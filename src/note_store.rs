// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::Result;
use thrift::transport::{TBufferedReadTransport, TBufferedWriteTransport};
use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TBinaryInputProtocol, TBinaryOutputProtocol, TFieldIdentifier, TInputProtocol, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::errors;
use crate::limits;
use crate::types;
use crate::user_store;

/// Privilege levels for accessing shared notebooks.
/// 
/// READ_NOTEBOOK: Recipient is able to read the contents of the shared notebook
///   but does not have access to information about other recipients of the
///   notebook or the activity stream information.
/// 
/// READ_NOTEBOOK_PLUS_ACTIVITY: Recipient has READ_NOTEBOOK rights and can also
///   access information about other recipients and the activity stream.
/// 
/// MODIFY_NOTEBOOK_PLUS_ACTIVITY: Recipient has rights to read and modify the contents
///   of the shared notebook, including the right to move notes to the trash and to create
///   notes in the notebook.  The recipient can also access information about other
///   recipients and the activity stream.
/// 
/// FULL_ACCESS: Recipient has full rights to the shared notebook and recipient lists,
///   including privilege to revoke and create invitations and to change privilege
///   levels on invitations for individuals. If the user is a member of the same group,
///   (e.g. the same business) as the shared notebook, they will additionally be granted
///   permissions to update the publishing status of the notebook.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShareRelationshipPrivilegeLevel(pub i32);

impl ShareRelationshipPrivilegeLevel {
  pub const READ_NOTEBOOK: ShareRelationshipPrivilegeLevel = ShareRelationshipPrivilegeLevel(0);
  pub const READ_NOTEBOOK_PLUS_ACTIVITY: ShareRelationshipPrivilegeLevel = ShareRelationshipPrivilegeLevel(10);
  pub const MODIFY_NOTEBOOK_PLUS_ACTIVITY: ShareRelationshipPrivilegeLevel = ShareRelationshipPrivilegeLevel(20);
  pub const FULL_ACCESS: ShareRelationshipPrivilegeLevel = ShareRelationshipPrivilegeLevel(30);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::READ_NOTEBOOK,
    Self::READ_NOTEBOOK_PLUS_ACTIVITY,
    Self::MODIFY_NOTEBOOK_PLUS_ACTIVITY,
    Self::FULL_ACCESS,
  ];
}

impl TSerializable for ShareRelationshipPrivilegeLevel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShareRelationshipPrivilegeLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(ShareRelationshipPrivilegeLevel::from(enum_value))
  }
}

impl From<i32> for ShareRelationshipPrivilegeLevel {
  fn from(i: i32) -> Self {
    match i {
      0 => ShareRelationshipPrivilegeLevel::READ_NOTEBOOK,
      10 => ShareRelationshipPrivilegeLevel::READ_NOTEBOOK_PLUS_ACTIVITY,
      20 => ShareRelationshipPrivilegeLevel::MODIFY_NOTEBOOK_PLUS_ACTIVITY,
      30 => ShareRelationshipPrivilegeLevel::FULL_ACCESS,
      _ => ShareRelationshipPrivilegeLevel(i)
    }
  }
}

impl From<&i32> for ShareRelationshipPrivilegeLevel {
  fn from(i: &i32) -> Self {
    ShareRelationshipPrivilegeLevel::from(*i)
  }
}

impl From<ShareRelationshipPrivilegeLevel> for i32 {
  fn from(e: ShareRelationshipPrivilegeLevel) -> i32 {
    e.0
  }
}

impl From<&ShareRelationshipPrivilegeLevel> for i32 {
  fn from(e: &ShareRelationshipPrivilegeLevel) -> i32 {
    e.0
  }
}

//
// SyncState
//

/// This structure encapsulates the information about the state of the
/// user's account for the purpose of "state based" synchronization.
/// <dl>
/// <dt>currentTime</dt>
///   <dd>
///   The server's current date and time.
///   </dd>
/// <dt>fullSyncBefore</dt>
///   <dd>
///   The cutoff date and time for client caches to be
///   updated via incremental synchronization.  Any clients that were last
///   synched with the server before this date/time must do a full resync of all
///   objects.  This cutoff point will change over time as archival data is
///   deleted or special circumstances on the service require resynchronization.
///   </dd>
/// <dt>updateCount</dt>
///   <dd>
///   Indicates the total number of transactions that have
///   been committed within the account.  This reflects (for example) the
///   number of discrete additions or modifications that have been made to
///   the data in this account (tags, notes, resources, etc.).
///   This number is the "high water mark" for Update Sequence Numbers (USN)
///   within the account.
///   </dd>
/// <dt>uploaded</dt>
///   <dd>
///   The total number of bytes that have been uploaded to
///   this account in the current monthly period.  This can be compared against
///   Accounting.uploadLimit (from the UserStore) to determine how close the user
///   is to their monthly upload limit.
///   This value may not be present if the SyncState has been retrieved by
///   a caller that only has read access to the account.
///   </dd>
/// <dt>userLastUpdated</dt>
///   <dd>
///   The last time when a user's account level information was changed. This value
///   is the latest time when a modification was made to any of the following:
///   accounting information (billing, quota, premium status, etc.), user attributes
///   and business user information (business name, business user attributes, etc.) if
///   the user is in a business.
///   Clients who need to maintain account information about a User should watch this
///   field for updates rather than polling UserStore.getUser for updates. Here is the
///   basic flow that clients should follow:
///   <ol>
///     <li>Call NoteStore.getSyncState to retrieve the SyncState object</li>
///     <li>Compare SyncState.userLastUpdated to previously stored value:
///         if (SyncState.userLastUpdated > previousValue)
///           call UserStore.getUser to get the latest User object;
///         else
///           do nothing;</li>
///     <li>Update previousValue = SyncState.userLastUpdated</li>
///   </ol>
///   </dd>
/// <dt>userMaxMessageEventId</dt>
///   <dd>
///   The greatest MessageEventID for this user's account. Clients that do a full
///   sync should store this value locally and compare their local copy to the
///   value returned by getSyncState to determine if they need to sync with
///   MessageStore. This value will be omitted if the user has never sent or
///   received a message.
///   </dd>
/// </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SyncState {
  pub current_time: types::Timestamp,
  pub full_sync_before: types::Timestamp,
  pub update_count: i32,
  pub uploaded: Option<i64>,
  pub user_last_updated: Option<types::Timestamp>,
  pub user_max_message_event_id: Option<types::MessageEventID>,
}

impl SyncState {
  pub fn new<F4, F5, F6>(current_time: types::Timestamp, full_sync_before: types::Timestamp, update_count: i32, uploaded: F4, user_last_updated: F5, user_max_message_event_id: F6) -> SyncState where F4: Into<Option<i64>>, F5: Into<Option<types::Timestamp>>, F6: Into<Option<types::MessageEventID>> {
    SyncState {
      current_time,
      full_sync_before,
      update_count,
      uploaded: uploaded.into(),
      user_last_updated: user_last_updated.into(),
      user_max_message_event_id: user_max_message_event_id.into(),
    }
  }
}

impl TSerializable for SyncState {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SyncState> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::Timestamp> = None;
    let mut f_2: Option<types::Timestamp> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<types::Timestamp> = None;
    let mut f_6: Option<types::MessageEventID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SyncState.current_time", &f_1)?;
    verify_required_field_exists("SyncState.full_sync_before", &f_2)?;
    verify_required_field_exists("SyncState.update_count", &f_3)?;
    let ret = SyncState {
      current_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      full_sync_before: f_2.expect("auto-generated code should have checked for presence of required fields"),
      update_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
      uploaded: f_4,
      user_last_updated: f_5,
      user_max_message_event_id: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SyncState");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("currentTime", TType::I64, 1))?;
    o_prot.write_i64(self.current_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fullSyncBefore", TType::I64, 2))?;
    o_prot.write_i64(self.full_sync_before)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updateCount", TType::I32, 3))?;
    o_prot.write_i32(self.update_count)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.uploaded {
      o_prot.write_field_begin(&TFieldIdentifier::new("uploaded", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_last_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("userLastUpdated", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_max_message_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userMaxMessageEventId", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SyncChunk
//

///  This structure is given out by the NoteStore when a client asks to
///  receive the current state of an account.  The client asks for the server's
///  state one chunk at a time in order to allow clients to retrieve the state
///  of a large account without needing to transfer the entire account in
///  a single message.
/// 
///  The server always gives SyncChunks using an ascending series of Update
///  Sequence Numbers (USNs).
/// 
/// <dl>
///  <dt>currentTime</dt>
///    <dd>
///    The server's current date and time.
///    </dd>
/// 
///  <dt>chunkHighUSN</dt>
///    <dd>
///    The highest USN for any of the data objects represented
///    in this sync chunk.  If there are no objects in the chunk, this will not be
///    set.
///    </dd>
/// 
///  <dt>updateCount</dt>
///    <dd>
///    The total number of updates that have been performed in
///    the service for this account.  This is equal to the highest USN within the
///    account at the point that this SyncChunk was generated.  If updateCount
///    and chunkHighUSN are identical, that means that this is the last chunk
///    in the account ... there is no more recent information.
///    </dd>
/// 
///  <dt>notes</dt>
///    <dd>
///    If present, this is a list of non-expunged notes that
///    have a USN in this chunk.  This will include notes that are "deleted"
///    but not expunged (i.e. in the trash).  The notes will include their list
///    of tags and resources, but the note content, resource content, resource
///    recognition data and resource alternate data will not be supplied.
///    </dd>
/// 
///  <dt>notebooks</dt>
///    <dd>
///    If present, this is a list of non-expunged notebooks that
///    have a USN in this chunk.
///    </dd>
/// 
///  <dt>tags</dt>
///    <dd>
///    If present, this is a list of the non-expunged tags that have a
///    USN in this chunk.
///    </dd>
/// 
///  <dt>searches</dt>
///    <dd>
///    If present, this is a list of non-expunged searches that
///    have a USN in this chunk.
///    </dd>
/// 
///  <dt>resources</dt>
///    <dd>
///    If present, this is a list of the non-expunged resources
///    that have a USN in this chunk.  This will include the metadata for each
///    resource, but not its binary contents or recognition data, which must be
///    retrieved separately.
///    </dd>
/// 
///  <dt>expungedNotes</dt>
///    <dd>
///    If present, the GUIDs of all of the notes that were
///    permanently expunged in this chunk.
///    </dd>
/// 
///  <dt>expungedNotebooks</dt>
///    <dd>
///    If present, the GUIDs of all of the notebooks that
///    were permanently expunged in this chunk.  When a notebook is expunged,
///    this implies that all of its child notes (and their resources) were
///    also expunged.
///    </dd>
/// 
///  <dt>expungedTags</dt>
///    <dd>
///    If present, the GUIDs of all of the tags that were
///    permanently expunged in this chunk.
///    </dd>
/// 
///  <dt>expungedSearches</dt>
///    <dd>
///    If present, the GUIDs of all of the saved searches
///    that were permanently expunged in this chunk.
///    </dd>
/// 
///  <dt>linkedNotebooks</dt>
///    <dd>
///    If present, this is a list of non-expunged LinkedNotebooks that
///    have a USN in this chunk.
///    </dd>
/// 
///  <dt>expungedLinkedNotebooks</dt>
///    <dd>
///    If present, the GUIDs of all of the LinkedNotebooks
///    that were permanently expunged in this chunk.
///    </dd>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SyncChunk {
  pub current_time: types::Timestamp,
  pub chunk_high_u_s_n: Option<i32>,
  pub update_count: i32,
  pub notes: Option<Vec<types::Note>>,
  pub notebooks: Option<Vec<types::Notebook>>,
  pub tags: Option<Vec<types::Tag>>,
  pub searches: Option<Vec<types::SavedSearch>>,
  pub resources: Option<Vec<types::Resource>>,
  pub expunged_notes: Option<Vec<types::Guid>>,
  pub expunged_notebooks: Option<Vec<types::Guid>>,
  pub expunged_tags: Option<Vec<types::Guid>>,
  pub expunged_searches: Option<Vec<types::Guid>>,
  pub linked_notebooks: Option<Vec<types::LinkedNotebook>>,
  pub expunged_linked_notebooks: Option<Vec<types::Guid>>,
}

impl SyncChunk {
  pub fn new<F2, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14>(current_time: types::Timestamp, chunk_high_u_s_n: F2, update_count: i32, notes: F4, notebooks: F5, tags: F6, searches: F7, resources: F8, expunged_notes: F9, expunged_notebooks: F10, expunged_tags: F11, expunged_searches: F12, linked_notebooks: F13, expunged_linked_notebooks: F14) -> SyncChunk where F2: Into<Option<i32>>, F4: Into<Option<Vec<types::Note>>>, F5: Into<Option<Vec<types::Notebook>>>, F6: Into<Option<Vec<types::Tag>>>, F7: Into<Option<Vec<types::SavedSearch>>>, F8: Into<Option<Vec<types::Resource>>>, F9: Into<Option<Vec<types::Guid>>>, F10: Into<Option<Vec<types::Guid>>>, F11: Into<Option<Vec<types::Guid>>>, F12: Into<Option<Vec<types::Guid>>>, F13: Into<Option<Vec<types::LinkedNotebook>>>, F14: Into<Option<Vec<types::Guid>>> {
    SyncChunk {
      current_time,
      chunk_high_u_s_n: chunk_high_u_s_n.into(),
      update_count,
      notes: notes.into(),
      notebooks: notebooks.into(),
      tags: tags.into(),
      searches: searches.into(),
      resources: resources.into(),
      expunged_notes: expunged_notes.into(),
      expunged_notebooks: expunged_notebooks.into(),
      expunged_tags: expunged_tags.into(),
      expunged_searches: expunged_searches.into(),
      linked_notebooks: linked_notebooks.into(),
      expunged_linked_notebooks: expunged_linked_notebooks.into(),
    }
  }
}

impl TSerializable for SyncChunk {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SyncChunk> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::Timestamp> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Vec<types::Note>> = None;
    let mut f_5: Option<Vec<types::Notebook>> = None;
    let mut f_6: Option<Vec<types::Tag>> = None;
    let mut f_7: Option<Vec<types::SavedSearch>> = None;
    let mut f_8: Option<Vec<types::Resource>> = None;
    let mut f_9: Option<Vec<types::Guid>> = None;
    let mut f_10: Option<Vec<types::Guid>> = None;
    let mut f_11: Option<Vec<types::Guid>> = None;
    let mut f_12: Option<Vec<types::Guid>> = None;
    let mut f_13: Option<Vec<types::LinkedNotebook>> = None;
    let mut f_14: Option<Vec<types::Guid>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Note> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = types::Note::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Notebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = types::Notebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Tag> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = types::Tag::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::SavedSearch> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = types::SavedSearch::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Resource> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = types::Resource::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = i_prot.read_string()?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_string()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        13 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::LinkedNotebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = types::LinkedNotebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_13 = Some(val);
        },
        14 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = i_prot.read_string()?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_14 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SyncChunk.current_time", &f_1)?;
    verify_required_field_exists("SyncChunk.update_count", &f_3)?;
    let ret = SyncChunk {
      current_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      chunk_high_u_s_n: f_2,
      update_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
      notes: f_4,
      notebooks: f_5,
      tags: f_6,
      searches: f_7,
      resources: f_8,
      expunged_notes: f_9,
      expunged_notebooks: f_10,
      expunged_tags: f_11,
      expunged_searches: f_12,
      linked_notebooks: f_13,
      expunged_linked_notebooks: f_14,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SyncChunk");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("currentTime", TType::I64, 1))?;
    o_prot.write_i64(self.current_time)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.chunk_high_u_s_n {
      o_prot.write_field_begin(&TFieldIdentifier::new("chunkHighUSN", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("updateCount", TType::I32, 3))?;
    o_prot.write_i32(self.update_count)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("notes", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebooks", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.searches {
      o_prot.write_field_begin(&TFieldIdentifier::new("searches", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resources {
      o_prot.write_field_begin(&TFieldIdentifier::new("resources", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expunged_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("expungedNotes", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expunged_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("expungedNotebooks", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expunged_tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("expungedTags", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expunged_searches {
      o_prot.write_field_begin(&TFieldIdentifier::new("expungedSearches", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.linked_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("linkedNotebooks", TType::List, 13))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expunged_linked_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("expungedLinkedNotebooks", TType::List, 14))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SyncChunkFilter
//

///  This structure is used with the 'getFilteredSyncChunk' call to provide
///  fine-grained control over the data that's returned when a client needs
///  to synchronize with the service. Each flag in this structure specifies
///  whether to include one class of data in the results of that call.
/// 
/// <dl>
///  <dt>includeNotes</dt>
///    <dd>
///    If true, then the server will include the SyncChunks.notes field
///    </dd>
/// 
///  <dt>includeNoteResources</dt>
///    <dd>
///    If true, then the server will include the 'resources' field on all of
///    the Notes that are in SyncChunk.notes.
///    If 'includeNotes' is false, then this will have no effect.
///    </dd>
/// 
///  <dt>includeNoteAttributes</dt>
///    <dd>
///    If true, then the server will include the 'attributes' field on all of
///    the Notes that are in SyncChunks.notes.
///    If 'includeNotes' is false, then this will have no effect.
///    </dd>
/// 
///  <dt>includeNotebooks</dt>
///    <dd>
///    If true, then the server will include the SyncChunks.notebooks field
///    </dd>
/// 
///  <dt>includeTags</dt>
///    <dd>
///    If true, then the server will include the SyncChunks.tags field
///    </dd>
/// 
///  <dt>includeSearches</dt>
///    <dd>
///    If true, then the server will include the SyncChunks.searches field
///    </dd>
/// 
///  <dt>includeResources</dt>
///    <dd>
///    If true, then the server will include the SyncChunks.resources field.
///    Since the Resources are also provided with their Note
///    (in the Notes.resources list), this is primarily useful for clients that
///    want to watch for changes to individual Resources due to recognition data
///    being added.
///    </dd>
/// 
///  <dt>includeLinkedNotebooks</dt>
///    <dd>
///    If true, then the server will include the SyncChunks.linkedNotebooks field.
///    </dd>
/// 
///  <dt>includeExpunged</dt>
///    <dd>
///    If true, then the server will include the 'expunged' data for any type
///    of included data.  For example, if 'includeTags' and 'includeExpunged'
///    are both true, then the SyncChunks.expungedTags field will be set with
///    the GUIDs of tags that have been expunged from the server.
///    </dd>
/// 
///  <dt>includeNoteApplicationDataFullMap</dt>
///    <dd>
///    If true, then the values for the applicationData map will be filled
///    in, assuming notes and note attributes are being returned.  Otherwise,
///    only the keysOnly field will be filled in.
///    </dd>
/// 
///  <dt>includeResourceApplicationDataFullMap</dt>
///    <dd>
///    If true, then the fullMap values for the applicationData map will be
///    filled in, assuming resources and resource attributes are being returned
///    (includeResources is true).  Otherwise, only the keysOnly field will be
///    filled in.
///    </dd>
/// 
///  <dt>includeNoteResourceApplicationDataFullMap</dt>
///    <dd>
///    If true, then the fullMap values for the applicationData map will be
///    filled in for resources found inside of notes, assuming resources are
///    being returned in notes (includeNoteResources is true).  Otherwise,
///    only the keysOnly field will be filled in.
///    </dd>
/// 
///  <dt>omitSharedNotebooks<dt>
///    <dd>
///    Normally, if 'includeNotebooks' is true, then the SyncChunks will
///    include Notebooks that may include a set of SharedNotebook
///    invitations via Notebook.sharedNotebookIds and Notebook.sharedNotebooks.
///    However, if omitSharedNotebooks is set to true, then the Notebooks
///    will omit those two fields and leave them unset. This should be used
///    by clients who want to know their own set of Notebooks (and the
///    associated permissions via Notebook.recipientSettings), and who
///    do not need to know the full set of other people who can also see
///    that same notebook.
///    </dd>
/// 
///  <dt>requireNoteContentClass</dt>
///    <dd>
///    If set, then only send notes whose content class matches this value.
///    The value can be a literal match or, if the last character is an
///    asterisk, a prefix match.
///    </dd>
/// 
///  <dt>notebookGuids</dt>
///    <dd>
///    If set, then restrict the returned notebooks, notes, and
///    resources to those associated with one of the notebooks whose
///    GUID is provided in this list.  If not set, then no filtering on
///    notebook GUID will be performed.  If you set this field, you may
///    not also set includeExpunged else an EDAMUserException with an
///    error code of DATA_CONFLICT will be thrown.  You only need to set
///    this field if you want to restrict the returned entities more
///    than what your authentication token allows you to access.  For
///    example, there is no need to set this field for single notebook
///    tokens such as for shared notebooks.  You can use this field to
///    synchronize a newly discovered business notebook while
///    incrementally synchronizing a business account, in which case you
///    will only need to consider setting includeNotes,
///    includeNotebooks, includeNoteAttributes, includeNoteResources,
///    and maybe some of the "FullMap" fields.
///    </dd>
/// 
///  <dt>includeSharedNotes</dt>
///    <dd>
///    If true, then the service will include the sharedNotes field on all
///    notes that are in SyncChunk.notes. If 'includeNotes' is false, then
///    this will have no effect.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SyncChunkFilter {
  pub include_notes: Option<bool>,
  pub include_note_resources: Option<bool>,
  pub include_note_attributes: Option<bool>,
  pub include_notebooks: Option<bool>,
  pub include_tags: Option<bool>,
  pub include_searches: Option<bool>,
  pub include_resources: Option<bool>,
  pub include_linked_notebooks: Option<bool>,
  pub include_expunged: Option<bool>,
  pub include_note_application_data_full_map: Option<bool>,
  pub require_note_content_class: Option<String>,
  pub include_resource_application_data_full_map: Option<bool>,
  pub include_note_resource_application_data_full_map: Option<bool>,
  pub notebook_guids: Option<BTreeSet<String>>,
  pub omit_shared_notebooks: Option<bool>,
  pub include_shared_notes: Option<bool>,
}

impl SyncChunkFilter {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F15, F16, F17>(include_notes: F1, include_note_resources: F2, include_note_attributes: F3, include_notebooks: F4, include_tags: F5, include_searches: F6, include_resources: F7, include_linked_notebooks: F8, include_expunged: F9, include_note_application_data_full_map: F10, require_note_content_class: F11, include_resource_application_data_full_map: F12, include_note_resource_application_data_full_map: F13, notebook_guids: F15, omit_shared_notebooks: F16, include_shared_notes: F17) -> SyncChunkFilter where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<String>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F15: Into<Option<BTreeSet<String>>>, F16: Into<Option<bool>>, F17: Into<Option<bool>> {
    SyncChunkFilter {
      include_notes: include_notes.into(),
      include_note_resources: include_note_resources.into(),
      include_note_attributes: include_note_attributes.into(),
      include_notebooks: include_notebooks.into(),
      include_tags: include_tags.into(),
      include_searches: include_searches.into(),
      include_resources: include_resources.into(),
      include_linked_notebooks: include_linked_notebooks.into(),
      include_expunged: include_expunged.into(),
      include_note_application_data_full_map: include_note_application_data_full_map.into(),
      require_note_content_class: require_note_content_class.into(),
      include_resource_application_data_full_map: include_resource_application_data_full_map.into(),
      include_note_resource_application_data_full_map: include_note_resource_application_data_full_map.into(),
      notebook_guids: notebook_guids.into(),
      omit_shared_notebooks: omit_shared_notebooks.into(),
      include_shared_notes: include_shared_notes.into(),
    }
  }
}

impl TSerializable for SyncChunkFilter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SyncChunkFilter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = None;
    let mut f_15: Option<BTreeSet<String>> = None;
    let mut f_16: Option<bool> = None;
    let mut f_17: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        15 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_11 = i_prot.read_string()?;
            val.insert(set_elem_11);
          }
          i_prot.read_set_end()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_bool()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_bool()?;
          f_17 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SyncChunkFilter {
      include_notes: f_1,
      include_note_resources: f_2,
      include_note_attributes: f_3,
      include_notebooks: f_4,
      include_tags: f_5,
      include_searches: f_6,
      include_resources: f_7,
      include_linked_notebooks: f_8,
      include_expunged: f_9,
      include_note_application_data_full_map: f_10,
      require_note_content_class: f_11,
      include_resource_application_data_full_map: f_12,
      include_note_resource_application_data_full_map: f_13,
      notebook_guids: f_15,
      omit_shared_notebooks: f_16,
      include_shared_notes: f_17,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SyncChunkFilter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.include_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNotes", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_note_resources {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNoteResources", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_note_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNoteAttributes", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNotebooks", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeTags", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_searches {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeSearches", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_resources {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeResources", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_linked_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeLinkedNotebooks", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_expunged {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeExpunged", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_note_application_data_full_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNoteApplicationDataFullMap", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.require_note_content_class {
      o_prot.write_field_begin(&TFieldIdentifier::new("requireNoteContentClass", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_resource_application_data_full_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeResourceApplicationDataFullMap", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_note_resource_application_data_full_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNoteResourceApplicationDataFullMap", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebook_guids {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuids", TType::Set, 15))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.omit_shared_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("omitSharedNotebooks", TType::Bool, 16))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_shared_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeSharedNotes", TType::Bool, 17))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteFilter
//

///  A list of criteria that are used to indicate which notes are desired from
///  the account.  This is used in queries to the NoteStore to determine
///  which notes should be retrieved.
/// 
/// <dl>
///  <dt>order</dt>
///    <dd>
///    The NoteSortOrder value indicating what criterion should be
///    used to sort the results of the filter.
///    </dd>
/// 
///  <dt>ascending</dt>
///    <dd>
///    If true, the results will be ascending in the requested
///    sort order.  If false, the results will be descending.
///    </dd>
/// 
///  <dt>words</dt>
///    <dd>
///    If present, a search query string that will filter the set of notes to be returned.
///    Accepts the full search grammar documented in the Evernote API Overview.
///    </dd>
/// 
///  <dt>notebookGuid</dt>
///    <dd>
///    If present, the Guid of the notebook that must contain
///    the notes.
///    </dd>
/// 
///  <dt>tagGuids</dt>
///    <dd>
///    If present, the list of tags (by GUID) that must be present
///    on the notes.
///    </dd>
/// 
///  <dt>timeZone</dt>
///    <dd>
///    The zone ID for the user, which will be used to interpret
///    any dates or times in the queries that do not include their desired zone
///    information.
///    For example, if a query requests notes created "yesterday", this
///    will be evaluated from the provided time zone, if provided.
///    The format must be encoded as a standard zone ID such as
///    "America/Los_Angeles".
///    </dd>
/// 
///  <dt>inactive</dt>
///    <dd>
///    If true, then only notes that are not active (i.e. notes in
///    the Trash) will be returned. Otherwise, only active notes will be returned.
///    There is no way to find both active and inactive notes in a single query.
///    </dd>
/// 
///  <dt>emphasized</dt>
///    <dd>
///    If present, a search query string that may or may not influence the notes
///    to be returned, both in terms of coverage as well as of order. Think of it
///    as a wish list, not a requirement.
///    Accepts the full search grammar documented in the Evernote API Overview.
///    </dd>
/// 
///  <dt>includeAllReadableNotebooks</dt>
///    <dd>
///    If true, then the search will include all business notebooks that are readable
///    by the user. A business authentication token must be supplied for
///    this option to take effect when calling search APIs.
///    </dd>
/// 
///  <dt>includeAllReadableWorkspaces</dt>
///    <dd>
///    If true, then the search will include all workspaces that are readable
///    by the user. A business authentication token must be supplied for
///    this option to take effect when calling search APIs.
///    </dd>
/// 
///  <dt>context</dt>
///    <dd>
///    Specifies the context to consider when determining result ranking.
///    Clients must leave this value unset unless they wish to explicitly specify a known
///    non-default context.
///    </dd>
/// 
///  <dt>rawWords</dt>
///    <dd>
///    If present, the raw user query input.
///    Accepts the full search grammar documented in the Evernote API Overview.
///    </dd>
/// 
///  <dt>searchContextBytes</dt>
///    <dd>
///    Specifies the correlating information about the current search session, in byte array.
///    If this request is not for the first page of search results, the client should populate
///    this field with the value of searchContextBytes from the NotesMetadataList of the
///    original search response.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteFilter {
  pub order: Option<i32>,
  pub ascending: Option<bool>,
  pub words: Option<String>,
  pub notebook_guid: Option<types::Guid>,
  pub tag_guids: Option<Vec<types::Guid>>,
  pub time_zone: Option<String>,
  pub inactive: Option<bool>,
  pub emphasized: Option<String>,
  pub include_all_readable_notebooks: Option<bool>,
  pub context: Option<String>,
  pub raw_words: Option<String>,
  pub search_context_bytes: Option<Vec<u8>>,
  pub include_all_readable_workspaces: Option<bool>,
}

impl NoteFilter {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F15>(order: F1, ascending: F2, words: F3, notebook_guid: F4, tag_guids: F5, time_zone: F6, inactive: F7, emphasized: F8, include_all_readable_notebooks: F9, context: F10, raw_words: F11, search_context_bytes: F12, include_all_readable_workspaces: F15) -> NoteFilter where F1: Into<Option<i32>>, F2: Into<Option<bool>>, F3: Into<Option<String>>, F4: Into<Option<types::Guid>>, F5: Into<Option<Vec<types::Guid>>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<String>>, F9: Into<Option<bool>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<Vec<u8>>>, F15: Into<Option<bool>> {
    NoteFilter {
      order: order.into(),
      ascending: ascending.into(),
      words: words.into(),
      notebook_guid: notebook_guid.into(),
      tag_guids: tag_guids.into(),
      time_zone: time_zone.into(),
      inactive: inactive.into(),
      emphasized: emphasized.into(),
      include_all_readable_notebooks: include_all_readable_notebooks.into(),
      context: context.into(),
      raw_words: raw_words.into(),
      search_context_bytes: search_context_bytes.into(),
      include_all_readable_workspaces: include_all_readable_workspaces.into(),
    }
  }
}

impl TSerializable for NoteFilter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteFilter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<types::Guid> = None;
    let mut f_5: Option<Vec<types::Guid>> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<Vec<u8>> = None;
    let mut f_15: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_string()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bytes()?;
          f_12 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteFilter {
      order: f_1,
      ascending: f_2,
      words: f_3,
      notebook_guid: f_4,
      tag_guids: f_5,
      time_zone: f_6,
      inactive: f_7,
      emphasized: f_8,
      include_all_readable_notebooks: f_9,
      context: f_10,
      raw_words: f_11,
      search_context_bytes: f_12,
      include_all_readable_workspaces: f_15,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteFilter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.order {
      o_prot.write_field_begin(&TFieldIdentifier::new("order", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ascending {
      o_prot.write_field_begin(&TFieldIdentifier::new("ascending", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.words {
      o_prot.write_field_begin(&TFieldIdentifier::new("words", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebook_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tag_guids {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagGuids", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.time_zone {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeZone", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.inactive {
      o_prot.write_field_begin(&TFieldIdentifier::new("inactive", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.emphasized {
      o_prot.write_field_begin(&TFieldIdentifier::new("emphasized", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_all_readable_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeAllReadableNotebooks", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.context {
      o_prot.write_field_begin(&TFieldIdentifier::new("context", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.raw_words {
      o_prot.write_field_begin(&TFieldIdentifier::new("rawWords", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_context_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchContextBytes", TType::String, 12))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_all_readable_workspaces {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeAllReadableWorkspaces", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteList
//

///  A small structure for returning a list of notes out of a larger set.
/// 
/// <dl>
///  <dt>startIndex</dt>
///    <dd>
///    The starting index within the overall set of notes.  This
///    is also the number of notes that are "before" this list in the set.
///    </dd>
/// 
///  <dt>totalNotes</dt>
///    <dd>
///    The number of notes in the larger set.  This can be used
///    to calculate how many notes are "after" this note in the set.
///    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
///    </dd>
/// 
///  <dt>notes</dt>
///    <dd>
///    The list of notes from this range.  The Notes will include all
///    metadata (attributes, resources, etc.), but will not include the ENML
///    content of the note or the binary contents of any resources.
///    </dd>
/// 
///  <dt>stoppedWords</dt>
///    <dd>
///    If the NoteList was produced using a text based search
///    query that included words that are not indexed or searched by the service,
///    this will include a list of those ignored words.
///    </dd>
/// 
///  <dt>searchedWords</dt>
///    <dd>
///    If the NoteList was produced using a text based search
///    query that included viable search words or quoted expressions, this will
///    include a list of those words.  Any stopped words will not be included
///    in this list.
///    </dd>
/// 
///  <dt>updateCount</dt>
///    <dd>
///    Indicates the total number of transactions that have
///    been committed within the account.  This reflects (for example) the
///    number of discrete additions or modifications that have been made to
///    the data in this account (tags, notes, resources, etc.).
///    This number is the "high water mark" for Update Sequence Numbers (USN)
///    within the account.
///    </dd>
/// 
///  <dt>searchContextBytes</dt>
///    <dd>
///    Specifies the correlating information about the current search session, in byte array.
///    </dd>
///  </dl>
/// 
///  <dt>debugInfo</dt>
///    <dd>
///    Depends on the value of <code>context</code> in NoteFilter, this field
///    may contain debug information if the service decides to do so.
///    </dd>
/// 
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteList {
  pub start_index: i32,
  pub total_notes: i32,
  pub notes: Vec<types::Note>,
  pub stopped_words: Option<Vec<String>>,
  pub searched_words: Option<Vec<String>>,
  pub update_count: Option<i32>,
  pub search_context_bytes: Option<Vec<u8>>,
  pub debug_info: Option<String>,
}

impl NoteList {
  pub fn new<F4, F5, F6, F7, F8>(start_index: i32, total_notes: i32, notes: Vec<types::Note>, stopped_words: F4, searched_words: F5, update_count: F6, search_context_bytes: F7, debug_info: F8) -> NoteList where F4: Into<Option<Vec<String>>>, F5: Into<Option<Vec<String>>>, F6: Into<Option<i32>>, F7: Into<Option<Vec<u8>>>, F8: Into<Option<String>> {
    NoteList {
      start_index,
      total_notes,
      notes,
      stopped_words: stopped_words.into(),
      searched_words: searched_words.into(),
      update_count: update_count.into(),
      search_context_bytes: search_context_bytes.into(),
      debug_info: debug_info.into(),
    }
  }
}

impl TSerializable for NoteList {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<types::Note>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<Vec<u8>> = None;
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Note> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = types::Note::read_from_in_protocol(i_prot)?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = i_prot.read_string()?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = i_prot.read_string()?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bytes()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteList.start_index", &f_1)?;
    verify_required_field_exists("NoteList.total_notes", &f_2)?;
    verify_required_field_exists("NoteList.notes", &f_3)?;
    let ret = NoteList {
      start_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
      total_notes: f_2.expect("auto-generated code should have checked for presence of required fields"),
      notes: f_3.expect("auto-generated code should have checked for presence of required fields"),
      stopped_words: f_4,
      searched_words: f_5,
      update_count: f_6,
      search_context_bytes: f_7,
      debug_info: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteList");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startIndex", TType::I32, 1))?;
    o_prot.write_i32(self.start_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("totalNotes", TType::I32, 2))?;
    o_prot.write_i32(self.total_notes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notes", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.notes.len() as i32))?;
    for e in &self.notes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.stopped_words {
      o_prot.write_field_begin(&TFieldIdentifier::new("stoppedWords", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.searched_words {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchedWords", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateCount", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_context_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchContextBytes", TType::String, 7))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.debug_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("debugInfo", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteMetadata
//

/// This structure is used in the set of results returned by the
/// findNotesMetadata function.  It represents the high-level information about
/// a single Note, without some of the larger deep structure.  This allows
/// for the information about a list of Notes to be returned relatively quickly
/// with less marshalling and data transfer to remote clients.
/// Most fields in this structure are identical to the corresponding field in
/// the Note structure, with the exception of:
/// 
/// <dl>
/// <dt>largestResourceMime</dt>
///   <dd>If set, then this will contain the MIME type of the largest Resource
///   (in bytes) within the Note.  This may be useful, for example, to choose
///   an appropriate icon or thumbnail to represent the Note.
///   </dd>
/// 
/// <dt>largestResourceSize</dt>
///  <dd>If set, this will contain the size of the largest Resource file, in
///  bytes, within the Note.  This may be useful, for example, to decide whether
///  to ask the server for a thumbnail to represent the Note.
///  </dd>
/// </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteMetadata {
  pub guid: types::Guid,
  pub title: Option<String>,
  pub content_length: Option<i32>,
  pub created: Option<types::Timestamp>,
  pub updated: Option<types::Timestamp>,
  pub deleted: Option<types::Timestamp>,
  pub update_sequence_num: Option<i32>,
  pub notebook_guid: Option<String>,
  pub tag_guids: Option<Vec<types::Guid>>,
  pub attributes: Option<types::NoteAttributes>,
  pub largest_resource_mime: Option<String>,
  pub largest_resource_size: Option<i32>,
}

impl NoteMetadata {
  pub fn new<F2, F5, F6, F7, F8, F10, F11, F12, F14, F20, F21>(guid: types::Guid, title: F2, content_length: F5, created: F6, updated: F7, deleted: F8, update_sequence_num: F10, notebook_guid: F11, tag_guids: F12, attributes: F14, largest_resource_mime: F20, largest_resource_size: F21) -> NoteMetadata where F2: Into<Option<String>>, F5: Into<Option<i32>>, F6: Into<Option<types::Timestamp>>, F7: Into<Option<types::Timestamp>>, F8: Into<Option<types::Timestamp>>, F10: Into<Option<i32>>, F11: Into<Option<String>>, F12: Into<Option<Vec<types::Guid>>>, F14: Into<Option<types::NoteAttributes>>, F20: Into<Option<String>>, F21: Into<Option<i32>> {
    NoteMetadata {
      guid,
      title: title.into(),
      content_length: content_length.into(),
      created: created.into(),
      updated: updated.into(),
      deleted: deleted.into(),
      update_sequence_num: update_sequence_num.into(),
      notebook_guid: notebook_guid.into(),
      tag_guids: tag_guids.into(),
      attributes: attributes.into(),
      largest_resource_mime: largest_resource_mime.into(),
      largest_resource_size: largest_resource_size.into(),
    }
  }
}

impl TSerializable for NoteMetadata {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteMetadata> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::Guid> = None;
    let mut f_2: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<types::Timestamp> = None;
    let mut f_7: Option<types::Timestamp> = None;
    let mut f_8: Option<types::Timestamp> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<Vec<types::Guid>> = None;
    let mut f_14: Option<types::NoteAttributes> = None;
    let mut f_20: Option<String> = None;
    let mut f_21: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_string()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        14 => {
          let val = types::NoteAttributes::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_i32()?;
          f_21 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteMetadata.guid", &f_1)?;
    let ret = NoteMetadata {
      guid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      title: f_2,
      content_length: f_5,
      created: f_6,
      updated: f_7,
      deleted: f_8,
      update_sequence_num: f_10,
      notebook_guid: f_11,
      tag_guids: f_12,
      attributes: f_14,
      largest_resource_mime: f_20,
      largest_resource_size: f_21,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteMetadata");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.content_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentLength", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created {
      o_prot.write_field_begin(&TFieldIdentifier::new("created", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("updated", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.deleted {
      o_prot.write_field_begin(&TFieldIdentifier::new("deleted", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebook_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tag_guids {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagGuids", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.largest_resource_mime {
      o_prot.write_field_begin(&TFieldIdentifier::new("largestResourceMime", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.largest_resource_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("largestResourceSize", TType::I32, 21))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotesMetadataList
//

///  This structure is returned from calls to the findNotesMetadata function to
///  give the high-level metadata about a subset of Notes that are found to
///  match a specified NoteFilter in a search.
/// 
/// <dl>
///  <dt>startIndex</dt>
///    <dd>
///    The starting index within the overall set of notes.  This
///    is also the number of notes that are "before" this list in the set.
///    </dd>
/// 
///  <dt>totalNotes</dt>
///    <dd>
///    The number of notes in the larger set.  This can be used
///    to calculate how many notes are "after" this note in the set.
///    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
///    </dd>
/// 
///  <dt>notes</dt>
///    <dd>
///    The list of metadata for Notes in this range.  The set of optional fields
///    that are set in each metadata structure will depend on the
///    NotesMetadataResultSpec provided by the caller when the search was
///    performed.  Only the 'guid' field will be guaranteed to be set in each
///    Note.
///    </dd>
/// 
///  <dt>stoppedWords</dt>
///    <dd>
///    If the NoteList was produced using a text based search
///    query that included words that are not indexed or searched by the service,
///    this will include a list of those ignored words.
///    </dd>
/// 
///  <dt>searchedWords</dt>
///    <dd>
///    If the NoteList was produced using a text based search
///    query that included viable search words or quoted expressions, this will
///    include a list of those words.  Any stopped words will not be included
///    in this list.
///    </dd>
/// 
///  <dt>updateCount</dt>
///    <dd>
///    Indicates the total number of transactions that have
///    been committed within the account.  This reflects (for example) the
///    number of discrete additions or modifications that have been made to
///    the data in this account (tags, notes, resources, etc.).
///    This number is the "high water mark" for Update Sequence Numbers (USN)
///    within the account.
///    </dd>
/// 
///  <dt>searchContextBytes</dt>
///    <dd>
///    Specifies the correlating information about the current search session, in byte array.
///    </dd>
/// 
///  <dt>debugInfo</dt>
///    <dd>
///    Depends on the value of <code>context</code> in NoteFilter, this field
///    may contain debug information if the service decides to do so.
///    </dd>
/// 
///  </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotesMetadataList {
  pub start_index: i32,
  pub total_notes: i32,
  pub notes: Vec<NoteMetadata>,
  pub stopped_words: Option<Vec<String>>,
  pub searched_words: Option<Vec<String>>,
  pub update_count: Option<i32>,
  pub search_context_bytes: Option<Vec<u8>>,
  pub debug_info: Option<String>,
}

impl NotesMetadataList {
  pub fn new<F4, F5, F6, F7, F9>(start_index: i32, total_notes: i32, notes: Vec<NoteMetadata>, stopped_words: F4, searched_words: F5, update_count: F6, search_context_bytes: F7, debug_info: F9) -> NotesMetadataList where F4: Into<Option<Vec<String>>>, F5: Into<Option<Vec<String>>>, F6: Into<Option<i32>>, F7: Into<Option<Vec<u8>>>, F9: Into<Option<String>> {
    NotesMetadataList {
      start_index,
      total_notes,
      notes,
      stopped_words: stopped_words.into(),
      searched_words: searched_words.into(),
      update_count: update_count.into(),
      search_context_bytes: search_context_bytes.into(),
      debug_info: debug_info.into(),
    }
  }
}

impl TSerializable for NotesMetadataList {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotesMetadataList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<NoteMetadata>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<Vec<u8>> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NoteMetadata> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = NoteMetadata::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = i_prot.read_string()?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bytes()?;
          f_7 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotesMetadataList.start_index", &f_1)?;
    verify_required_field_exists("NotesMetadataList.total_notes", &f_2)?;
    verify_required_field_exists("NotesMetadataList.notes", &f_3)?;
    let ret = NotesMetadataList {
      start_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
      total_notes: f_2.expect("auto-generated code should have checked for presence of required fields"),
      notes: f_3.expect("auto-generated code should have checked for presence of required fields"),
      stopped_words: f_4,
      searched_words: f_5,
      update_count: f_6,
      search_context_bytes: f_7,
      debug_info: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotesMetadataList");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startIndex", TType::I32, 1))?;
    o_prot.write_i32(self.start_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("totalNotes", TType::I32, 2))?;
    o_prot.write_i32(self.total_notes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notes", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.notes.len() as i32))?;
    for e in &self.notes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.stopped_words {
      o_prot.write_field_begin(&TFieldIdentifier::new("stoppedWords", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.searched_words {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchedWords", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateCount", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_context_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchContextBytes", TType::String, 7))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.debug_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("debugInfo", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotesMetadataResultSpec
//

/// This structure is provided to the findNotesMetadata function to specify
/// the subset of fields that should be included in each NoteMetadata element
/// that is returned in the NotesMetadataList.
/// Each field on this structure is a boolean flag that indicates whether the
/// corresponding field should be included in the NoteMetadata structure when
/// it is returned.  For example, if the 'includeTitle' field is set on this
/// structure when calling findNotesMetadata, then each NoteMetadata in the
/// list should have its 'title' field set.
/// If one of the fields in this spec is not set, then it will be treated as
/// 'false' by the server, so the default behavior is to include nothing in
/// replies (but the mandatory GUID)
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotesMetadataResultSpec {
  pub include_title: Option<bool>,
  pub include_content_length: Option<bool>,
  pub include_created: Option<bool>,
  pub include_updated: Option<bool>,
  pub include_deleted: Option<bool>,
  pub include_update_sequence_num: Option<bool>,
  pub include_notebook_guid: Option<bool>,
  pub include_tag_guids: Option<bool>,
  pub include_attributes: Option<bool>,
  pub include_largest_resource_mime: Option<bool>,
  pub include_largest_resource_size: Option<bool>,
}

impl NotesMetadataResultSpec {
  pub fn new<F2, F5, F6, F7, F8, F10, F11, F12, F14, F20, F21>(include_title: F2, include_content_length: F5, include_created: F6, include_updated: F7, include_deleted: F8, include_update_sequence_num: F10, include_notebook_guid: F11, include_tag_guids: F12, include_attributes: F14, include_largest_resource_mime: F20, include_largest_resource_size: F21) -> NotesMetadataResultSpec where F2: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<bool>>, F12: Into<Option<bool>>, F14: Into<Option<bool>>, F20: Into<Option<bool>>, F21: Into<Option<bool>> {
    NotesMetadataResultSpec {
      include_title: include_title.into(),
      include_content_length: include_content_length.into(),
      include_created: include_created.into(),
      include_updated: include_updated.into(),
      include_deleted: include_deleted.into(),
      include_update_sequence_num: include_update_sequence_num.into(),
      include_notebook_guid: include_notebook_guid.into(),
      include_tag_guids: include_tag_guids.into(),
      include_attributes: include_attributes.into(),
      include_largest_resource_mime: include_largest_resource_mime.into(),
      include_largest_resource_size: include_largest_resource_size.into(),
    }
  }
}

impl TSerializable for NotesMetadataResultSpec {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotesMetadataResultSpec> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<bool> = None;
    let mut f_14: Option<bool> = None;
    let mut f_20: Option<bool> = None;
    let mut f_21: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_bool()?;
          f_21 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotesMetadataResultSpec {
      include_title: f_2,
      include_content_length: f_5,
      include_created: f_6,
      include_updated: f_7,
      include_deleted: f_8,
      include_update_sequence_num: f_10,
      include_notebook_guid: f_11,
      include_tag_guids: f_12,
      include_attributes: f_14,
      include_largest_resource_mime: f_20,
      include_largest_resource_size: f_21,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotesMetadataResultSpec");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.include_title {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeTitle", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_content_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeContentLength", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_created {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeCreated", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeUpdated", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_deleted {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeDeleted", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeUpdateSequenceNum", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_notebook_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNotebookGuid", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_tag_guids {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeTagGuids", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeAttributes", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_largest_resource_mime {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeLargestResourceMime", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_largest_resource_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeLargestResourceSize", TType::Bool, 21))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteCollectionCounts
//

///  A data structure representing the number of notes for each notebook
///  and tag with a non-zero set of applicable notes.
/// 
/// <dl>
///  <dt>notebookCounts</dt>
///    <dd>
///    A mapping from the Notebook GUID to the number of
///    notes (from some selection) that are in the corresponding notebook.
///    </dd>
/// 
///  <dt>tagCounts</dt>
///    <dd>
///    A mapping from the Tag GUID to the number of notes (from some
///    selection) that have the corresponding tag.
///    </dd>
/// 
///  <dt>trashCount</dt>
///    <dd>
///    If this is set, then this is the number of notes that are in the trash.
///    If this is not set, then the number of notes in the trash hasn't been
///    reported.  (I.e. if there are no notes in the trash, this will be set
///    to 0.)
///    </dd>
///  </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteCollectionCounts {
  pub notebook_counts: Option<BTreeMap<types::Guid, i32>>,
  pub tag_counts: Option<BTreeMap<types::Guid, i32>>,
  pub trash_count: Option<i32>,
}

impl NoteCollectionCounts {
  pub fn new<F1, F2, F3>(notebook_counts: F1, tag_counts: F2, trash_count: F3) -> NoteCollectionCounts where F1: Into<Option<BTreeMap<types::Guid, i32>>>, F2: Into<Option<BTreeMap<types::Guid, i32>>>, F3: Into<Option<i32>> {
    NoteCollectionCounts {
      notebook_counts: notebook_counts.into(),
      tag_counts: tag_counts.into(),
      trash_count: trash_count.into(),
    }
  }
}

impl TSerializable for NoteCollectionCounts {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteCollectionCounts> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<types::Guid, i32>> = None;
    let mut f_2: Option<BTreeMap<types::Guid, i32>> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::Guid, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_20 = i_prot.read_string()?;
            let map_val_21 = i_prot.read_i32()?;
            val.insert(map_key_20, map_val_21);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::Guid, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_22 = i_prot.read_string()?;
            let map_val_23 = i_prot.read_i32()?;
            val.insert(map_key_22, map_val_23);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteCollectionCounts {
      notebook_counts: f_1,
      tag_counts: f_2,
      trash_count: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteCollectionCounts");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.notebook_counts {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookCounts", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tag_counts {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagCounts", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.trash_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("trashCount", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteResultSpec
//

/// This structure is provided to the getNoteWithResultSpec function to specify the subset of
/// fields that should be included in the Note that is returned. This allows clients to request
/// the minimum set of information that they require when retrieving a note, reducing the size
/// of the response and improving the response time.
/// 
/// If one of the fields in this spec is not set, then it will be treated as 'false' by the service,
/// so that the default behavior is to include none of the fields below in the Note.
/// 
/// <dl>
///   <dt>includeContent</dt>
///   <dd>If true, the Note.content field will be populated with the note's ENML contents.</dd>
/// 
///   <dt>includeResourcesData</dt>
///   <dd>If true, any Resource elements will include the binary contents of their 'data' field's
///     body.</dd>
/// 
///   <dt>includeResourcesRecognition</dt>
///   <dd>If true, any Resource elements will include the binary contents of their 'recognition'
///     field's body if recognition data is available.</dd>
/// 
///   <dt>includeResourcesAlternateData</dt>
///   <dd>If true, any Resource elements will include the binary contents of their 'alternateData'
///     field's body, if an alternate form is available.</dd>
/// 
///   <dt>includeSharedNotes</dt>
///   <dd>If true, the Note.sharedNotes field will be populated with the note's shares.</dd>
/// 
///   <dt>includeNoteAppDataValues</dt>
///   <dd>If true, the Note.attributes.applicationData.fullMap field will be populated.</dd>
/// 
///   <dt>includeResourceAppDataValues</dt>
///   <dd>If true, the Note.resource.attributes.applicationData.fullMap field will be populated.</dd>
/// 
///   <dt>includeAccountLimits</dt>
///   <dd>If true, the Note.limits field will be populated with the note owner's account limits.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteResultSpec {
  pub include_content: Option<bool>,
  pub include_resources_data: Option<bool>,
  pub include_resources_recognition: Option<bool>,
  pub include_resources_alternate_data: Option<bool>,
  pub include_shared_notes: Option<bool>,
  pub include_note_app_data_values: Option<bool>,
  pub include_resource_app_data_values: Option<bool>,
  pub include_account_limits: Option<bool>,
}

impl NoteResultSpec {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(include_content: F1, include_resources_data: F2, include_resources_recognition: F3, include_resources_alternate_data: F4, include_shared_notes: F5, include_note_app_data_values: F6, include_resource_app_data_values: F7, include_account_limits: F8) -> NoteResultSpec where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    NoteResultSpec {
      include_content: include_content.into(),
      include_resources_data: include_resources_data.into(),
      include_resources_recognition: include_resources_recognition.into(),
      include_resources_alternate_data: include_resources_alternate_data.into(),
      include_shared_notes: include_shared_notes.into(),
      include_note_app_data_values: include_note_app_data_values.into(),
      include_resource_app_data_values: include_resource_app_data_values.into(),
      include_account_limits: include_account_limits.into(),
    }
  }
}

impl TSerializable for NoteResultSpec {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteResultSpec> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteResultSpec {
      include_content: f_1,
      include_resources_data: f_2,
      include_resources_recognition: f_3,
      include_resources_alternate_data: f_4,
      include_shared_notes: f_5,
      include_note_app_data_values: f_6,
      include_resource_app_data_values: f_7,
      include_account_limits: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteResultSpec");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.include_content {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeContent", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_resources_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeResourcesData", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_resources_recognition {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeResourcesRecognition", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_resources_alternate_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeResourcesAlternateData", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_shared_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeSharedNotes", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_note_app_data_values {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeNoteAppDataValues", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_resource_app_data_values {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeResourceAppDataValues", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_account_limits {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeAccountLimits", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteEmailParameters
//

/// Parameters that must be given to the NoteStore emailNote call. These allow
/// the caller to specify the note to send, the recipient addresses, etc.
/// 
/// <dl>
///  <dt>guid</dt>
///    <dd>
///      If set, this must be the GUID of a note within the user's account that
///      should be retrieved from the service and sent as email.  If not set,
///      the 'note' field must be provided instead.
///    </dd>
/// 
///  <dt>note</dt>
///    <dd>
///      If the 'guid' field is not set, this field must be provided, including
///      the full contents of the note note (and all of its Resources) to send.
///      This can be used for a Note that as not been created in the service,
///      for example by a local client with local notes.
///    </dd>
/// 
///  <dt>toAddresses</dt>
///    <dd>
///      If provided, this should contain a list of the SMTP email addresses
///      that should be included in the "To:" line of the email.
///      Callers must specify at least one "to" or "cc" email address.
///    </dd>
/// 
///  <dt>ccAddresses</dt>
///    <dd>
///      If provided, this should contain a list of the SMTP email addresses
///      that should be included in the "Cc:" line of the email.
///      Callers must specify at least one "to" or "cc" email address.
///    </dd>
/// 
///  <dt>subject</dt>
///    <dd>
///      If provided, this should contain the subject line of the email that
///      will be sent.  If not provided, the title of the note will be used
///      as the subject of the email.
///    </dd>
/// 
///  <dt>message</dt>
///    <dd>
///      If provided, this is additional personal text that should be included
///      into the email as a message from the owner to the recipient(s).
///    </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteEmailParameters {
  pub guid: Option<String>,
  pub note: Option<types::Note>,
  pub to_addresses: Option<Vec<String>>,
  pub cc_addresses: Option<Vec<String>>,
  pub subject: Option<String>,
  pub message: Option<String>,
}

impl NoteEmailParameters {
  pub fn new<F1, F2, F3, F4, F5, F6>(guid: F1, note: F2, to_addresses: F3, cc_addresses: F4, subject: F5, message: F6) -> NoteEmailParameters where F1: Into<Option<String>>, F2: Into<Option<types::Note>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<Vec<String>>>, F5: Into<Option<String>>, F6: Into<Option<String>> {
    NoteEmailParameters {
      guid: guid.into(),
      note: note.into(),
      to_addresses: to_addresses.into(),
      cc_addresses: cc_addresses.into(),
      subject: subject.into(),
      message: message.into(),
    }
  }
}

impl TSerializable for NoteEmailParameters {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteEmailParameters> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Note> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = i_prot.read_string()?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_string()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteEmailParameters {
      guid: f_1,
      note: f_2,
      to_addresses: f_3,
      cc_addresses: f_4,
      subject: f_5,
      message: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteEmailParameters");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.note {
      o_prot.write_field_begin(&TFieldIdentifier::new("note", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.to_addresses {
      o_prot.write_field_begin(&TFieldIdentifier::new("toAddresses", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cc_addresses {
      o_prot.write_field_begin(&TFieldIdentifier::new("ccAddresses", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.subject {
      o_prot.write_field_begin(&TFieldIdentifier::new("subject", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteVersionId
//

/// Identifying information about previous versions of a note that are backed up
/// within Evernote's servers.  Used in the return value of the listNoteVersions
/// call.
/// 
/// <dl>
///  <dt>updateSequenceNum</dt>
///  <dd>
///    The update sequence number for the Note when it last had this content.
///    This serves to uniquely identify each version of the note, since USN
///    values are unique within an account for each update.
///  </dd>
///  <dt>updated</dt>
///  <dd>
///    The 'updated' time that was set on the Note when it had this version
///    of the content.  This is the user-modifiable modification time on the
///    note, so it's not reliable for guaranteeing the order of various
///    versions.  (E.g. if someone modifies the note, then changes this time
///    manually into the past and then updates the note again.)
///  </dd>
///  <dt>saved</dt>
///  <dd>
///    A timestamp that holds the date and time when this version of the note
///    was backed up by Evernote's servers.
///  </dd>
///  <dt>title</dt>
///  <dd>
///    The title of the note when this particular version was saved.  (The
///    current title of the note may differ from this value.)
///  </dd>
///  <dt>lastEditorId</dt>
///  <dd>
///    The ID of the user who made the change to this version of the note. This will be
///    unset if the note version was edited by the owner of the account.
///  </dd>
/// </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteVersionId {
  pub update_sequence_num: i32,
  pub updated: types::Timestamp,
  pub saved: types::Timestamp,
  pub title: String,
  pub last_editor_id: Option<types::UserID>,
}

impl NoteVersionId {
  pub fn new<F5>(update_sequence_num: i32, updated: types::Timestamp, saved: types::Timestamp, title: String, last_editor_id: F5) -> NoteVersionId where F5: Into<Option<types::UserID>> {
    NoteVersionId {
      update_sequence_num,
      updated,
      saved,
      title,
      last_editor_id: last_editor_id.into(),
    }
  }
}

impl TSerializable for NoteVersionId {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteVersionId> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<types::Timestamp> = None;
    let mut f_3: Option<types::Timestamp> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<types::UserID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteVersionId.update_sequence_num", &f_1)?;
    verify_required_field_exists("NoteVersionId.updated", &f_2)?;
    verify_required_field_exists("NoteVersionId.saved", &f_3)?;
    verify_required_field_exists("NoteVersionId.title", &f_4)?;
    let ret = NoteVersionId {
      update_sequence_num: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updated: f_2.expect("auto-generated code should have checked for presence of required fields"),
      saved: f_3.expect("auto-generated code should have checked for presence of required fields"),
      title: f_4.expect("auto-generated code should have checked for presence of required fields"),
      last_editor_id: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteVersionId");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 1))?;
    o_prot.write_i32(self.update_sequence_num)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updated", TType::I64, 2))?;
    o_prot.write_i64(self.updated)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("saved", TType::I64, 3))?;
    o_prot.write_i64(self.saved)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 4))?;
    o_prot.write_string(&self.title)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.last_editor_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastEditorId", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RelatedQuery
//

/// A description of the thing for which we are searching for related
/// entities.
/// 
/// You must specify either <em>noteGuid</em> or <em>plainText</em>, but
/// not both. <em>filter</em> and <em>referenceUri</em> are optional.
/// 
/// <dl>
/// <dt>noteGuid</dt>
/// <dd>The GUID of an existing note in your account for which related
///     entities will be found.</dd>
/// 
/// <dt>plainText</dt>
/// <dd>A string of plain text for which to find related entities.
///     You should provide a text block with a number of characters between
///     EDAM_RELATED_PLAINTEXT_LEN_MIN and EDAM_RELATED_PLAINTEXT_LEN_MAX.
///     </dd>
/// 
/// <dt>filter</dt>
/// <dd>The list of criteria that will constrain the notes being considered
///     related.
///     Please note that some of the parameters may be ignored, such as
///     <em>order</em> and <em>ascending</em>.
/// </dd>
/// 
/// <dt>referenceUri</dt>
/// <dd>A URI string specifying a reference entity, around which "relatedness"
///     should be based. This can be an URL pointing to a web page, for example.
/// </dd>
/// 
/// <dt>context</dt>
/// <dd>Specifies the context to consider when determining related results.
///     Clients must leave this value unset unless they wish to explicitly specify a known
///     non-default context.
/// </dd>
/// 
/// <dt>cacheKey</dt>
/// <dd>If set and non-empty, this is an indicator for the server whether it is actually
///     necessary to perform a new findRelated call at all. Cache Keys are opaque strings
///     which are returned by the server as part of "RelatedResult" in response
///     to a "NoteStore.findRelated" query. Cache Keys are inherently query specific.
/// 
///     If set to an empty string, this indicates that the server should generate a cache
///     key in the response as part of "RelatedResult".
/// 
///     If not set, the server will not attempt to generate a cache key at all.
/// </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RelatedQuery {
  pub note_guid: Option<String>,
  pub plain_text: Option<String>,
  pub filter: Option<NoteFilter>,
  pub reference_uri: Option<String>,
  pub context: Option<String>,
  pub cache_key: Option<String>,
}

impl RelatedQuery {
  pub fn new<F1, F2, F3, F4, F5, F6>(note_guid: F1, plain_text: F2, filter: F3, reference_uri: F4, context: F5, cache_key: F6) -> RelatedQuery where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<NoteFilter>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>> {
    RelatedQuery {
      note_guid: note_guid.into(),
      plain_text: plain_text.into(),
      filter: filter.into(),
      reference_uri: reference_uri.into(),
      context: context.into(),
      cache_key: cache_key.into(),
    }
  }
}

impl TSerializable for RelatedQuery {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RelatedQuery> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<NoteFilter> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = NoteFilter::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RelatedQuery {
      note_guid: f_1,
      plain_text: f_2,
      filter: f_3,
      reference_uri: f_4,
      context: f_5,
      cache_key: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RelatedQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.note_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.plain_text {
      o_prot.write_field_begin(&TFieldIdentifier::new("plainText", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reference_uri {
      o_prot.write_field_begin(&TFieldIdentifier::new("referenceUri", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.context {
      o_prot.write_field_begin(&TFieldIdentifier::new("context", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cache_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("cacheKey", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RelatedResult
//

/// The result of calling findRelated().  The contents of the notes,
/// notebooks, and tags fields will be in decreasing order of expected
/// relevance.  It is possible that fewer results than requested will be
/// returned even if there are enough distinct entities in the account
/// in cases where the relevance is estimated to be low.
/// 
/// <dl>
/// <dt>notes</dt>
/// <dd>If notes have been requested to be included, this will be the
///     list of notes.</dd>
/// 
/// <dt>notebooks</dt>
/// <dd>If notebooks have been requested to be included, this will be the
///     list of notebooks.</dd>
/// 
/// <dt>tags</dt>
/// <dd>If tags have been requested to be included, this will be the list
///     of tags.</dd>
/// 
/// <dt>containingNotebooks</dt>
/// <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
///     in the RelatedResultSpec, return the list of notebooks to
///     to which the returned related notes belong. The notebooks in this
///     list will occur once per notebook GUID and are represented as
///     NotebookDescriptor objects.</dd>
/// 
/// <dt>experts</dt>
/// <dd>If experts have been requested to be included, this will return
///  a list of users within your business who have knowledge about the specified query.
/// </dd>
/// 
/// <dt>relatedContent</dt>
/// <dd>If related content has been requested to be included, this will be the list of
///  related content snippets.
/// </dd>
/// 
/// <dt>cacheKey</dt>
/// <dd>If set and non-empty, this cache key may be used in subsequent
///     "NoteStore.findRelated" calls (via "RelatedQuery") to re-use previous
///     responses that were cached on the client-side, instead of actually performing
///     another search.
/// 
///     If set to an empty string, this indicates that the server could not determine
///     a specific key for this response, but the client should nevertheless remove
///     any previously cached result for this request.
/// 
///     If unset/null, it is up to the client whether to re-use cached results or to
///     use the server's response.
/// 
///     If set to the exact non-empty cache key that was specified in
///     "RelatedQuery.cacheKey", this indicates that the server decided that cached results
///     could be reused.
/// 
///     Depending on the cache key specified in the query, the "RelatedResult" may only be
///     partially filled. For each set field, the client should replace the corresponding
///     part in the previously cached result with the new partial result.
/// 
///     For example, for a specific query that has both "RelatedResultSpec.maxNotes" and
///     "RelatedResultSpec.maxRelatedContent" set to positive values, the server may decide
///     that the previously requested and cached <em>Related Content</em> are unchanged,
///     but new results for <em>Related Notes</em> are available. The
///     response will have a new cache key and have "RelatedResult.notes" set, but have
///     "RelatedResult.relatedContent" unset (not just empty, but really unset).
/// 
///     In this situation, the client should replace any cached notes with the newly
///     returned "RelatedResult.notes", but it can re-use the previously cached entries for
///     "RelatedResult.relatedContent". List fields that are set, but empty indicate that
///     no results could be found; the cache should be updated correspondingly.
/// </dd>
/// 
/// <dt>cacheExpires</dt>
/// <dd> If set, clients should reuse this response for any situations where the same input
///      parameters are applicable for up to this many seconds after receiving this result.
/// 
///      After this time has passed, the client may request a new result from the service,
///      but it should supply the stored cacheKey to the service when checking for an
///      update.
/// </dd>
/// 
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RelatedResult {
  pub notes: Option<Vec<types::Note>>,
  pub notebooks: Option<Vec<types::Notebook>>,
  pub tags: Option<Vec<types::Tag>>,
  pub containing_notebooks: Option<Vec<types::NotebookDescriptor>>,
  pub debug_info: Option<String>,
  pub experts: Option<Vec<types::UserProfile>>,
  pub related_content: Option<Vec<types::RelatedContent>>,
  pub cache_key: Option<String>,
  pub cache_expires: Option<i32>,
}

impl RelatedResult {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(notes: F1, notebooks: F2, tags: F3, containing_notebooks: F4, debug_info: F5, experts: F6, related_content: F7, cache_key: F8, cache_expires: F9) -> RelatedResult where F1: Into<Option<Vec<types::Note>>>, F2: Into<Option<Vec<types::Notebook>>>, F3: Into<Option<Vec<types::Tag>>>, F4: Into<Option<Vec<types::NotebookDescriptor>>>, F5: Into<Option<String>>, F6: Into<Option<Vec<types::UserProfile>>>, F7: Into<Option<Vec<types::RelatedContent>>>, F8: Into<Option<String>>, F9: Into<Option<i32>> {
    RelatedResult {
      notes: notes.into(),
      notebooks: notebooks.into(),
      tags: tags.into(),
      containing_notebooks: containing_notebooks.into(),
      debug_info: debug_info.into(),
      experts: experts.into(),
      related_content: related_content.into(),
      cache_key: cache_key.into(),
      cache_expires: cache_expires.into(),
    }
  }
}

impl TSerializable for RelatedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RelatedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<types::Note>> = None;
    let mut f_2: Option<Vec<types::Notebook>> = None;
    let mut f_3: Option<Vec<types::Tag>> = None;
    let mut f_4: Option<Vec<types::NotebookDescriptor>> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<types::UserProfile>> = None;
    let mut f_7: Option<Vec<types::RelatedContent>> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Note> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = types::Note::read_from_in_protocol(i_prot)?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Notebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = types::Notebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Tag> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = types::Tag::read_from_in_protocol(i_prot)?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::NotebookDescriptor> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = types::NotebookDescriptor::read_from_in_protocol(i_prot)?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::UserProfile> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_30 = types::UserProfile::read_from_in_protocol(i_prot)?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::RelatedContent> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_31 = types::RelatedContent::read_from_in_protocol(i_prot)?;
            val.push(list_elem_31);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RelatedResult {
      notes: f_1,
      notebooks: f_2,
      tags: f_3,
      containing_notebooks: f_4,
      debug_info: f_5,
      experts: f_6,
      related_content: f_7,
      cache_key: f_8,
      cache_expires: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RelatedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("notes", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebooks", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.containing_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("containingNotebooks", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.debug_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("debugInfo", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.experts {
      o_prot.write_field_begin(&TFieldIdentifier::new("experts", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.related_content {
      o_prot.write_field_begin(&TFieldIdentifier::new("relatedContent", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cache_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("cacheKey", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cache_expires {
      o_prot.write_field_begin(&TFieldIdentifier::new("cacheExpires", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RelatedResultSpec
//

/// A description of the thing for which the service will find related
/// entities, via findRelated(), together with a description of what
/// type of entities and how many you are seeking in the
/// RelatedResult.
/// 
/// <dl>
/// <dt>maxNotes</dt>
/// <dd>Return notes that are related to the query, but no more than
///     this many.  Any value greater than EDAM_RELATED_MAX_NOTES
///     will be silently capped.  If you do not set this field, then
///     no notes will be returned.</dd>
/// 
/// <dt>maxNotebooks</dt>
/// <dd>Return notebooks that are related to the query, but no more than
///     this many.  Any value greater than EDAM_RELATED_MAX_NOTEBOOKS
///     will be silently capped.  If you do not set this field, then
///     no notebooks will be returned.</dd>
/// 
/// <dt>maxTags</dt>
/// <dd>Return tags that are related to the query, but no more than
///     this many.  Any value greater than EDAM_RELATED_MAX_TAGS
///     will be silently capped.  If you do not set this field, then
///     no tags will be returned.</dd>
/// </dl>
/// 
/// <dt>writableNotebooksOnly</dt>
/// <dd>Require that all returned related notebooks are writable.
///     The user will be able to create notes in all returned notebooks.
///     However, individual notes returned may still belong to notebooks
///     in which the user lacks the ability to create notes.</dd>
/// </dl>
/// 
/// <dt>includeContainingNotebooks</dt>
/// <dd>If set to <code>true</code>, return the containingNotebooks field
///     in the RelatedResult, which will contain the list of notebooks to
///     to which the returned related notes belong.</dd>
/// </dl>
/// 
/// <dt>includeDebugInfo</dt>
/// <dd>If set to <code>true</code>, indicate that debug information should
///     be returned in the 'debugInfo' field of RelatedResult. Note that the call may
///     be slower if this flag is set.</dd>
/// 
/// <dt>maxExperts</dt>
/// <dd>This can only be used when making a findRelated call against a business.
///  Find users within your business who have knowledge about the specified query.
///  No more than this many users will be returned. Any value greater than
///  EDAM_RELATED_MAX_EXPERTS will be silently capped.
/// </dd>
/// 
/// <dt>maxRelatedContent</dt>
/// <dd>Return snippets of related content that is related to the query, but no more than
///  this many. Any value greater than EDAM_RELATED_MAX_RELATED_CONTENT will be silently
///  capped. If you do not set this field, then no related content will be returned.</dd>
/// </dl>
/// 
/// <dt>relatedContentTypes</dt>
/// <dd>Specifies the types of Related Content that should be returned.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RelatedResultSpec {
  pub max_notes: Option<i32>,
  pub max_notebooks: Option<i32>,
  pub max_tags: Option<i32>,
  pub writable_notebooks_only: Option<bool>,
  pub include_containing_notebooks: Option<bool>,
  pub include_debug_info: Option<bool>,
  pub max_experts: Option<i32>,
  pub max_related_content: Option<i32>,
  pub related_content_types: Option<BTreeSet<types::RelatedContentType>>,
}

impl RelatedResultSpec {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(max_notes: F1, max_notebooks: F2, max_tags: F3, writable_notebooks_only: F4, include_containing_notebooks: F5, include_debug_info: F6, max_experts: F7, max_related_content: F8, related_content_types: F9) -> RelatedResultSpec where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<BTreeSet<types::RelatedContentType>>> {
    RelatedResultSpec {
      max_notes: max_notes.into(),
      max_notebooks: max_notebooks.into(),
      max_tags: max_tags.into(),
      writable_notebooks_only: writable_notebooks_only.into(),
      include_containing_notebooks: include_containing_notebooks.into(),
      include_debug_info: include_debug_info.into(),
      max_experts: max_experts.into(),
      max_related_content: max_related_content.into(),
      related_content_types: related_content_types.into(),
    }
  }
}

impl TSerializable for RelatedResultSpec {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RelatedResultSpec> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<BTreeSet<types::RelatedContentType>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<types::RelatedContentType> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_32 = types::RelatedContentType::read_from_in_protocol(i_prot)?;
            val.insert(set_elem_32);
          }
          i_prot.read_set_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RelatedResultSpec {
      max_notes: f_1,
      max_notebooks: f_2,
      max_tags: f_3,
      writable_notebooks_only: f_4,
      include_containing_notebooks: f_5,
      include_debug_info: f_6,
      max_experts: f_7,
      max_related_content: f_8,
      related_content_types: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RelatedResultSpec");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.max_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxNotes", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxNotebooks", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxTags", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.writable_notebooks_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("writableNotebooksOnly", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_containing_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeContainingNotebooks", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_debug_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeDebugInfo", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_experts {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxExperts", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_related_content {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxRelatedContent", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.related_content_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("relatedContentTypes", TType::Set, 9))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpdateNoteIfUsnMatchesResult
//

/// The result of a call to updateNoteIfUsnMatches, which optionally updates a note
/// based on the current value of the note's update sequence number on the service.
/// 
/// <dl>
/// <dt>note</dt>
/// <dd>Either the current state of the note if <tt>updated</tt> is false or the
/// result of updating the note as would be done via the <tt>updateNote</tt> method.
/// If the note was not updated, you will receive a Note that does not include note
/// content, resources data, resources recognition data, or resources alternate data.
/// You can check for updates to these large objects by checking the Data.bodyHash
/// values and downloading accordingly.</dd>
/// 
/// <dt>updated</dt>
/// <dd>Whether or not the note was updated by the operation.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpdateNoteIfUsnMatchesResult {
  pub note: Option<types::Note>,
  pub updated: Option<bool>,
}

impl UpdateNoteIfUsnMatchesResult {
  pub fn new<F1, F2>(note: F1, updated: F2) -> UpdateNoteIfUsnMatchesResult where F1: Into<Option<types::Note>>, F2: Into<Option<bool>> {
    UpdateNoteIfUsnMatchesResult {
      note: note.into(),
      updated: updated.into(),
    }
  }
}

impl TSerializable for UpdateNoteIfUsnMatchesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpdateNoteIfUsnMatchesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::Note> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpdateNoteIfUsnMatchesResult {
      note: f_1,
      updated: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateNoteIfUsnMatchesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.note {
      o_prot.write_field_begin(&TFieldIdentifier::new("note", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("updated", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShareRelationshipRestrictions
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShareRelationshipRestrictions {
  pub no_set_read_only: Option<bool>,
  pub no_set_read_plus_activity: Option<bool>,
  pub no_set_modify: Option<bool>,
  pub no_set_full_access: Option<bool>,
}

impl ShareRelationshipRestrictions {
  pub fn new<F1, F2, F3, F4>(no_set_read_only: F1, no_set_read_plus_activity: F2, no_set_modify: F3, no_set_full_access: F4) -> ShareRelationshipRestrictions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    ShareRelationshipRestrictions {
      no_set_read_only: no_set_read_only.into(),
      no_set_read_plus_activity: no_set_read_plus_activity.into(),
      no_set_modify: no_set_modify.into(),
      no_set_full_access: no_set_full_access.into(),
    }
  }
}

impl TSerializable for ShareRelationshipRestrictions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShareRelationshipRestrictions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShareRelationshipRestrictions {
      no_set_read_only: f_1,
      no_set_read_plus_activity: f_2,
      no_set_modify: f_3,
      no_set_full_access: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShareRelationshipRestrictions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.no_set_read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetReadOnly", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_read_plus_activity {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetReadPlusActivity", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_modify {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetModify", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_full_access {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetFullAccess", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// InvitationShareRelationship
//

/// Describes an invitation to a person to use their Evernote
/// credentials to become a member of a notebook.
/// 
/// <dl>
/// <dt>displayName</dt>
/// <dd>The string that clients should show to users to represent this
/// invitation.</dd>
/// 
/// <dt>recipientUserIdentity</dt>
/// <dd>Identifies the recipient of the invitation. The user identity
/// type can be either EMAIL, EVERNOTE or IDENTITYID. If the
/// invitation was created using the classic notebook sharing APIs it will be EMAIL. If it
/// was created using the new identity-based notebook sharing APIs it will either be
/// EVERNOTE or IDENTITYID, depending on whether we can map the identity to an Evernote
/// user at the time of creation.
/// </dd>
/// 
/// <dt>privilege</dt>
/// <dd>The privilege level at which the member will be joined, if it
/// turns out that the member is not already joined at a higher level.
/// Note that the <tt>identity</tt> field may not uniquely identify an
/// Evernote User ID, and so we won't know until the invitation is
/// redeemed whether or not the recipient already has privilege.</dd>
/// 
/// <dt>sharerUserId</dt>
/// <dd>The user id of the user who most recently shared this notebook
/// to this identity. This field is used by the service to convey information
/// to the user, so clients should treat it as read-only.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InvitationShareRelationship {
  pub display_name: Option<String>,
  pub recipient_user_identity: Option<types::UserIdentity>,
  pub privilege: Option<ShareRelationshipPrivilegeLevel>,
  pub sharer_user_id: Option<types::UserID>,
}

impl InvitationShareRelationship {
  pub fn new<F1, F2, F3, F5>(display_name: F1, recipient_user_identity: F2, privilege: F3, sharer_user_id: F5) -> InvitationShareRelationship where F1: Into<Option<String>>, F2: Into<Option<types::UserIdentity>>, F3: Into<Option<ShareRelationshipPrivilegeLevel>>, F5: Into<Option<types::UserID>> {
    InvitationShareRelationship {
      display_name: display_name.into(),
      recipient_user_identity: recipient_user_identity.into(),
      privilege: privilege.into(),
      sharer_user_id: sharer_user_id.into(),
    }
  }
}

impl TSerializable for InvitationShareRelationship {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InvitationShareRelationship> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::UserIdentity> = None;
    let mut f_3: Option<ShareRelationshipPrivilegeLevel> = None;
    let mut f_5: Option<types::UserID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::UserIdentity::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = ShareRelationshipPrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InvitationShareRelationship {
      display_name: f_1,
      recipient_user_identity: f_2,
      privilege: f_3,
      sharer_user_id: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InvitationShareRelationship");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_user_identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientUserIdentity", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sharer_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharerUserId", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MemberShareRelationship
//

/// Describes the association between a Notebook and an Evernote User who is
/// a member of that notebook.
/// 
/// <dl>
/// <dt>displayName</dt>
/// <dd>The string that clients should show to users to represent this
/// member.</dd>
/// 
/// <dt>recipientUserId</dt>
/// <dd>The Evernote User ID of the recipient of this notebook share.
/// </dd>
/// 
/// <dt>bestPrivilege</dt>
/// <dd>The privilege at which the member can access the notebook,
/// which is the best privilege granted either individually or to a
/// group to which a member belongs, such as a business.  This field is
/// used by the service to convey information to the user, so clients
/// should treat it as read-only.</dd>
/// 
/// <dt>individualPrivilege</dt>
/// <dd>The individually granted privilege for the member, which does
/// not take GROUP privileges into account.  This value may be unset if
/// only a group-assigned privilege has been granted to the member.
/// This value can be managed by others with sufficient rights using
/// the manageNotebookShares method.  The valid values that clients
/// should present to users for selection are given via the the
/// 'restrictions' field.</dd>
/// 
/// <dt>restrictions</dt>
/// <dd>The restrictions on which privileges may be individually
/// assigned to the recipient of this share relationship.</dd>
/// 
/// <dt>sharerUserId</dt>
/// <dd>The user id of the user who most recently shared the notebook
/// to this user. This field is currently unset for a MemberShareRelationship
/// created by joining a notebook that has been published to the business
/// (MemberShareRelationships where the individual privilege is unset).
/// This field is used by the service to convey information to the user, so
/// clients should treat it as read-only.
/// </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MemberShareRelationship {
  pub display_name: Option<String>,
  pub recipient_user_id: Option<types::UserID>,
  pub best_privilege: Option<ShareRelationshipPrivilegeLevel>,
  pub individual_privilege: Option<ShareRelationshipPrivilegeLevel>,
  pub restrictions: Option<ShareRelationshipRestrictions>,
  pub sharer_user_id: Option<types::UserID>,
}

impl MemberShareRelationship {
  pub fn new<F1, F2, F3, F4, F5, F6>(display_name: F1, recipient_user_id: F2, best_privilege: F3, individual_privilege: F4, restrictions: F5, sharer_user_id: F6) -> MemberShareRelationship where F1: Into<Option<String>>, F2: Into<Option<types::UserID>>, F3: Into<Option<ShareRelationshipPrivilegeLevel>>, F4: Into<Option<ShareRelationshipPrivilegeLevel>>, F5: Into<Option<ShareRelationshipRestrictions>>, F6: Into<Option<types::UserID>> {
    MemberShareRelationship {
      display_name: display_name.into(),
      recipient_user_id: recipient_user_id.into(),
      best_privilege: best_privilege.into(),
      individual_privilege: individual_privilege.into(),
      restrictions: restrictions.into(),
      sharer_user_id: sharer_user_id.into(),
    }
  }
}

impl TSerializable for MemberShareRelationship {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MemberShareRelationship> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::UserID> = None;
    let mut f_3: Option<ShareRelationshipPrivilegeLevel> = None;
    let mut f_4: Option<ShareRelationshipPrivilegeLevel> = None;
    let mut f_5: Option<ShareRelationshipRestrictions> = None;
    let mut f_6: Option<types::UserID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ShareRelationshipPrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = ShareRelationshipPrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = ShareRelationshipRestrictions::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MemberShareRelationship {
      display_name: f_1,
      recipient_user_id: f_2,
      best_privilege: f_3,
      individual_privilege: f_4,
      restrictions: f_5,
      sharer_user_id: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MemberShareRelationship");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recipient_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientUserId", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.best_privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("bestPrivilege", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.individual_privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("individualPrivilege", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("restrictions", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sharer_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharerUserId", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShareRelationships
//

/// Captures a collection of share relationships for a notebook, for
/// example, as returned by the getNotebookShares method.  The share
/// relationships fall into two broad categories: members, and
/// invitations that can be used to become members.
/// 
/// <dl>
/// <dt>invitations</dt>
/// <dd>A list of open invitations that can be redeemed into
/// memberships to the notebook.</dd>
/// 
/// <dt>memberships</dt>
/// <dd>A list of memberships of the notebook.  A member is identified
/// by their Evernote UserID and has rights to access the
/// notebook.</dd>
/// 
/// <dt>invitationRestrictions</dt>
/// <dd>The restrictions on what privileges may be granted to invitees
/// to this notebook. These restrictions may be specific to the calling
/// user or to the notebook itself. They represent the
/// union of all possible invite cases, so it is possible that once the
/// recipient of the invitation has been identified by the service, such
/// as by a business auto-join, the actual assigned privilege may change.
/// </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShareRelationships {
  pub invitations: Option<Vec<InvitationShareRelationship>>,
  pub memberships: Option<Vec<MemberShareRelationship>>,
  pub invitation_restrictions: Option<ShareRelationshipRestrictions>,
}

impl ShareRelationships {
  pub fn new<F1, F2, F3>(invitations: F1, memberships: F2, invitation_restrictions: F3) -> ShareRelationships where F1: Into<Option<Vec<InvitationShareRelationship>>>, F2: Into<Option<Vec<MemberShareRelationship>>>, F3: Into<Option<ShareRelationshipRestrictions>> {
    ShareRelationships {
      invitations: invitations.into(),
      memberships: memberships.into(),
      invitation_restrictions: invitation_restrictions.into(),
    }
  }
}

impl TSerializable for ShareRelationships {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShareRelationships> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<InvitationShareRelationship>> = None;
    let mut f_2: Option<Vec<MemberShareRelationship>> = None;
    let mut f_3: Option<ShareRelationshipRestrictions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<InvitationShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_33 = InvitationShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<MemberShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_34 = MemberShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_34);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ShareRelationshipRestrictions::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShareRelationships {
      invitations: f_1,
      memberships: f_2,
      invitation_restrictions: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShareRelationships");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.invitations {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitations", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memberships {
      o_prot.write_field_begin(&TFieldIdentifier::new("memberships", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.invitation_restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitationRestrictions", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ManageNotebookSharesParameters
//

/// A structure that captures parameters used by clients to manage the
/// shares for a given notebook via the manageNotebookShares method.
/// 
/// <dl>
/// <dt>notebookGuid</dt>
/// <dd>The GUID of the notebook whose shares are being managed.</dd>
/// 
/// <dt>inviteMessage</dt>
/// <dd>If the service sends a message to invitees, this parameter will
/// be used to form the actual message that is sent.</dd>
/// 
/// <dt>membershipsToUpdate</dt>
/// <dd>The list of existing memberships to update.  This field is not
/// intended to be the full set of memberships for the notebook and
/// should only include those already-existing memberships that you
/// actually want to change.  If you want to remove shares, see the
/// unshares fields.  If you want to create a membership,
/// i.e. auto-join a business user, you can do this via the
/// invitationsToCreateOrUpdate field using an Evernote UserID of a
/// fellow business member (the created invitation is automatically
/// joined by the service, so the client is creating an
/// invitation, not a membership).</dd>
/// 
/// <dt>invitationsToCreateOrUpdate</dt>
/// <dd>The list of invitations to update, as matched by the identity
/// field of the InvitationShareRelationship instances, or to create if
/// an existing invitation does not exist.  This field is not intended
/// to be the full set of invitations on the notebook and should only
/// include those invitations that you wish to create or update.  Note
/// that your invitation could convert into a membership via a
/// service-supported auto-join operation.  This happens, for example,
/// when you use an invitation with an Evernote UserID type for a
/// recipient who is a member of the business to which the notebook
/// belongs.  Note that to discover the user IDs for business members,
/// the sharer must also be part of the business.</dd>
/// 
/// <dt>unshares</dt>
/// <dd>The list of share relationships to expunge from the service.
/// If the user identity is for an Evernote UserID, then matching invitations or
/// memberships will be removed. If it's an e-mail, then e-mail based shared notebook
/// invitations will be removed. If it's for an Identity ID, then any invitations that
/// match the identity (by identity ID or user ID or e-mail for legacy invitations) will be
/// removed.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ManageNotebookSharesParameters {
  pub notebook_guid: Option<String>,
  pub invite_message: Option<String>,
  pub memberships_to_update: Option<Vec<MemberShareRelationship>>,
  pub invitations_to_create_or_update: Option<Vec<InvitationShareRelationship>>,
  pub unshares: Option<Vec<types::UserIdentity>>,
}

impl ManageNotebookSharesParameters {
  pub fn new<F1, F2, F3, F4, F5>(notebook_guid: F1, invite_message: F2, memberships_to_update: F3, invitations_to_create_or_update: F4, unshares: F5) -> ManageNotebookSharesParameters where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<Vec<MemberShareRelationship>>>, F4: Into<Option<Vec<InvitationShareRelationship>>>, F5: Into<Option<Vec<types::UserIdentity>>> {
    ManageNotebookSharesParameters {
      notebook_guid: notebook_guid.into(),
      invite_message: invite_message.into(),
      memberships_to_update: memberships_to_update.into(),
      invitations_to_create_or_update: invitations_to_create_or_update.into(),
      unshares: unshares.into(),
    }
  }
}

impl TSerializable for ManageNotebookSharesParameters {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ManageNotebookSharesParameters> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<MemberShareRelationship>> = None;
    let mut f_4: Option<Vec<InvitationShareRelationship>> = None;
    let mut f_5: Option<Vec<types::UserIdentity>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<MemberShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_35 = MemberShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_35);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<InvitationShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_36 = InvitationShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::UserIdentity> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_37 = types::UserIdentity::read_from_in_protocol(i_prot)?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ManageNotebookSharesParameters {
      notebook_guid: f_1,
      invite_message: f_2,
      memberships_to_update: f_3,
      invitations_to_create_or_update: f_4,
      unshares: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ManageNotebookSharesParameters");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.notebook_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.invite_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("inviteMessage", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memberships_to_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("membershipsToUpdate", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.invitations_to_create_or_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitationsToCreateOrUpdate", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.unshares {
      o_prot.write_field_begin(&TFieldIdentifier::new("unshares", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ManageNotebookSharesError
//

/// A structure to capture certain errors that occurred during a call
/// to manageNotebookShares.  That method can be run best-effort,
/// meaning that some change requests can be applied while others fail.
/// Note that some errors such as system errors will still fail the
/// entire transaction regardless of running best effort.  When some
/// change requests do not succeed, the error conditions are captured
/// in instances of this class, captured by the identity of the share
/// relationship and one of the exception fields.
/// 
/// <dl>
/// <dt>userIdentity</dt>
/// <dd>The identity of the share relationship whose update encountered
/// an error.</dd>
/// 
/// <dt>userException</dt>
/// <dd>If the error is represented as an EDAMUserException that would
/// have otherwise been thrown without best-effort execution.  Only one
/// exception field will be set.</dd>
/// 
/// <dt>notFoundException</dt>
/// <dd>If the error is represented as an EDAMNotFoundException that would
/// have otherwise been thrown without best-effort execution.  Only one
/// exception field will be set.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ManageNotebookSharesError {
  pub user_identity: Option<types::UserIdentity>,
  pub user_exception: Option<errors::EDAMUserException>,
  pub not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl ManageNotebookSharesError {
  pub fn new<F1, F2, F3>(user_identity: F1, user_exception: F2, not_found_exception: F3) -> ManageNotebookSharesError where F1: Into<Option<types::UserIdentity>>, F2: Into<Option<errors::EDAMUserException>>, F3: Into<Option<errors::EDAMNotFoundException>> {
    ManageNotebookSharesError {
      user_identity: user_identity.into(),
      user_exception: user_exception.into(),
      not_found_exception: not_found_exception.into(),
    }
  }
}

impl TSerializable for ManageNotebookSharesError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ManageNotebookSharesError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::UserIdentity> = None;
    let mut f_2: Option<errors::EDAMUserException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::UserIdentity::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ManageNotebookSharesError {
      user_identity: f_1,
      user_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ManageNotebookSharesError");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("userIdentity", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ManageNotebookSharesResult
//

/// The return value of a call to the manageNotebookShares method.
/// 
/// <dl>
/// <dt>errors</dt>
/// <dd>If the method completed without throwing exceptions, some errors
/// might still have occurred, and in that case, this field will contain
/// the list of those errors the occurred.
/// </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ManageNotebookSharesResult {
  pub errors: Option<Vec<ManageNotebookSharesError>>,
}

impl ManageNotebookSharesResult {
  pub fn new<F1>(errors: F1) -> ManageNotebookSharesResult where F1: Into<Option<Vec<ManageNotebookSharesError>>> {
    ManageNotebookSharesResult {
      errors: errors.into(),
    }
  }
}

impl TSerializable for ManageNotebookSharesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ManageNotebookSharesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ManageNotebookSharesError>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ManageNotebookSharesError> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = ManageNotebookSharesError::read_from_in_protocol(i_prot)?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ManageNotebookSharesResult {
      errors: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ManageNotebookSharesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.errors {
      o_prot.write_field_begin(&TFieldIdentifier::new("errors", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SharedNoteTemplate
//

/// A structure used to share a note with one or more recipients at a given privilege.
/// 
/// <dl>
///   <dt>noteGuid</dt>
///   <dd>The GUID of the note.</dd>
/// 
///   <dt>recipientThreadId</dt>
///   <dd>The recipients of the note share specified as a messaging thread ID. If you
///       have an existing messaging thread to share the note with, specify its ID
///       here instead of recipientContacts in order to properly support defunct
///       identities. The sharer must be a participant of the thread. Either this
///       field or recipientContacts must be set.</dd>
/// 
///   <dt>recipientContacts</dt>
///   <dd>The recipients of the note share specified as a list of contacts. This should
///       only be set if the sharing takes place before the thread is created. Use
///       recipientThreadId instead when sharing with an existing thread. Either this
///       field or recipientThreadId must be set.</dd>
/// 
///   <dt>privilege</dt>
///   <dd>The privilege level to be granted.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SharedNoteTemplate {
  pub note_guid: Option<types::Guid>,
  pub recipient_contacts: Option<Vec<types::Contact>>,
  pub privilege: Option<types::SharedNotePrivilegeLevel>,
  pub recipient_thread_id: Option<types::MessageThreadID>,
}

impl SharedNoteTemplate {
  pub fn new<F1, F2, F3, F4>(note_guid: F1, recipient_contacts: F2, privilege: F3, recipient_thread_id: F4) -> SharedNoteTemplate where F1: Into<Option<types::Guid>>, F2: Into<Option<Vec<types::Contact>>>, F3: Into<Option<types::SharedNotePrivilegeLevel>>, F4: Into<Option<types::MessageThreadID>> {
    SharedNoteTemplate {
      note_guid: note_guid.into(),
      recipient_contacts: recipient_contacts.into(),
      privilege: privilege.into(),
      recipient_thread_id: recipient_thread_id.into(),
    }
  }
}

impl TSerializable for SharedNoteTemplate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SharedNoteTemplate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::Guid> = None;
    let mut f_2: Option<Vec<types::Contact>> = None;
    let mut f_3: Option<types::SharedNotePrivilegeLevel> = None;
    let mut f_4: Option<types::MessageThreadID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = types::Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::SharedNotePrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SharedNoteTemplate {
      note_guid: f_1,
      recipient_contacts: f_2,
      privilege: f_3,
      recipient_thread_id: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SharedNoteTemplate");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.note_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_contacts {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientContacts", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recipient_thread_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientThreadId", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotebookShareTemplate
//

/// A structure used to share a notebook with one or more recipients at a given privilege.
/// 
/// <dl>
///   <dt>notebookGuid</dt>
///   <dd>The GUID of the notebook.</dd>
/// 
///   <dt>recipientThreadId</dt>
///   <dd>The recipients of the notebook share specified as a messaging thread ID. If you
///       have an existing messaging thread to share the note with, specify its ID
///       here instead of recipientContacts in order to properly support defunct
///       identities. The sharer must be a participant of the thread. Either this field
///       or recipientContacts must be set.</dd>
/// 
///   <dt>recipientContacts</dt>
///   <dd>The recipients of the notebook share specified as a list of contacts. This should
///       only be set if the sharing takes place before the thread is created. Use
///       recipientThreadId instead when sharing with an existing thread. Either this
///       field or recipientThreadId must be set.</dd>
/// 
///   <dt>privilege</dt>
///   <dd>The privilege level to be granted.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotebookShareTemplate {
  pub notebook_guid: Option<types::Guid>,
  pub recipient_contacts: Option<Vec<types::Contact>>,
  pub privilege: Option<types::SharedNotebookPrivilegeLevel>,
  pub recipient_thread_id: Option<types::MessageThreadID>,
}

impl NotebookShareTemplate {
  pub fn new<F1, F2, F3, F4>(notebook_guid: F1, recipient_contacts: F2, privilege: F3, recipient_thread_id: F4) -> NotebookShareTemplate where F1: Into<Option<types::Guid>>, F2: Into<Option<Vec<types::Contact>>>, F3: Into<Option<types::SharedNotebookPrivilegeLevel>>, F4: Into<Option<types::MessageThreadID>> {
    NotebookShareTemplate {
      notebook_guid: notebook_guid.into(),
      recipient_contacts: recipient_contacts.into(),
      privilege: privilege.into(),
      recipient_thread_id: recipient_thread_id.into(),
    }
  }
}

impl TSerializable for NotebookShareTemplate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotebookShareTemplate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::Guid> = None;
    let mut f_2: Option<Vec<types::Contact>> = None;
    let mut f_3: Option<types::SharedNotebookPrivilegeLevel> = None;
    let mut f_4: Option<types::MessageThreadID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Contact> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = types::Contact::read_from_in_protocol(i_prot)?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::SharedNotebookPrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotebookShareTemplate {
      notebook_guid: f_1,
      recipient_contacts: f_2,
      privilege: f_3,
      recipient_thread_id: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotebookShareTemplate");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.notebook_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_contacts {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientContacts", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recipient_thread_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientThreadId", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CreateOrUpdateNotebookSharesResult
//

/// A structure containing the results of a call to createOrUpdateNotebookShares.
/// 
/// <dl>
///   <dt>updateSequenceNum</dt>
///   <dd>The USN of the notebook after the call.</dd>
/// 
///   <dt>matchingShares</dt>
///   <dd>A list of SharedNotebook records that match the desired recipients. These
///       records may have been either created or updated by the call to
///       createOrUpdateNotebookShares, or they may have been at the desired privilege
///       privilege level prior to the call.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CreateOrUpdateNotebookSharesResult {
  pub update_sequence_num: Option<i32>,
  pub matching_shares: Option<Vec<types::SharedNotebook>>,
}

impl CreateOrUpdateNotebookSharesResult {
  pub fn new<F1, F2>(update_sequence_num: F1, matching_shares: F2) -> CreateOrUpdateNotebookSharesResult where F1: Into<Option<i32>>, F2: Into<Option<Vec<types::SharedNotebook>>> {
    CreateOrUpdateNotebookSharesResult {
      update_sequence_num: update_sequence_num.into(),
      matching_shares: matching_shares.into(),
    }
  }
}

impl TSerializable for CreateOrUpdateNotebookSharesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CreateOrUpdateNotebookSharesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<types::SharedNotebook>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::SharedNotebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = types::SharedNotebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CreateOrUpdateNotebookSharesResult {
      update_sequence_num: f_1,
      matching_shares: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CreateOrUpdateNotebookSharesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.matching_shares {
      o_prot.write_field_begin(&TFieldIdentifier::new("matchingShares", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteShareRelationshipRestrictions
//

/// This structure is used by the service to communicate to clients, via
/// getNoteShareRelationships, which privilege levels are assignable to the
/// target of a note share relationship.
/// 
/// <dl>
/// <dt>noSetReadNote</dt>
/// <dd>This value is true if the user is not allowed to set the privilege
/// level to SharedNotePrivilegeLevel.READ_NOTE.</dd>
/// 
/// <dt>noSetModifyNote</dt>
/// <dd>This value is true if the user is not allowed to set the privilege
/// level to SharedNotePrivilegeLevel.MODIFY_NOTE.</dd>
/// 
/// <dt>noSetFullAccess</dt>
/// <dd>This value is true if the user is not allowed to set the
/// privilege level to SharedNotePrivilegeLevel.FULL_ACCESS.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteShareRelationshipRestrictions {
  pub no_set_read_note: Option<bool>,
  pub no_set_modify_note: Option<bool>,
  pub no_set_full_access: Option<bool>,
}

impl NoteShareRelationshipRestrictions {
  pub fn new<F1, F2, F3>(no_set_read_note: F1, no_set_modify_note: F2, no_set_full_access: F3) -> NoteShareRelationshipRestrictions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>> {
    NoteShareRelationshipRestrictions {
      no_set_read_note: no_set_read_note.into(),
      no_set_modify_note: no_set_modify_note.into(),
      no_set_full_access: no_set_full_access.into(),
    }
  }
}

impl TSerializable for NoteShareRelationshipRestrictions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteShareRelationshipRestrictions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteShareRelationshipRestrictions {
      no_set_read_note: f_1,
      no_set_modify_note: f_2,
      no_set_full_access: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteShareRelationshipRestrictions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.no_set_read_note {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetReadNote", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_modify_note {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetModifyNote", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_full_access {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetFullAccess", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteMemberShareRelationship
//

/// Describes the association between a Note and an Evernote User who is
/// a member of that note.
/// 
/// <dl>
/// <dt>displayName</dt>
/// <dd>The string that clients should show to users to represent this
/// member.</dd>
/// 
/// <dt>recipientUserId</dt>
/// <dd>The Evernote UserID of the user who is a member to the note.</dd>
/// 
/// <dt>privilege</dt>
/// <dd>The privilege at which the member can access the note,
/// which is the best privilege granted to the user across all of their
/// individual shares for this note. This field is used by the service
/// to convey information to the user, so clients should treat it as
/// read-only.</dd>
/// 
/// <dt>restrictions</dt>
/// <dd>The restrictions on which privileges may be individually
/// assigned to the recipient of this share relationship. This field
/// is used by the service to convey information to the user, so
/// clients should treat it as read-only.</dd>
/// 
/// <dt>sharerUserId</dt>
/// <dd>The user id of the user who most recently shared the note with
/// this user. This field is used by the service to convey information
/// to the user, so clients should treat it as read-only.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteMemberShareRelationship {
  pub display_name: Option<String>,
  pub recipient_user_id: Option<types::UserID>,
  pub privilege: Option<types::SharedNotePrivilegeLevel>,
  pub restrictions: Option<NoteShareRelationshipRestrictions>,
  pub sharer_user_id: Option<types::UserID>,
}

impl NoteMemberShareRelationship {
  pub fn new<F1, F2, F3, F4, F5>(display_name: F1, recipient_user_id: F2, privilege: F3, restrictions: F4, sharer_user_id: F5) -> NoteMemberShareRelationship where F1: Into<Option<String>>, F2: Into<Option<types::UserID>>, F3: Into<Option<types::SharedNotePrivilegeLevel>>, F4: Into<Option<NoteShareRelationshipRestrictions>>, F5: Into<Option<types::UserID>> {
    NoteMemberShareRelationship {
      display_name: display_name.into(),
      recipient_user_id: recipient_user_id.into(),
      privilege: privilege.into(),
      restrictions: restrictions.into(),
      sharer_user_id: sharer_user_id.into(),
    }
  }
}

impl TSerializable for NoteMemberShareRelationship {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteMemberShareRelationship> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::UserID> = None;
    let mut f_3: Option<types::SharedNotePrivilegeLevel> = None;
    let mut f_4: Option<NoteShareRelationshipRestrictions> = None;
    let mut f_5: Option<types::UserID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::SharedNotePrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = NoteShareRelationshipRestrictions::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteMemberShareRelationship {
      display_name: f_1,
      recipient_user_id: f_2,
      privilege: f_3,
      restrictions: f_4,
      sharer_user_id: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteMemberShareRelationship");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recipient_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientUserId", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("restrictions", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sharer_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharerUserId", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteInvitationShareRelationship
//

/// Describes an invitation to a person to use their Evernote credentials
/// to gain access to a note belonging to another user.
/// 
/// <dl>
/// <dt>displayName</dt>
/// <dd>The string that clients should show to users to represent this
/// invitation.</dd>
/// 
/// <dt>recipientIdentityId</dt>
/// <dd>Identifies the identity of the invitation recipient. Once the
/// identity has been claimed by an Evernote user and they have accessed
/// the note at least once, the invitation will be used up and will no
/// longer be returned by the service to clients. Instead, that recipient
/// will be included in the list of NoteMemberShareRelationships.</dd>
/// 
/// <dt>privilege</dt>
/// <dd>The privilege level that the recipient will be granted when they
/// accept this invitation. If the user already has a higher privilege to
/// access this note then this will not affect the recipient's privileges.</dd>
/// 
/// <dt>sharerUserId</dt>
/// <dd>The user id of the user who most recently shared this note to this
/// recipient. This field is used by the service to convey information
/// to the user, so clients should treat it as read-only.</dd>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteInvitationShareRelationship {
  pub display_name: Option<String>,
  pub recipient_identity_id: Option<types::IdentityID>,
  pub privilege: Option<types::SharedNotePrivilegeLevel>,
  pub sharer_user_id: Option<types::UserID>,
}

impl NoteInvitationShareRelationship {
  pub fn new<F1, F2, F3, F5>(display_name: F1, recipient_identity_id: F2, privilege: F3, sharer_user_id: F5) -> NoteInvitationShareRelationship where F1: Into<Option<String>>, F2: Into<Option<types::IdentityID>>, F3: Into<Option<types::SharedNotePrivilegeLevel>>, F5: Into<Option<types::UserID>> {
    NoteInvitationShareRelationship {
      display_name: display_name.into(),
      recipient_identity_id: recipient_identity_id.into(),
      privilege: privilege.into(),
      sharer_user_id: sharer_user_id.into(),
    }
  }
}

impl TSerializable for NoteInvitationShareRelationship {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteInvitationShareRelationship> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::IdentityID> = None;
    let mut f_3: Option<types::SharedNotePrivilegeLevel> = None;
    let mut f_5: Option<types::UserID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::SharedNotePrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteInvitationShareRelationship {
      display_name: f_1,
      recipient_identity_id: f_2,
      privilege: f_3,
      sharer_user_id: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteInvitationShareRelationship");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("displayName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recipient_identity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientIdentityId", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sharer_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharerUserId", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteShareRelationships
//

/// Captures a collection of share relationships for a single note,
/// for example, as returned by the getNoteShares method. The share
/// relationships fall into two broad categories: members, and
/// invitations that can be used to become members.
/// 
/// <dl>
/// <dt>invitations</dt>
/// <dd>A list of open invitations that can be redeemed into
/// memberships to the note.</dd>
/// 
/// <dt>memberships</dt>
/// <dd>A list of memberships of the noteb. A member is identified
/// by their Evernote UserID and has rights to access the
/// note.</dd>
/// 
/// <dt>restrictions</dt>
/// <dd>The restrictions on which privileges may be assigned to the recipient
/// of an open invitation. These restrictions only apply to invitations;
/// restrictions on memberships are specified on the NoteMemberShareRelationship.
/// This field is used by the service to convey information to the user, so
/// clients should treat it as read-only.</dd>
/// 
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteShareRelationships {
  pub invitations: Option<Vec<NoteInvitationShareRelationship>>,
  pub memberships: Option<Vec<NoteMemberShareRelationship>>,
  pub invitation_restrictions: Option<NoteShareRelationshipRestrictions>,
}

impl NoteShareRelationships {
  pub fn new<F1, F2, F3>(invitations: F1, memberships: F2, invitation_restrictions: F3) -> NoteShareRelationships where F1: Into<Option<Vec<NoteInvitationShareRelationship>>>, F2: Into<Option<Vec<NoteMemberShareRelationship>>>, F3: Into<Option<NoteShareRelationshipRestrictions>> {
    NoteShareRelationships {
      invitations: invitations.into(),
      memberships: memberships.into(),
      invitation_restrictions: invitation_restrictions.into(),
    }
  }
}

impl TSerializable for NoteShareRelationships {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteShareRelationships> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<NoteInvitationShareRelationship>> = None;
    let mut f_2: Option<Vec<NoteMemberShareRelationship>> = None;
    let mut f_3: Option<NoteShareRelationshipRestrictions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NoteInvitationShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = NoteInvitationShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NoteMemberShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = NoteMemberShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = NoteShareRelationshipRestrictions::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteShareRelationships {
      invitations: f_1,
      memberships: f_2,
      invitation_restrictions: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteShareRelationships");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.invitations {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitations", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memberships {
      o_prot.write_field_begin(&TFieldIdentifier::new("memberships", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.invitation_restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitationRestrictions", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ManageNoteSharesParameters
//

/// Captures parameters used by clients to manage the shares for a given
/// note via the manageNoteShares function. This is used only to manage
/// the existing memberships and invitations for a note. To invite a new
/// recipient, use NoteStore.createOrUpdateSharedNotes.
/// 
/// The only field of an existing membership or invitation that can be
/// updated by this function is the share privilege.
/// 
/// <dl>
///   <dt>noteGuid</dt>
///   <dd>The GUID of the note whose shares are being managed.</dd>
/// 
///   <dt>membershipsToUpdate</dt>
///   <dd>A list of existing memberships to update. This field is not
///     meant to be the full set of memberships for the note. Clients
///     should only include those existing memberships that they wish
///     to modify. To remove an existing membership, see the unshares
///     field.</dd>
/// 
///   <dt>invitationsToUpdate</dt>
///   <dd>The list of outstanding invitations to update, as matched by the
///     identity field of the NoteInvitationShareRelatioship instances.
///     This field is not meant to be the full set of invitations for the
///     note. Clients should only include those existing invitations that
///     they wish to modify.</dd>
/// 
///   <dt>membershipsToUnshare</dt>
///   <dd>A list of existing memberships to expunge from the service.</dd>
/// 
///   <dt>invitationsToUnshare</dt>
///   <dd>A list of outstanding invitations to expunge from the service.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ManageNoteSharesParameters {
  pub note_guid: Option<String>,
  pub memberships_to_update: Option<Vec<NoteMemberShareRelationship>>,
  pub invitations_to_update: Option<Vec<NoteInvitationShareRelationship>>,
  pub memberships_to_unshare: Option<Vec<types::UserID>>,
  pub invitations_to_unshare: Option<Vec<types::IdentityID>>,
}

impl ManageNoteSharesParameters {
  pub fn new<F1, F2, F3, F4, F5>(note_guid: F1, memberships_to_update: F2, invitations_to_update: F3, memberships_to_unshare: F4, invitations_to_unshare: F5) -> ManageNoteSharesParameters where F1: Into<Option<String>>, F2: Into<Option<Vec<NoteMemberShareRelationship>>>, F3: Into<Option<Vec<NoteInvitationShareRelationship>>>, F4: Into<Option<Vec<types::UserID>>>, F5: Into<Option<Vec<types::IdentityID>>> {
    ManageNoteSharesParameters {
      note_guid: note_guid.into(),
      memberships_to_update: memberships_to_update.into(),
      invitations_to_update: invitations_to_update.into(),
      memberships_to_unshare: memberships_to_unshare.into(),
      invitations_to_unshare: invitations_to_unshare.into(),
    }
  }
}

impl TSerializable for ManageNoteSharesParameters {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ManageNoteSharesParameters> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<NoteMemberShareRelationship>> = None;
    let mut f_3: Option<Vec<NoteInvitationShareRelationship>> = None;
    let mut f_4: Option<Vec<types::UserID>> = None;
    let mut f_5: Option<Vec<types::IdentityID>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NoteMemberShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = NoteMemberShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NoteInvitationShareRelationship> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = NoteInvitationShareRelationship::read_from_in_protocol(i_prot)?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::UserID> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = i_prot.read_i32()?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::IdentityID> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = i_prot.read_i64()?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ManageNoteSharesParameters {
      note_guid: f_1,
      memberships_to_update: f_2,
      invitations_to_update: f_3,
      memberships_to_unshare: f_4,
      invitations_to_unshare: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ManageNoteSharesParameters");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.note_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memberships_to_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("membershipsToUpdate", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.invitations_to_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitationsToUpdate", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memberships_to_unshare {
      o_prot.write_field_begin(&TFieldIdentifier::new("membershipsToUnshare", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.invitations_to_unshare {
      o_prot.write_field_begin(&TFieldIdentifier::new("invitationsToUnshare", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ManageNoteSharesError
//

/// Captures errors that occur during a call to manageNoteShares. That
/// function can be run best-effort, meaning that some change requests can
/// be applied while others fail. Note that some errors such as system
/// exceptions may still cause the entire call to fail.
/// 
/// Only one of the two ID fields will be set on a given error.
/// 
/// Only one of the two exception fields will be set on a given error.
/// 
/// <dl>
///   <dt>identityID</dt>
///   <dd>The identity ID of an outstanding invitation that was not updated
///     due to the error.</dd>
/// 
///   <dt>userID</dt>
///   <dd>The user ID of an existing membership that was not updated due
///     to the error.</dd>
/// 
///   <dt>userException</dt>
///   <dd>If the error is represented as an EDAMUserException that would
///     have otherwise been thrown without best-effort execution.</dd>
/// 
///   <dt>notFoundException</dt>
///   <dd>If the error is represented as an EDAMNotFoundException that
///     would have otherwise been thrown without best-effort execution.
///     The identifier field of the exception will be either "Identity.id"
///     or "User.id", indicating that no existing share could be found for
///     the specified recipient.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ManageNoteSharesError {
  pub identity_i_d: Option<types::IdentityID>,
  pub user_i_d: Option<types::UserID>,
  pub user_exception: Option<errors::EDAMUserException>,
  pub not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl ManageNoteSharesError {
  pub fn new<F1, F2, F3, F4>(identity_i_d: F1, user_i_d: F2, user_exception: F3, not_found_exception: F4) -> ManageNoteSharesError where F1: Into<Option<types::IdentityID>>, F2: Into<Option<types::UserID>>, F3: Into<Option<errors::EDAMUserException>>, F4: Into<Option<errors::EDAMNotFoundException>> {
    ManageNoteSharesError {
      identity_i_d: identity_i_d.into(),
      user_i_d: user_i_d.into(),
      user_exception: user_exception.into(),
      not_found_exception: not_found_exception.into(),
    }
  }
}

impl TSerializable for ManageNoteSharesError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ManageNoteSharesError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::IdentityID> = None;
    let mut f_2: Option<types::UserID> = None;
    let mut f_3: Option<errors::EDAMUserException> = None;
    let mut f_4: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ManageNoteSharesError {
      identity_i_d: f_1,
      user_i_d: f_2,
      user_exception: f_3,
      not_found_exception: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ManageNoteSharesError");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.identity_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("identityID", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("userID", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ManageNoteSharesResult
//

/// The return value of a call to the manageNoteShares function.
/// 
/// <dl>
///   <dt>errors</dt>
///   <dd>If the call succeeded without throwing an exception, some errors
///     might still have occurred. In that case, this field will contain the
///     list of errors.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ManageNoteSharesResult {
  pub errors: Option<Vec<ManageNoteSharesError>>,
}

impl ManageNoteSharesResult {
  pub fn new<F1>(errors: F1) -> ManageNoteSharesResult where F1: Into<Option<Vec<ManageNoteSharesError>>> {
    ManageNoteSharesResult {
      errors: errors.into(),
    }
  }
}

impl TSerializable for ManageNoteSharesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ManageNoteSharesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ManageNoteSharesError>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ManageNoteSharesError> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_48 = ManageNoteSharesError::read_from_in_protocol(i_prot)?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ManageNoteSharesResult {
      errors: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ManageNoteSharesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.errors {
      o_prot.write_field_begin(&TFieldIdentifier::new("errors", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStore service client
//

/// Service:  NoteStore
/// <p>
/// The NoteStore service is used by EDAM clients to exchange information
/// about the collection of notes in an account. This is primarily used for
/// synchronization, but could also be used by a "thin" client without a full
/// local cache.
/// </p><p>
/// Most functions take an "authenticationToken" parameter, which is the
/// value returned by the UserStore which permits access to the account.
/// </p>
/// 
/// Calls which require an authenticationToken may throw an EDAMUserException
/// for the following reasons:
///  <ul>
///   <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
///   <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
///   <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
///   <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
///   <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
///       to perform the requested action</li>
///   <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
///       that requires single sign-on, and must complete SSO before accessing business
///       content.
/// </ul>
pub trait TNoteStoreSyncClient {
  /// Asks the NoteStore to provide information about the status of the user
  /// account corresponding to the provided authentication token.
  fn get_sync_state(&mut self, authentication_token: String) -> thrift::Result<SyncState>;
  /// Asks the NoteStore to provide the state of the account in order of
  /// last modification.  This request retrieves one block of the server's
  /// state so that a client can make several small requests against a large
  /// account rather than getting the entire state in one big message.
  /// This call gives fine-grained control of the data that will
  /// be received by a client by omitting data elements that a client doesn't
  /// need. This may reduce network traffic and sync times.
  /// 
  /// @param afterUSN
  ///   The client can pass this value to ask only for objects that
  ///   have been updated after a certain point.  This allows the client to
  ///   receive updates after its last checkpoint rather than doing a full
  ///   synchronization on every pass.  The default value of "0" indicates
  ///   that the client wants to get objects from the start of the account.
  /// 
  /// @param maxEntries
  ///   The maximum number of modified objects that should be
  ///   returned in the result SyncChunk.  This can be used to limit the size
  ///   of each individual message to be friendly for network transfer.
  /// 
  /// @param filter
  ///   The caller must set some of the flags in this structure to specify which
  ///   data types should be returned during the synchronization.  See
  ///   the SyncChunkFilter structure for information on each flag.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
  ///   </li>
  /// </ul>
  fn get_filtered_sync_chunk(&mut self, authentication_token: String, after_u_s_n: i32, max_entries: i32, filter: SyncChunkFilter) -> thrift::Result<SyncChunk>;
  /// Asks the NoteStore to provide information about the status of a linked
  /// notebook that has been shared with the caller, or that is public to the
  /// world.
  /// This will return a result that is similar to getSyncState, but may omit
  /// SyncState.uploaded if the caller doesn't have permission to write to
  /// the linked notebook.
  /// 
  /// This function must be called on the shard that owns the referenced
  /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
  /// same as LinkedNotebook.shardId.)
  /// 
  /// @param authenticationToken
  ///   This should be an authenticationToken for the guest who has received
  ///   the invitation to the share.  (I.e. this should not be the result of
  ///   NoteStore.authenticateToSharedNotebook)
  /// 
  /// @param linkedNotebook
  ///   This structure should contain identifying information and permissions
  ///   to access the notebook in question.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
  ///       populated with the current username of the owner of the notebook for which
  ///       you are obtaining sync state.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
  ///       correspond to a current user on the service.
  ///   </li>
  /// </ul>
  /// 
  /// @throws SystemException <ul>
  ///   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
  ///       user whose account is on a shard other than that on which this method was
  ///       invoked.
  ///   </li>
  /// </ul>
  fn get_linked_notebook_sync_state(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<SyncState>;
  /// Asks the NoteStore to provide information about the contents of a linked
  /// notebook that has been shared with the caller, or that is public to the
  /// world.
  /// This will return a result that is similar to getSyncChunk, but will only
  /// contain entries that are visible to the caller.  I.e. only that particular
  /// Notebook will be visible, along with its Notes, and Tags on those Notes.
  /// 
  /// This function must be called on the shard that owns the referenced
  /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
  /// same as LinkedNotebook.shardId.)
  /// 
  /// @param authenticationToken
  ///   This should be an authenticationToken for the guest who has received
  ///   the invitation to the share.  (I.e. this should not be the result of
  ///   NoteStore.authenticateToSharedNotebook)
  /// 
  /// @param linkedNotebook
  ///   This structure should contain identifying information and permissions
  ///   to access the notebook in question.  This must contain the valid fields
  ///   for either a shared notebook (e.g. shareKey)
  ///   or a public notebook (e.g. username, uri)
  /// 
  /// @param afterUSN
  ///   The client can pass this value to ask only for objects that
  ///   have been updated after a certain point.  This allows the client to
  ///   receive updates after its last checkpoint rather than doing a full
  ///   synchronization on every pass.  The default value of "0" indicates
  ///   that the client wants to get objects from the start of the account.
  /// 
  /// @param maxEntries
  ///   The maximum number of modified objects that should be
  ///   returned in the result SyncChunk.  This can be used to limit the size
  ///   of each individual message to be friendly for network transfer.
  ///   Applications should not request more than 256 objects at a time,
  ///   and must handle the case where the service returns less than the
  ///   requested number of objects in a given request even though more
  ///   objects are available on the service.
  /// 
  /// @param fullSyncOnly
  ///   If true, then the client only wants initial data for a full sync.
  ///   In this case, the service will not return any expunged objects,
  ///   and will not return any Resources, since these are also provided
  ///   in their corresponding Notes.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "LinkedNotebook" - if the provided information doesn't match any
  ///     valid notebook
  ///   </li>
  ///   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
  ///     valid notebook
  ///   </li>
  ///   <li> "SharedNotebook.id" - if the provided information indicates a
  ///      shared notebook that no longer exists
  ///   </li>
  /// </ul>
  fn get_linked_notebook_sync_chunk(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook, after_u_s_n: i32, max_entries: i32, full_sync_only: bool) -> thrift::Result<SyncChunk>;
  /// Returns a list of all of the notebooks in the account.
  fn list_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::Notebook>>;
  /// Returns a list of all the notebooks in a business that the user has permission to access,
  /// regardless of whether the user has joined them. This includes notebooks that have been shared
  /// with the entire business as well as notebooks that have been shared directly with the user.
  /// 
  /// @param authenticationToken A business authentication token obtained by calling
  ///   UserStore.authenticateToBusiness.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
  ///     business auth token.</li>
  /// </ul>
  fn list_accessible_business_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::Notebook>>;
  /// Returns the current state of the notebook with the provided GUID.
  /// The notebook may be active or deleted (but not expunged).
  /// 
  /// @param guid
  ///   The GUID of the notebook to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn get_notebook(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::Notebook>;
  /// Returns the notebook that should be used to store new notes in the
  /// user's account when no other notebooks are specified.
  fn get_default_notebook(&mut self, authentication_token: String) -> thrift::Result<types::Notebook>;
  /// Asks the service to make a notebook with the provided name.
  /// 
  /// @param notebook
  ///   The desired fields for the notebook must be provided on this
  ///   object.  The name of the notebook must be set, and either the 'active'
  ///   or 'defaultNotebook' fields may be set by the client at creation.
  ///   If a notebook exists in the account with the same name (via
  ///   case-insensitive compare), this will throw an EDAMUserException.
  /// 
  /// @return
  ///   The newly created Notebook.  The server-side GUID will be
  ///   saved in this object's 'guid' field.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
  ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
  ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
  ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
  ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
  ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
  ///        is set to 'true' for a Notebook that is not owned by the user identified by
  ///        the passed authenticationToken.</li>
  ///   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Workspace.guid" - if workspaceGuid set and no Workspace exists for the GUID
  ///   </li>
  /// </ul>
  fn create_notebook(&mut self, authentication_token: String, notebook: types::Notebook) -> thrift::Result<types::Notebook>;
  /// Submits notebook changes to the service. The provided data must include the
  /// notebook's guid field for identification.
  /// <p />
  /// The Notebook will be moved to the specified Workspace, if a non empty
  /// Notebook.workspaceGuid is provided. If an empty Notebook.workspaceGuid is set and the
  /// Notebook is in a Workspace, then it will be removed from the Workspace and a full
  /// access SharedNotebook record will be ensured for the caller. If the caller does not
  /// already have a full access share, either the privilege of an existing share will be
  /// upgraded or a new share will be created. It is illegal to set a
  /// Notebook.workspaceGuid on a Workspace backing Notebook.
  /// 
  /// @param notebook
  ///   The notebook object containing the requested changes.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
  ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
  ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
  ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
  ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
  ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
  ///        is set to 'true' for a Notebook that is not owned by the user identified by
  ///        the passed authenticationToken.</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID</li>
  ///   <li> "Workspace.guid" - if a non empty workspaceGuid set and no Workspace exists
  ///        for the GUID
  ///   </li>
  /// </ul>
  fn update_notebook(&mut self, authentication_token: String, notebook: types::Notebook) -> thrift::Result<i32>;
  /// Permanently removes the notebook from the user's account.
  /// After this action, the notebook is no longer available for undeletion, etc.
  /// If the notebook contains any Notes, they will be moved to the current
  /// default notebook and moved into the trash (i.e. Note.active=false).
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the notebook to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
  ///   </li>
  ///   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
  ///   </li>
  ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
  ///   </li>
  /// </ul>
  fn expunge_notebook(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Returns a list of the tags in the account.  Evernote does not support
  /// the undeletion of tags, so this will only include active tags.
  fn list_tags(&mut self, authentication_token: String) -> thrift::Result<Vec<types::Tag>>;
  /// Returns a list of the tags that are applied to at least one note within
  /// the provided notebook.  If the notebook is public, the authenticationToken
  /// may be ignored.
  /// 
  /// @param notebookGuid
  ///    the GUID of the notebook to use to find tags
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - notebook not found by GUID
  ///   </li>
  /// </ul>
  fn list_tags_by_notebook(&mut self, authentication_token: String, notebook_guid: types::Guid) -> thrift::Result<Vec<types::Tag>>;
  /// Returns the current state of the Tag with the provided GUID.
  /// 
  /// @param guid
  ///   The GUID of the tag to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn get_tag(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::Tag>;
  /// Asks the service to make a tag with a set of information.
  /// 
  /// @param tag
  ///   The desired list of fields for the tag are specified in this
  ///   object.  The caller must specify the tag name, and may provide
  ///   the parentGUID.
  /// 
  /// @return
  ///   The newly created Tag.  The server-side GUID will be
  ///   saved in this object.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
  ///   </li>
  ///   <li> DATA_CONFLICT "Tag.name" - name already in use
  ///   </li>
  ///   <li> LIMIT_REACHED "Tag" - at max number of tags
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.parentGuid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn create_tag(&mut self, authentication_token: String, tag: types::Tag) -> thrift::Result<types::Tag>;
  /// Submits tag changes to the service.  The provided data must include
  /// the tag's guid field for identification.  The service will apply
  /// updates to the following tag fields:  name, parentGuid
  /// 
  /// @param tag
  ///   The tag object containing the requested changes.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
  ///   </li>
  ///   <li> DATA_CONFLICT "Tag.name" - name already in use
  ///   </li>
  ///   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  ///   <li> "Tag.parentGuid" - parent not found, by GUID
  ///   </li>
  /// </ul>
  fn update_tag(&mut self, authentication_token: String, tag: types::Tag) -> thrift::Result<i32>;
  /// Removes the provided tag from every note that is currently tagged with
  /// this tag.  If this operation is successful, the tag will still be in
  /// the account, but it will not be tagged on any notes.
  /// 
  /// This function is not indended for use by full synchronizing clients, since
  /// it does not provide enough result information to the client to reconcile
  /// the local state without performing a follow-up sync from the service.  This
  /// is intended for "thin clients" that need to efficiently support this as
  /// a UI operation.
  /// 
  /// @param guid
  ///   The GUID of the tag to remove from all notes.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn untag_all(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<()>;
  /// Permanently deletes the tag with the provided GUID, if present.
  /// <p/>
  /// NOTE: This function is not generally available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the tag to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn expunge_tag(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Returns a list of the searches in the account.  Evernote does not support
  /// the undeletion of searches, so this will only include active searches.
  fn list_searches(&mut self, authentication_token: String) -> thrift::Result<Vec<types::SavedSearch>>;
  /// Returns the current state of the search with the provided GUID.
  /// 
  /// @param guid
  ///   The GUID of the search to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
  ///   </li>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SavedSearch.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_search(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::SavedSearch>;
  /// Asks the service to make a saved search with a set of information.
  /// 
  /// @param search
  ///   The desired list of fields for the search are specified in this
  ///   object. The caller must specify the name and query for the
  ///   search, and may optionally specify a search scope.
  ///   The SavedSearch.format field is ignored by the service.
  /// 
  /// @return
  ///   The newly created SavedSearch.  The server-side GUID will be
  ///   saved in this object.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
  ///   </li>
  ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
  ///   </li>
  ///   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
  ///   </li>
  /// </ul>
  fn create_search(&mut self, authentication_token: String, search: types::SavedSearch) -> thrift::Result<types::SavedSearch>;
  /// Submits search changes to the service. The provided data must include
  /// the search's guid field for identification. The service will apply
  /// updates to the following search fields: name, query, and scope.
  /// 
  /// @param search
  ///   The search object containing the requested changes.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
  ///   </li>
  ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
  ///   </li>
  ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SavedSearch.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn update_search(&mut self, authentication_token: String, search: types::SavedSearch) -> thrift::Result<i32>;
  /// Permanently deletes the saved search with the provided GUID, if present.
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the search to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
  ///   </li>
  ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SavedSearch.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn expunge_search(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Finds the position of a note within a sorted subset of all of the user's
  /// notes. This may be useful for thin clients that are displaying a paginated
  /// listing of a large account, which need to know where a particular note
  /// sits in the list without retrieving all notes first.
  /// 
  /// @param authenticationToken
  ///   Must be a valid token for the user's account unless the NoteFilter
  ///   'notebookGuid' is the GUID of a public notebook.
  /// 
  /// @param filter
  ///   The list of criteria that will constrain the notes to be returned.
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @return
  ///   If the note with the provided GUID is found within the matching note
  ///   list, this will return the offset of that note within that list (where
  ///   the first offset is 0).  If the note is not found within the set of
  ///   notes, this will return -1.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  ///   </li>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID
  ///   </li>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn find_note_offset(&mut self, authentication_token: String, filter: NoteFilter, guid: types::Guid) -> thrift::Result<i32>;
  /// Used to find the high-level information about a set of the notes from a
  /// user's account based on various criteria specified via a NoteFilter object.
  /// <p/>
  /// Web applications that wish to periodically check for new content in a user's
  /// Evernote account should consider using webhooks instead of polling this API.
  /// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
  /// for more information.
  /// 
  /// @param authenticationToken
  ///   Must be a valid token for the user's account unless the NoteFilter
  ///   'notebookGuid' is the GUID of a public notebook.
  /// 
  /// @param filter
  ///   The list of criteria that will constrain the notes to be returned.
  /// 
  /// @param offset
  ///   The numeric index of the first note to show within the sorted
  ///   results.  The numbering scheme starts with "0".  This can be used for
  ///   pagination.
  /// 
  /// @param maxNotes
  ///   The maximum notes to return in this query.  The service will return a set
  ///   of notes that is no larger than this number, but may return fewer notes
  ///   if needed.  The NoteList.totalNotes field in the return value will
  ///   indicate whether there are more values available after the returned set.
  ///   Currently, the service will not return more than 250 notes in a single request,
  ///   but this number may change in the future.
  /// 
  /// @param resultSpec
  ///   This specifies which information should be returned for each matching
  ///   Note. The fields on this structure can be used to eliminate data that
  ///   the client doesn't need, which will reduce the time and bandwidth
  ///   to receive and process the reply.
  /// 
  /// @return
  ///   The list of notes that match the criteria.
  ///   The Notes.sharedNotes field will not be set.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn find_notes_metadata(&mut self, authentication_token: String, filter: NoteFilter, offset: i32, max_notes: i32, result_spec: NotesMetadataResultSpec) -> thrift::Result<NotesMetadataList>;
  /// This function is used to determine how many notes are found for each
  /// notebook and tag in the user's account, given a current set of filter
  /// parameters that determine the current selection.  This function will
  /// return a structure that gives the note count for each notebook and tag
  /// that has at least one note under the requested filter.  Any notebook or
  /// tag that has zero notes in the filtered set will not be listed in the
  /// reply to this function (so they can be assumed to be 0).
  /// 
  /// @param authenticationToken
  ///   Must be a valid token for the user's account unless the NoteFilter
  ///   'notebookGuid' is the GUID of a public notebook.
  /// 
  /// @param filter
  ///   The note selection filter that is currently being applied.  The note
  ///   counts are to be calculated with this filter applied to the total set
  ///   of notes in the user's account.
  /// 
  /// @param withTrash
  ///   If true, then the NoteCollectionCounts.trashCount will be calculated
  ///   and supplied in the reply. Otherwise, the trash value will be omitted.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
  ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
  ///   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID</li>
  /// </ul>
  fn find_note_counts(&mut self, authentication_token: String, filter: NoteFilter, with_trash: bool) -> thrift::Result<NoteCollectionCounts>;
  /// Returns the current state of the note in the service with the provided
  /// GUID.  The ENML contents of the note will only be provided if the
  /// 'withContent' parameter is true.  The service will include the meta-data
  /// for each resource in the note, but the binary content depends
  /// on whether it is explicitly requested in resultSpec parameter.
  /// If the Note is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).  The applicationData
  /// fields are returned as keysOnly.
  /// 
  /// @param authenticationToken
  ///   An authentication token that grants the caller access to the requested note.
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @param resultSpec
  ///   A structure specifying the fields of the note that the caller would like to get.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_note_with_result_spec(&mut self, authentication_token: String, guid: types::Guid, result_spec: NoteResultSpec) -> thrift::Result<types::Note>;
  /// DEPRECATED. See getNoteWithResultSpec.
  /// 
  /// This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
  /// mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
  /// populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
  fn get_note(&mut self, authentication_token: String, guid: types::Guid, with_content: bool, with_resources_data: bool, with_resources_recognition: bool, with_resources_alternate_data: bool) -> thrift::Result<types::Note>;
  /// Get all of the application data for the note identified by GUID,
  /// with values returned within the LazyMap fullMap field.
  /// If there are no applicationData entries, then a LazyMap
  /// with an empty fullMap will be returned. If your application
  /// only needs to fetch its own applicationData entry, use
  /// getNoteApplicationDataEntry instead.
  fn get_note_application_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::LazyMap>;
  /// Get the value of a single entry in the applicationData map
  /// for the note identified by GUID.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - note not found, by GUID</li>
  ///   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
  /// </ul>
  fn get_note_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<String>;
  /// Update, or create, an entry in the applicationData map for
  /// the note identified by guid.
  fn set_note_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String, value: String) -> thrift::Result<i32>;
  /// Remove an entry identified by 'key' from the applicationData map for
  /// the note identified by 'guid'. Silently ignores an unset of a
  /// non-existing key.
  fn unset_note_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<i32>;
  /// Returns XHTML contents of the note with the provided GUID.
  /// If the Note is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_note_content(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<String>;
  /// Returns a block of the extracted plain text contents of the note with the
  /// provided GUID.  This text can be indexed for search purposes by a light
  /// client that doesn't have capabilities to extract all of the searchable
  /// text content from the note and its resources.
  /// 
  /// If the Note is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @param noteOnly
  ///   If true, this will only return the text extracted from the ENML contents
  ///   of the note itself.  If false, this will also include the extracted text
  ///   from any text-bearing resources (PDF, recognized images)
  /// 
  /// @param tokenizeForIndexing
  ///   If true, this will break the text into cleanly separated and sanitized
  ///   tokens.  If false, this will return the more raw text extraction, with
  ///   its original punctuation, capitalization, spacing, etc.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_note_search_text(&mut self, authentication_token: String, guid: types::Guid, note_only: bool, tokenize_for_indexing: bool) -> thrift::Result<String>;
  /// Returns a block of the extracted plain text contents of the resource with
  /// the provided GUID.  This text can be indexed for search purposes by a light
  /// client that doesn't have capability to extract all of the searchable
  /// text content from a resource.
  /// 
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_resource_search_text(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<String>;
  /// Returns a list of the names of the tags for the note with the provided
  /// guid.  This can be used with authentication to get the tags for a
  /// user's own note, or can be used without valid authentication to retrieve
  /// the names of the tags for a note in a public notebook.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_note_tag_names(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<String>>;
  /// Asks the service to make a note with the provided set of information.
  /// 
  /// @param note
  ///   A Note object containing the desired fields to be populated on
  ///   the service.
  /// 
  /// @return
  ///   The newly created Note from the service.  The server-side
  ///   GUIDs for the Note and any Resources will be saved in this object.
  ///   The service will include the meta-data
  ///   for each resource in the note, but the binary contents of the resources
  ///   and their recognition data will be omitted (except Recognition Resource body,
  ///   for which the behavior is unspecified).
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  ///   </li>
  ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
  ///   </li>
  ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
  ///   </li>
  ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  ///   </li>
  ///   <li> LIMIT_REACHED "Note" - at max number per account
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.size" - total note size too large
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
  ///   </li>
  ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
  ///   </li>
  ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
  ///     of the specified tags had an invalid length or pattern
  ///   </li>
  ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
  ///     new tags would exceed the maximum number per account
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.notebookGuid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn create_note(&mut self, authentication_token: String, note: types::Note) -> thrift::Result<types::Note>;
  /// Submit a set of changes to a note to the service.  The provided data
  /// must include the note's guid field for identification. The note's
  /// title must also be set.
  /// 
  /// @param note
  ///   A Note object containing the desired fields to be populated on
  ///   the service. With the exception of the note's title and guid, fields
  ///   that are not being changed do not need to be set. If the content is not
  ///   being modified, note.content should be left unset. If the list of
  ///   resources is not being modified, note.resources should be left unset.
  /// 
  /// @return
  ///   The Note.sharedNotes field will not be set.
  ///   The service will include the meta-data
  ///   for each resource in the note, but the binary contents of the resources
  ///   and their recognition data will be omitted.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  ///   </li>
  ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
  ///   </li>
  ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
  ///   </li>
  ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.size" - total note size too large
  ///   </li>
  ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
  ///   </li>
  ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
  ///   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
  ///     modify the note's tags. note.tags must be unset.
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
  ///     to modify the note's attributes. note.attributes must be unset.
  ///   </li>
  ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
  ///     of the specified tags had an invalid length or pattern
  ///   </li>
  ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
  ///     new tags would exceed the maximum number per account
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - note not found, by GUID
  ///   </li>
  ///   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
  ///   </li>
  /// </ul>
  fn update_note(&mut self, authentication_token: String, note: types::Note) -> thrift::Result<types::Note>;
  /// Moves the note into the trash. The note may still be undeleted, unless it
  /// is expunged.  This is equivalent to calling updateNote() after setting
  /// Note.active = false
  /// 
  /// @param guid
  ///   The GUID of the note to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
  ///          update the note.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
  ///   </li>
  /// </ul>
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn delete_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Permanently removes a Note, and all of its Resources,
  /// from the service.
  /// <p/>
  /// NOTE: This function is not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the note to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "Note" - user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn expunge_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
  /// the Notebook with the provided GUID 'toNotebookGuid'.
  /// The caller must be the owner of both the Note and the Notebook.
  /// This creates a new Note in the destination Notebook with new content and
  /// Resources that match all of the content and Resources from the original
  /// Note, but with new GUID identifiers.
  /// The original Note is not modified by this operation.
  /// The copied note is considered as an "upload" for the purpose of upload
  /// transfer limit calculation, so its size is added to the upload count for
  /// the owner.
  /// 
  /// If the original note has been shared and has SharedNote records, the shares
  /// are NOT copied.
  /// 
  /// @param noteGuid
  ///   The GUID of the Note to copy.
  /// 
  /// @param toNotebookGuid
  ///   The GUID of the Notebook that should receive the new Note.
  /// 
  /// @return
  ///   The metadata for the new Note that was created.  This will include the
  ///   new GUID for this Note (and any copied Resources), but will not include
  ///   the content body or the binary bodies of any Resources.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> LIMIT_REACHED "Note" - at max number per account
  ///   </li>
  ///   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - user doesn't own
  ///   </li>
  ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn copy_note(&mut self, authentication_token: String, note_guid: types::Guid, to_notebook_guid: types::Guid) -> thrift::Result<types::Note>;
  /// Returns a list of the prior versions of a particular note that are
  /// saved within the service.  These prior versions are stored to provide a
  /// recovery from unintentional removal of content from a note. The identifiers
  /// that are returned by this call can be used with getNoteVersion to retrieve
  /// the previous note.
  /// The identifiers will be listed from the most recent versions to the oldest.
  /// This call is only available for notes in Premium accounts. (I.e. access
  /// to past versions of Notes is a Premium-only feature.)
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID.
  ///   </li>
  /// </ul>
  fn list_note_versions(&mut self, authentication_token: String, note_guid: types::Guid) -> thrift::Result<Vec<NoteVersionId>>;
  /// This can be used to retrieve a previous version of a Note after it has been
  /// updated within the service.  The caller must identify the note (via its
  /// guid) and the version (via the updateSequenceNumber of that version).
  /// to find a listing of the stored version USNs for a note, call
  /// listNoteVersions.
  /// This call is only available for notes in Premium accounts. (I.e. access
  /// to past versions of Notes is a Premium-only feature.)
  /// 
  /// @param noteGuid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @param updateSequenceNum
  ///   The USN of the version of the note that is being retrieved
  /// 
  /// @param withResourcesData
  ///   If true, any Resource elements in this Note will include the binary
  ///   contents of their 'data' field's body.
  /// 
  /// @param withResourcesRecognition
  ///   If true, any Resource elements will include the binary contents of the
  ///   'recognition' field's body if recognition data is present.
  /// 
  /// @param withResourcesAlternateData
  ///   If true, any Resource elements in this Note will include the binary
  ///   contents of their 'alternateData' fields' body, if an alternate form
  ///   is present.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID.
  ///   </li>
  ///   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
  ///      the corresponding USN.
  ///   </li>
  /// </ul>
  fn get_note_version(&mut self, authentication_token: String, note_guid: types::Guid, update_sequence_num: i32, with_resources_data: bool, with_resources_recognition: bool, with_resources_alternate_data: bool) -> thrift::Result<types::Note>;
  /// Returns the current state of the resource in the service with the
  /// provided GUID.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).  Only the
  /// keys for the applicationData will be returned.
  /// 
  /// @param guid
  ///   The GUID of the resource to be retrieved.
  /// 
  /// @param withData
  ///   If true, the Resource will include the binary contents of the
  ///   'data' field's body.
  /// 
  /// @param withRecognition
  ///   If true, the Resource will include the binary contents of the
  ///   'recognition' field's body if recognition data is present.
  /// 
  /// @param withAttributes
  ///   If true, the Resource will include the attributes
  /// 
  /// @param withAlternateData
  ///   If true, the Resource will include the binary contents of the
  ///   'alternateData' field's body, if an alternate form is present.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_resource(&mut self, authentication_token: String, guid: types::Guid, with_data: bool, with_recognition: bool, with_attributes: bool, with_alternate_data: bool) -> thrift::Result<types::Resource>;
  /// Get all of the application data for the Resource identified by GUID,
  /// with values returned within the LazyMap fullMap field.
  /// If there are no applicationData entries, then a LazyMap
  /// with an empty fullMap will be returned. If your application
  /// only needs to fetch its own applicationData entry, use
  /// getResourceApplicationDataEntry instead.
  fn get_resource_application_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::LazyMap>;
  /// Get the value of a single entry in the applicationData map
  /// for the Resource identified by GUID.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - Resource not found, by GUID</li>
  ///   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
  /// </ul>
  fn get_resource_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<String>;
  /// Update, or create, an entry in the applicationData map for
  /// the Resource identified by guid.
  fn set_resource_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String, value: String) -> thrift::Result<i32>;
  /// Remove an entry identified by 'key' from the applicationData map for
  /// the Resource identified by 'guid'.
  fn unset_resource_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<i32>;
  /// Submit a set of changes to a resource to the service.  This can be used
  /// to update the meta-data about the resource, but cannot be used to change
  /// the binary contents of the resource (including the length and hash).  These
  /// cannot be changed directly without creating a new resource and removing the
  /// old one via updateNote.
  /// 
  /// @param resource
  ///   A Resource object containing the desired fields to be populated on
  ///   the service.  The service will attempt to update the resource with the
  ///   following fields from the client:
  ///   <ul>
  ///      <li>guid:  must be provided to identify the resource
  ///      </li>
  ///      <li>mime
  ///      </li>
  ///      <li>width
  ///      </li>
  ///      <li>height
  ///      </li>
  ///      <li>duration
  ///      </li>
  ///      <li>attributes:  optional.  if present, the set of attributes will
  ///           be replaced.
  ///      </li>
  ///   </ul>
  /// 
  /// @return
  ///   The Update Sequence Number of the resource after the changes have been
  ///   applied.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  ///   </li>
  ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn update_resource(&mut self, authentication_token: String, resource: types::Resource) -> thrift::Result<i32>;
  /// Returns binary data of the resource with the provided GUID.  For
  /// example, if this were an image resource, this would contain the
  /// raw bits of the image.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_resource_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>>;
  /// Returns the current state of a resource, referenced by containing
  /// note GUID and resource content hash.
  /// 
  /// @param noteGuid
  ///   The GUID of the note that holds the resource to be retrieved.
  /// 
  /// @param contentHash
  ///   The MD5 checksum of the resource within that note. Note that
  ///   this is the binary checksum, for example from Resource.data.bodyHash,
  ///   and not the hex-encoded checksum that is used within an en-media
  ///   tag in a note body.
  /// 
  /// @param withData
  ///   If true, the Resource will include the binary contents of the
  ///   'data' field's body.
  /// 
  /// @param withRecognition
  ///   If true, the Resource will include the binary contents of the
  ///   'recognition' field's body.
  /// 
  /// @param withAlternateData
  ///   If true, the Resource will include the binary contents of the
  ///   'alternateData' field's body, if an alternate form is present.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
  ///   </li>
  ///   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note" - not found, by guid
  ///   </li>
  ///   <li> "Resource" - not found, by hash
  ///   </li>
  /// </ul>
  fn get_resource_by_hash(&mut self, authentication_token: String, note_guid: types::Guid, content_hash: Vec<u8>, with_data: bool, with_recognition: bool, with_alternate_data: bool) -> thrift::Result<types::Resource>;
  /// Returns the binary contents of the recognition index for the resource
  /// with the provided GUID.  If the caller asks about a resource that has
  /// no recognition data, this will throw EDAMNotFoundException.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource whose recognition data should be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  ///   <li> "Resource.recognition" - resource has no recognition
  ///   </li>
  /// </ul>
  fn get_resource_recognition(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>>;
  /// If the Resource with the provided GUID has an alternate data representation
  /// (indicated via the Resource.alternateData field), then this request can
  /// be used to retrieve the binary contents of that alternate data file.
  /// If the caller asks about a resource that has no alternate data form, this
  /// will throw EDAMNotFoundException.
  /// 
  /// @param guid
  ///    The GUID of the resource whose recognition data should be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  ///   <li> "Resource.alternateData" - resource has no recognition
  ///   </li>
  /// </ul>
  fn get_resource_alternate_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>>;
  /// Returns the set of attributes for the Resource with the provided GUID.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource whose attributes should be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn get_resource_attributes(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::ResourceAttributes>;
  /// <p>
  /// Looks for a user account with the provided userId on this NoteStore
  /// shard and determines whether that account contains a public notebook
  /// with the given URI.  If the account is not found, or no public notebook
  /// exists with this URI, this will throw an EDAMNotFoundException,
  /// otherwise this will return the information for that Notebook.
  /// </p>
  /// <p>
  /// If a notebook is visible on the web with a full URL like
  /// http://www.evernote.com/pub/sethdemo/api
  /// Then 'sethdemo' is the username that can be used to look up the userId,
  /// and 'api' is the publicUri.
  /// </p>
  /// 
  /// @param userId
  ///    The numeric identifier for the user who owns the public notebook.
  ///    To find this value based on a username string, you can invoke
  ///    UserStore.getPublicUserInfo
  /// 
  /// @param publicUri
  ///    The uri string for the public notebook, from Notebook.publishing.uri.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"Publishing.uri" - not found, by URI</li>
  /// </ul>
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
  ///     taken down (for all requesters).</li>
  ///   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
  ///     down for the requester because of an IP-based country lookup.</li>
  /// </ul>
  fn get_public_notebook(&mut self, user_id: types::UserID, public_uri: String) -> thrift::Result<types::Notebook>;
  /// * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
  /// *
  /// * Share a notebook with an email address, and optionally to a specific
  /// * recipient. If an existing SharedNotebook associated with
  /// * sharedNotebook.notebookGuid is found by recipientUsername or email, then
  /// * the values of sharedNotebook will be used to update the existing record,
  /// * else a new record will be created.
  /// *
  /// * If recipientUsername is set and there is already a SharedNotebook
  /// * for that Notebook with that recipientUsername and the privileges on the
  /// * existing notebook are lower, than on this one, this will update the
  /// * privileges and sharerUserId. If there isn't an existing SharedNotebook for
  /// * recipientUsername, this will create and return a shared notebook for that
  /// * email and recipientUsername. If recipientUsername is not set and there
  /// * already is a SharedNotebook for a Notebook for that email address and the
  /// * privileges on the existing SharedNotebook are lower than on this one, this
  /// * will update the privileges and sharerUserId, and return the updated
  /// * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
  /// * the email address.
  /// *
  /// * If the authenticationToken is a Business auth token, recipientUsername is
  /// * set and the recipient is in the same business as the business auth token,
  /// * this method will also auto-join the business user to the SharedNotebook -
  /// * that is it will set serviceJoined on the SharedNotebook and create a
  /// * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
  /// * The LinkedNotebook creation happens out-of-band, so there will be a delay
  /// * on the order of half a minute between the SharedNotebook and LinkedNotebook
  /// * creation.
  /// *
  /// * Also handles sending an email to the email addresses: if a SharedNotebook
  /// * is being created, this will send the shared notebook invite email, and
  /// * if a SharedNotebook already exists, it will send the shared notebook
  /// * reminder email. Both these emails contain a link to join the notebook.
  /// * If the notebook is being auto-joined, it sends an email with that
  /// * information to the recipient.
  /// *
  /// * @param authenticationToken
  /// *   Must be an authentication token from the owner or a shared notebook
  /// *   authentication token or business authentication token with sufficient
  /// *   permissions to change invitations for a notebook.
  /// *
  /// * @param sharedNotebook
  /// *   A shared notebook object populated with the email address of the share
  /// *   recipient, the notebook guid and the access permissions. All other
  /// *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
  /// *   field must be explicitly set with either a true or false value.
  /// *
  /// * @param message
  /// *   The sharer-defined message to put in the email sent out.
  /// *
  /// * @return
  /// *   The fully populated SharedNotebook object including the server assigned
  /// *   globalId which can both be used to uniquely identify the SharedNotebook.
  /// *
  /// * @throws EDAMUserException <ul>
  /// *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
  /// *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
  /// *       SharedNotebook.privilegeLevel was not set.</li>
  /// *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
  /// *       set. requireLogin is deprecated.</li>
  /// *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
  /// *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
  /// *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
  ///         owner's account is not confirmed.</li>
  /// *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
  /// *       recipientSettings is set in the sharedNotebook.  Only the recipient
  /// *       can set these values via the setSharedNotebookRecipientSettings
  /// *       method.</li>
  /// *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
  /// *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
  /// *   </ul>
  /// * @throws EDAMNotFoundException <ul>
  /// *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
  /// *   </li>
  /// *   </ul>
  fn share_notebook(&mut self, authentication_token: String, shared_notebook: types::SharedNotebook, message: String) -> thrift::Result<types::SharedNotebook>;
  /// Share a notebook by a messaging thread ID or a list of contacts. This function is
  /// intended to be used in conjunction with Evernote messaging, and as such does not
  /// notify the recipient that a notebook has been shared with them.
  /// 
  /// Sharing with a subset of participants on a thread is accomplished by specifying both
  /// a thread ID and a list of contacts. This ensures that even if those contacts are
  /// on the thread under a deactivated identity, the correct user (the one who has the
  /// given contact on the thread) receives the share.
  /// 
  /// @param authenticationToken
  ///   An authentication token that grants the caller permission to share the notebook.
  ///   This should be an owner token if the notebook is owned by the caller.
  ///   If the notebook is a business notebook to which the caller has full access,
  ///   this should be their business authentication token. If the notebook is a shared
  ///   (non-business) notebook to which the caller has full access, this should be the
  ///   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
  /// 
  /// @param shareTemplate
  ///   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
  ///   should be shared, and the recipient information.
  /// 
  /// @return
  ///   A structure containing the USN of the Notebook after the change and a list of created
  ///   or updated SharedNotebooks.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
  ///   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
  ///     valid GUID</li>
  ///   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
  ///   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
  ///     specified</li>
  ///   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
  ///     is not allowed.</li>
  ///   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
  ///     specified, either by thread ID or as a list of contacts</li>
  ///   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
  ///     number of shares</li>
  /// </ul>
  /// 
  /// @throws EDAMInvalidContactsException <ul>
  ///   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
  ///     in shareTemplate.recipients was not syntactically valid, or if attempting to
  ///     share a notebook with an Evernote identity that the sharer does not have a
  ///     connection to. The exception will specify which recipients were invalid.</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
  ///   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
  ///     specified, but no thread with that ID exists</li>
  /// </ul>
  fn create_or_update_notebook_shares(&mut self, authentication_token: String, share_template: NotebookShareTemplate) -> thrift::Result<CreateOrUpdateNotebookSharesResult>;
  /// @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
  fn update_shared_notebook(&mut self, authentication_token: String, shared_notebook: types::SharedNotebook) -> thrift::Result<i32>;
  /// Set values for the recipient settings associated with a notebook share. Only the
  /// recipient of the share can update their recipient settings.
  /// 
  /// If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
  /// you must leave that field unset in recipientSettings.
  /// This method will skip that field for updates and attempt to leave the existing value as
  /// it is.
  /// 
  /// If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
  /// will be either left as null or converted to false (if currently true).
  /// 
  /// To unset a notebook's stack, pass in the empty string for the stack field.
  /// 
  /// @param authenticationToken The owner authentication token for the recipient of the share.
  /// 
  /// @return The updated Notebook with the new recipient settings. Note that some of the
  /// recipient settings may differ from what was requested. Clients should update their state
  /// based on this return value.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
  ///       notebookGuid on the given shard.</li>
  ///   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
  ///       user and is also not published to their business.</li>
  /// </ul>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
  ///       allowed to set recipient settings on the specified notebook.</li>
  ///   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
  ///       is allowed only for notebooks which belong to the same business as the user.</li>
  ///   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
  ///       to false and any of reminder* settings to true.</li>
  /// </ul>
  fn set_notebook_recipient_settings(&mut self, authentication_token: String, notebook_guid: String, recipient_settings: types::NotebookRecipientSettings) -> thrift::Result<types::Notebook>;
  /// Lists the collection of shared notebooks for all notebooks in the
  /// users account.
  /// 
  /// @return
  ///  The list of all SharedNotebooks for the user
  fn list_shared_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::SharedNotebook>>;
  /// Asks the service to make a linked notebook with the provided name, username
  /// of the owner and identifiers provided. A linked notebook can be either a
  /// link to a public notebook or to a private shared notebook.
  /// 
  /// @param linkedNotebook
  ///   The desired fields for the linked notebook must be provided on this
  ///   object.  The name of the linked notebook must be set. Either a username
  ///   uri or a shard id and share key must be provided otherwise a
  ///   EDAMUserException is thrown.
  /// 
  /// @return
  ///   The newly created LinkedNotebook.  The server-side id will be
  ///   saved in this object's 'id' field.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
  ///     if public notebook set but bad uri
  ///   </li>
  ///   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
  ///     if private notebook but shard id not provided
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
  ///     if a bad global identifer was set on a private notebook
  ///   </li>
  /// </ul>
  fn create_linked_notebook(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<types::LinkedNotebook>;
  /// @param linkedNotebook
  ///   Updates the name of a linked notebook.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
  ///   </li>
  /// </ul>
  fn update_linked_notebook(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<i32>;
  /// Returns a list of linked notebooks
  fn list_linked_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::LinkedNotebook>>;
  /// Permanently expunges the linked notebook from the account.
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
  ///   from the account.
  fn expunge_linked_notebook(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Asks the service to produce an authentication token that can be used to
  /// access the contents of a shared notebook from someone else's account.
  /// This authenticationToken can be used with the various other NoteStore
  /// calls to find and retrieve notes, and if the permissions in the shared
  /// notebook are sufficient, to make changes to the contents of the notebook.
  /// 
  /// @param shareKeyOrGlobalId
  ///   May be one of the following:
  ///   <ul>
  ///     <li>A share key for a shared notebook that was granted to some recipient
  ///         Must be used if you are joining a notebook unless it was shared via
  ///         createOrUpdateNotebookShares. Share keys are delivered out-of-band
  ///         and are generally not available to clients. For security reasons,
  ///         share keys may be invalidated at the discretion of the service.
  ///     </li>
  ///     <li>The shared notebook global identifier. May be used to access a
  ///         notebook that is already joined.
  ///     </li>
  ///     <li>The Notebook GUID. May be used to access a notebook that was already
  ///         joined, or to access a notebook that was shared with the recipient
  ///         via createOrUpdateNotebookShares.
  ///     </li>
  ///   </ul>
  /// 
  /// @param authenticationToken
  ///   If a non-empty string is provided, this is the full user-based
  ///   authentication token that identifies the user who is currently logged in
  ///   and trying to access the shared notebook.
  ///   If this string is empty, the service will attempt to authenticate to the
  ///   shared notebook without any logged in user.
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
  ///   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
  /// </ul>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
  ///          no valid authentication token was provided.
  ///   </li>
  ///   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
  ///          and another username has already been bound to this notebook.
  ///   </li>
  /// </ul>
  fn authenticate_to_shared_notebook(&mut self, share_key_or_global_id: String, authentication_token: String) -> thrift::Result<user_store::AuthenticationResult>;
  /// This function is used to retrieve extended information about a shared
  /// notebook by a guest who has already authenticated to access that notebook.
  /// This requires an 'authenticationToken' parameter which should be the
  /// resut of a call to authenticateToSharedNotebook(...).
  /// I.e. this is the token that gives access to the particular shared notebook
  /// in someone else's account -- it's not the authenticationToken for the
  /// owner of the notebook itself.
  /// 
  /// @param authenticationToken
  ///   Should be the authentication token retrieved from the reply of
  ///   authenticateToSharedNotebook(), proving access to a particular shared
  ///   notebook.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "authenticationToken" -
  ///          authentication token doesn't correspond to a valid shared notebook
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SharedNotebook.id" - the shared notebook no longer exists
  ///   </li>
  /// </ul>
  fn get_shared_notebook_by_auth(&mut self, authentication_token: String) -> thrift::Result<types::SharedNotebook>;
  /// Attempts to send a single note to one or more email recipients.
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param authenticationToken
  ///    The note will be sent as the user logged in via this token, using that
  ///    user's registered email address.  If the authenticated user doesn't
  ///    have permission to read that note, the emailing will fail.
  /// 
  /// @param parameters
  ///    The note must be specified either by GUID (in which case it will be
  ///    sent using the existing data in the service), or else the full Note
  ///    must be passed to this call.  This also specifies the additional
  ///    email fields that will be used in the email.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
  ///     The email can't be sent because this would exceed the user's daily
  ///     email limit.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "(email address)" -
  ///     email address malformed
  ///   </li>
  ///   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
  ///     if there are no To: or Cc: addresses provided.
  ///   </li>
  ///   <li> DATA_REQUIRED "Note.title" -
  ///     if the caller provides a Note parameter with no title
  ///   </li>
  ///   <li> DATA_REQUIRED "Note.content" -
  ///     if the caller provides a Note parameter with no content
  ///   </li>
  ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  ///   </li>
  ///   <li> DATA_REQUIRED "NoteEmailParameters.note" -
  ///     if no guid or note provided
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn email_note(&mut self, authentication_token: String, parameters: NoteEmailParameters) -> thrift::Result<()>;
  /// If this note is not already shared publicly (via its own direct URL), then this
  /// will start sharing that note.
  /// This will return the secret "Note Key" for this note that
  /// can currently be used in conjunction with the Note's GUID to gain direct
  /// read-only access to the Note.
  /// If the note is already shared, then this won't make any changes to the
  /// note, and the existing "Note Key" will be returned.  The only way to change
  /// the Note Key for an existing note is to stopSharingNote first, and then
  /// call this function.
  /// 
  /// @param guid
  ///   The GUID of the note to be shared.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID</li>
  /// </ul>
  fn share_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<String>;
  /// If this note is shared publicly then this will stop sharing that note
  /// and invalidate its "Note Key", so any existing URLs to access that Note
  /// will stop working.
  /// 
  /// If the Note is not shared, then this function will do nothing.
  /// 
  /// This function does not remove invididual shares for the note. To remove
  /// individual shares, see stopSharingNoteWithRecipients.
  /// 
  /// @param guid
  ///   The GUID of the note to be un-shared.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"Note.guid" - not found, by GUID</li>
  /// </ul>
  fn stop_sharing_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<()>;
  /// Asks the service to produce an authentication token that can be used to
  /// access the contents of a single Note which was individually shared
  /// from someone's account.
  /// This authenticationToken can be used with the various other NoteStore
  /// calls to find and retrieve the Note and its directly-referenced children.
  /// 
  /// @param guid
  ///   The GUID identifying this Note on this shard.
  /// 
  /// @param noteKey
  ///   The 'noteKey' identifier from the Note that was originally created via
  ///   a call to shareNote() and then given to a recipient to access.
  /// 
  /// @param authenticationToken
  ///   An optional authenticationToken that identifies the user accessing the
  ///   shared note. This parameter may be required to access some shared notes.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
  ///     shared, or the noteKey doesn't match the current key for this note
  ///   </li>
  ///   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
  ///     required to access this Note, but either no authentication token or a
  ///     "non-owner" authentication token was provided.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "guid" - the note with that GUID is not found
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
  ///     all requesters).
  ///   </li>
  ///   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
  ///     for the requester because of an IP-based country lookup.
  ///   </ul>
  /// </ul>
  fn authenticate_to_shared_note(&mut self, guid: String, note_key: String, authentication_token: String) -> thrift::Result<user_store::AuthenticationResult>;
  /// Identify related entities on the service, such as notes,
  /// notebooks, tags and users in a business related to notes or content.
  /// 
  /// @param query
  ///   The information about which we are finding related entities.
  /// 
  /// @param resultSpec
  ///   Allows the client to indicate the type and quantity of
  ///   information to be returned, allowing a saving of time and
  ///   bandwidth.
  /// 
  /// @return
  ///   The result of the query, with information considered
  ///   to likely be relevantly related to the information
  ///   described by the query.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
  ///     a zero-length plain text value.
  ///   </li>
  ///   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
  ///     invalid Note GUID, that is, one that does not match the constraints
  ///     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  ///   </li>
  ///   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
  ///     the note identified by RelatedQuery.noteGuid.
  ///   </li>
  ///   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
  ///     findExperts in the context of a non business user (i.e. The authenticationToken
  ///     is not a business auth token).
  ///   </li>
  ///   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
  ///     in the result spec.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
  ///     found, if that field has been set in the query.
  ///   </li>
  /// </ul>
  fn find_related(&mut self, authentication_token: String, query: RelatedQuery, result_spec: RelatedResultSpec) -> thrift::Result<RelatedResult>;
  /// Perform the same operation as updateNote() would provided that the update
  /// sequence number on the parameter Note object matches the current update sequence
  /// number that the service has for the note.  If they do <i>not</i> match, then
  /// <i>no</i> update is performed and the return value will have the current server
  /// state in the note field and updated will be false.  If the update sequence
  /// numbers between the client and server do match, then the note will be updated
  /// and the note field of the return value will be returned as it would be for the
  /// updateNote method.  This method allows you to check for an update to the note
  /// on the service, by another client instance, from when you obtained the
  /// note state as a baseline for your edits and the time when you wish to save your
  /// edits.  If your client can merge the conflict, you can avoid overwriting changes
  /// that were saved to the service by the other client.
  /// 
  /// See the updateNote method for information on the exceptions and parameters for
  /// this method.  The only difference is that you must have an update sequence number
  /// defined on the note parameter (equal to the USN of the note as synched to the
  /// client), and the following additional exceptions might be thrown.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
  ///       not provided.  This includes a value that is set as 0.</li>
  ///   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
  ///       sequence number that is larger than the current server value, which should
  ///       not happen if your client is working correctly.</li>
  /// </ul>
  fn update_note_if_usn_matches(&mut self, authentication_token: String, note: types::Note) -> thrift::Result<UpdateNoteIfUsnMatchesResult>;
  /// Manage invitations and memberships associated with a given notebook.
  /// 
  /// <i>Note:</i> Beta method! This method is currently intended for
  /// limited use by Evernote clients that have discussed using this
  /// routine with the platform team.
  /// 
  /// @param parameters A structure containing all parameters for the updates.
  ///    See the structure documentation for details.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
  ///    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
  ///    shares.</li>
  /// </ul>
  fn manage_notebook_shares(&mut self, authentication_token: String, parameters: ManageNotebookSharesParameters) -> thrift::Result<ManageNotebookSharesResult>;
  /// Return the share relationships for the given notebook, including
  /// both the invitations and the memberships.
  /// 
  /// <i>Note:</i> Beta method! This method is currently intended for
  /// limited use by Evernote clients that have discussed using this
  /// routine with the platform team.
  fn get_notebook_shares(&mut self, authentication_token: String, notebook_guid: String) -> thrift::Result<ShareRelationships>;
}

pub trait TNoteStoreSyncClientMarker {}

pub struct NoteStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> NoteStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> NoteStoreSyncClient<IP, OP> {
    NoteStoreSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for NoteStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TNoteStoreSyncClientMarker for NoteStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TNoteStoreSyncClientMarker> TNoteStoreSyncClient for C {
  fn get_sync_state(&mut self, authentication_token: String) -> thrift::Result<SyncState> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSyncState", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetSyncStateArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSyncState", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetSyncStateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_filtered_sync_chunk(&mut self, authentication_token: String, after_u_s_n: i32, max_entries: i32, filter: SyncChunkFilter) -> thrift::Result<SyncChunk> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getFilteredSyncChunk", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetFilteredSyncChunkArgs { authentication_token, after_u_s_n, max_entries, filter };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getFilteredSyncChunk", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetFilteredSyncChunkResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_linked_notebook_sync_state(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<SyncState> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetLinkedNotebookSyncStateArgs { authentication_token, linked_notebook };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getLinkedNotebookSyncState", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetLinkedNotebookSyncStateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_linked_notebook_sync_chunk(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook, after_u_s_n: i32, max_entries: i32, full_sync_only: bool) -> thrift::Result<SyncChunk> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetLinkedNotebookSyncChunkArgs { authentication_token, linked_notebook, after_u_s_n, max_entries, full_sync_only };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getLinkedNotebookSyncChunk", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetLinkedNotebookSyncChunkResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::Notebook>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listNotebooks", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListNotebooksArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listNotebooks", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListNotebooksResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_accessible_business_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::Notebook>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listAccessibleBusinessNotebooks", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListAccessibleBusinessNotebooksArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listAccessibleBusinessNotebooks", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListAccessibleBusinessNotebooksResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_notebook(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::Notebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNotebookArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_default_notebook(&mut self, authentication_token: String) -> thrift::Result<types::Notebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getDefaultNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetDefaultNotebookArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getDefaultNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetDefaultNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_notebook(&mut self, authentication_token: String, notebook: types::Notebook) -> thrift::Result<types::Notebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreCreateNotebookArgs { authentication_token, notebook };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreCreateNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_notebook(&mut self, authentication_token: String, notebook: types::Notebook) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateNotebookArgs { authentication_token, notebook };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn expunge_notebook(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreExpungeNotebookArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("expungeNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreExpungeNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_tags(&mut self, authentication_token: String) -> thrift::Result<Vec<types::Tag>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listTags", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListTagsArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listTags", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListTagsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_tags_by_notebook(&mut self, authentication_token: String, notebook_guid: types::Guid) -> thrift::Result<Vec<types::Tag>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListTagsByNotebookArgs { authentication_token, notebook_guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listTagsByNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListTagsByNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tag(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::Tag> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getTag", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetTagArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getTag", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetTagResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_tag(&mut self, authentication_token: String, tag: types::Tag) -> thrift::Result<types::Tag> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createTag", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreCreateTagArgs { authentication_token, tag };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createTag", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreCreateTagResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_tag(&mut self, authentication_token: String, tag: types::Tag) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateTagArgs { authentication_token, tag };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateTag", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateTagResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn untag_all(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUntagAllArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("untagAll", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUntagAllResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn expunge_tag(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreExpungeTagArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("expungeTag", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreExpungeTagResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_searches(&mut self, authentication_token: String) -> thrift::Result<Vec<types::SavedSearch>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listSearches", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListSearchesArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listSearches", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListSearchesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_search(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::SavedSearch> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetSearchArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSearch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetSearchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_search(&mut self, authentication_token: String, search: types::SavedSearch) -> thrift::Result<types::SavedSearch> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createSearch", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreCreateSearchArgs { authentication_token, search };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createSearch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreCreateSearchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_search(&mut self, authentication_token: String, search: types::SavedSearch) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateSearchArgs { authentication_token, search };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateSearch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateSearchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn expunge_search(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreExpungeSearchArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("expungeSearch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreExpungeSearchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_note_offset(&mut self, authentication_token: String, filter: NoteFilter, guid: types::Guid) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreFindNoteOffsetArgs { authentication_token, filter, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findNoteOffset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreFindNoteOffsetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_notes_metadata(&mut self, authentication_token: String, filter: NoteFilter, offset: i32, max_notes: i32, result_spec: NotesMetadataResultSpec) -> thrift::Result<NotesMetadataList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreFindNotesMetadataArgs { authentication_token, filter, offset, max_notes, result_spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findNotesMetadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreFindNotesMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_note_counts(&mut self, authentication_token: String, filter: NoteFilter, with_trash: bool) -> thrift::Result<NoteCollectionCounts> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreFindNoteCountsArgs { authentication_token, filter, with_trash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findNoteCounts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreFindNoteCountsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note_with_result_spec(&mut self, authentication_token: String, guid: types::Guid, result_spec: NoteResultSpec) -> thrift::Result<types::Note> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteWithResultSpecArgs { authentication_token, guid, result_spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNoteWithResultSpec", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteWithResultSpecResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note(&mut self, authentication_token: String, guid: types::Guid, with_content: bool, with_resources_data: bool, with_resources_recognition: bool, with_resources_alternate_data: bool) -> thrift::Result<types::Note> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteArgs { authentication_token, guid, with_content, with_resources_data, with_resources_recognition, with_resources_alternate_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note_application_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::LazyMap> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteApplicationDataArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNoteApplicationData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteApplicationDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteApplicationDataEntryArgs { authentication_token, guid, key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNoteApplicationDataEntry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteApplicationDataEntryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_note_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String, value: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreSetNoteApplicationDataEntryArgs { authentication_token, guid, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setNoteApplicationDataEntry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreSetNoteApplicationDataEntryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unset_note_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUnsetNoteApplicationDataEntryArgs { authentication_token, guid, key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unsetNoteApplicationDataEntry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUnsetNoteApplicationDataEntryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note_content(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteContentArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNoteContent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteContentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note_search_text(&mut self, authentication_token: String, guid: types::Guid, note_only: bool, tokenize_for_indexing: bool) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteSearchTextArgs { authentication_token, guid, note_only, tokenize_for_indexing };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNoteSearchText", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteSearchTextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_search_text(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceSearchTextArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceSearchText", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceSearchTextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note_tag_names(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteTagNamesArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNoteTagNames", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteTagNamesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_note(&mut self, authentication_token: String, note: types::Note) -> thrift::Result<types::Note> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreCreateNoteArgs { authentication_token, note };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreCreateNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_note(&mut self, authentication_token: String, note: types::Note) -> thrift::Result<types::Note> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateNoteArgs { authentication_token, note };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreDeleteNoteArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deleteNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreDeleteNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn expunge_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreExpungeNoteArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("expungeNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreExpungeNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn copy_note(&mut self, authentication_token: String, note_guid: types::Guid, to_notebook_guid: types::Guid) -> thrift::Result<types::Note> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreCopyNoteArgs { authentication_token, note_guid, to_notebook_guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("copyNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreCopyNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_note_versions(&mut self, authentication_token: String, note_guid: types::Guid) -> thrift::Result<Vec<NoteVersionId>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListNoteVersionsArgs { authentication_token, note_guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listNoteVersions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListNoteVersionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_note_version(&mut self, authentication_token: String, note_guid: types::Guid, update_sequence_num: i32, with_resources_data: bool, with_resources_recognition: bool, with_resources_alternate_data: bool) -> thrift::Result<types::Note> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNoteVersionArgs { authentication_token, note_guid, update_sequence_num, with_resources_data, with_resources_recognition, with_resources_alternate_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNoteVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNoteVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource(&mut self, authentication_token: String, guid: types::Guid, with_data: bool, with_recognition: bool, with_attributes: bool, with_alternate_data: bool) -> thrift::Result<types::Resource> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResource", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceArgs { authentication_token, guid, with_data, with_recognition, with_attributes, with_alternate_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResource", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_application_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::LazyMap> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceApplicationDataArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceApplicationData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceApplicationDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceApplicationDataEntryArgs { authentication_token, guid, key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceApplicationDataEntry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceApplicationDataEntryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_resource_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String, value: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreSetResourceApplicationDataEntryArgs { authentication_token, guid, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setResourceApplicationDataEntry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreSetResourceApplicationDataEntryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unset_resource_application_data_entry(&mut self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUnsetResourceApplicationDataEntryArgs { authentication_token, guid, key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unsetResourceApplicationDataEntry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUnsetResourceApplicationDataEntryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_resource(&mut self, authentication_token: String, resource: types::Resource) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateResourceArgs { authentication_token, resource };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateResource", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateResourceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceDataArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_by_hash(&mut self, authentication_token: String, note_guid: types::Guid, content_hash: Vec<u8>, with_data: bool, with_recognition: bool, with_alternate_data: bool) -> thrift::Result<types::Resource> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceByHashArgs { authentication_token, note_guid, content_hash, with_data, with_recognition, with_alternate_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceByHash", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceByHashResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_recognition(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceRecognitionArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceRecognition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceRecognitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_alternate_data(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceAlternateDataArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceAlternateData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceAlternateDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_attributes(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::ResourceAttributes> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetResourceAttributesArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getResourceAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetResourceAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_public_notebook(&mut self, user_id: types::UserID, public_uri: String) -> thrift::Result<types::Notebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPublicNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetPublicNotebookArgs { user_id, public_uri };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPublicNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetPublicNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn share_notebook(&mut self, authentication_token: String, shared_notebook: types::SharedNotebook, message: String) -> thrift::Result<types::SharedNotebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreShareNotebookArgs { authentication_token, shared_notebook, message };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("shareNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreShareNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_or_update_notebook_shares(&mut self, authentication_token: String, share_template: NotebookShareTemplate) -> thrift::Result<CreateOrUpdateNotebookSharesResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreCreateOrUpdateNotebookSharesArgs { authentication_token, share_template };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createOrUpdateNotebookShares", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreCreateOrUpdateNotebookSharesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_shared_notebook(&mut self, authentication_token: String, shared_notebook: types::SharedNotebook) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateSharedNotebookArgs { authentication_token, shared_notebook };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateSharedNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateSharedNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_notebook_recipient_settings(&mut self, authentication_token: String, notebook_guid: String, recipient_settings: types::NotebookRecipientSettings) -> thrift::Result<types::Notebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreSetNotebookRecipientSettingsArgs { authentication_token, notebook_guid, recipient_settings };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setNotebookRecipientSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreSetNotebookRecipientSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_shared_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::SharedNotebook>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListSharedNotebooksArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listSharedNotebooks", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListSharedNotebooksResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_linked_notebook(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<types::LinkedNotebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreCreateLinkedNotebookArgs { authentication_token, linked_notebook };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createLinkedNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreCreateLinkedNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_linked_notebook(&mut self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateLinkedNotebookArgs { authentication_token, linked_notebook };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateLinkedNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateLinkedNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_linked_notebooks(&mut self, authentication_token: String) -> thrift::Result<Vec<types::LinkedNotebook>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreListLinkedNotebooksArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listLinkedNotebooks", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreListLinkedNotebooksResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn expunge_linked_notebook(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreExpungeLinkedNotebookArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("expungeLinkedNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreExpungeLinkedNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authenticate_to_shared_notebook(&mut self, share_key_or_global_id: String, authentication_token: String) -> thrift::Result<user_store::AuthenticationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreAuthenticateToSharedNotebookArgs { share_key_or_global_id, authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("authenticateToSharedNotebook", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreAuthenticateToSharedNotebookResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_shared_notebook_by_auth(&mut self, authentication_token: String) -> thrift::Result<types::SharedNotebook> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetSharedNotebookByAuthArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getSharedNotebookByAuth", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetSharedNotebookByAuthResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn email_note(&mut self, authentication_token: String, parameters: NoteEmailParameters) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreEmailNoteArgs { authentication_token, parameters };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("emailNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreEmailNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn share_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreShareNoteArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("shareNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreShareNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn stop_sharing_note(&mut self, authentication_token: String, guid: types::Guid) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreStopSharingNoteArgs { authentication_token, guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("stopSharingNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreStopSharingNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authenticate_to_shared_note(&mut self, guid: String, note_key: String, authentication_token: String) -> thrift::Result<user_store::AuthenticationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreAuthenticateToSharedNoteArgs { guid, note_key, authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("authenticateToSharedNote", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreAuthenticateToSharedNoteResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn find_related(&mut self, authentication_token: String, query: RelatedQuery, result_spec: RelatedResultSpec) -> thrift::Result<RelatedResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreFindRelatedArgs { authentication_token, query, result_spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("findRelated", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreFindRelatedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_note_if_usn_matches(&mut self, authentication_token: String, note: types::Note) -> thrift::Result<UpdateNoteIfUsnMatchesResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreUpdateNoteIfUsnMatchesArgs { authentication_token, note };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateNoteIfUsnMatches", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreUpdateNoteIfUsnMatchesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn manage_notebook_shares(&mut self, authentication_token: String, parameters: ManageNotebookSharesParameters) -> thrift::Result<ManageNotebookSharesResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreManageNotebookSharesArgs { authentication_token, parameters };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("manageNotebookShares", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreManageNotebookSharesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_notebook_shares(&mut self, authentication_token: String, notebook_guid: String) -> thrift::Result<ShareRelationships> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Call, self.sequence_number());
        let call_args = NoteStoreGetNotebookSharesArgs { authentication_token, notebook_guid };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getNotebookShares", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = NoteStoreGetNotebookSharesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// NoteStore service processor
//

/// Service:  NoteStore
/// <p>
/// The NoteStore service is used by EDAM clients to exchange information
/// about the collection of notes in an account. This is primarily used for
/// synchronization, but could also be used by a "thin" client without a full
/// local cache.
/// </p><p>
/// Most functions take an "authenticationToken" parameter, which is the
/// value returned by the UserStore which permits access to the account.
/// </p>
/// 
/// Calls which require an authenticationToken may throw an EDAMUserException
/// for the following reasons:
///  <ul>
///   <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
///   <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
///   <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
///   <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
///   <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
///       to perform the requested action</li>
///   <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
///       that requires single sign-on, and must complete SSO before accessing business
///       content.
/// </ul>
pub trait NoteStoreSyncHandler {
  /// Asks the NoteStore to provide information about the status of the user
  /// account corresponding to the provided authentication token.
  fn handle_get_sync_state(&self, authentication_token: String) -> thrift::Result<SyncState>;
  /// Asks the NoteStore to provide the state of the account in order of
  /// last modification.  This request retrieves one block of the server's
  /// state so that a client can make several small requests against a large
  /// account rather than getting the entire state in one big message.
  /// This call gives fine-grained control of the data that will
  /// be received by a client by omitting data elements that a client doesn't
  /// need. This may reduce network traffic and sync times.
  /// 
  /// @param afterUSN
  ///   The client can pass this value to ask only for objects that
  ///   have been updated after a certain point.  This allows the client to
  ///   receive updates after its last checkpoint rather than doing a full
  ///   synchronization on every pass.  The default value of "0" indicates
  ///   that the client wants to get objects from the start of the account.
  /// 
  /// @param maxEntries
  ///   The maximum number of modified objects that should be
  ///   returned in the result SyncChunk.  This can be used to limit the size
  ///   of each individual message to be friendly for network transfer.
  /// 
  /// @param filter
  ///   The caller must set some of the flags in this structure to specify which
  ///   data types should be returned during the synchronization.  See
  ///   the SyncChunkFilter structure for information on each flag.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
  ///   </li>
  /// </ul>
  fn handle_get_filtered_sync_chunk(&self, authentication_token: String, after_u_s_n: i32, max_entries: i32, filter: SyncChunkFilter) -> thrift::Result<SyncChunk>;
  /// Asks the NoteStore to provide information about the status of a linked
  /// notebook that has been shared with the caller, or that is public to the
  /// world.
  /// This will return a result that is similar to getSyncState, but may omit
  /// SyncState.uploaded if the caller doesn't have permission to write to
  /// the linked notebook.
  /// 
  /// This function must be called on the shard that owns the referenced
  /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
  /// same as LinkedNotebook.shardId.)
  /// 
  /// @param authenticationToken
  ///   This should be an authenticationToken for the guest who has received
  ///   the invitation to the share.  (I.e. this should not be the result of
  ///   NoteStore.authenticateToSharedNotebook)
  /// 
  /// @param linkedNotebook
  ///   This structure should contain identifying information and permissions
  ///   to access the notebook in question.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
  ///       populated with the current username of the owner of the notebook for which
  ///       you are obtaining sync state.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
  ///       correspond to a current user on the service.
  ///   </li>
  /// </ul>
  /// 
  /// @throws SystemException <ul>
  ///   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
  ///       user whose account is on a shard other than that on which this method was
  ///       invoked.
  ///   </li>
  /// </ul>
  fn handle_get_linked_notebook_sync_state(&self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<SyncState>;
  /// Asks the NoteStore to provide information about the contents of a linked
  /// notebook that has been shared with the caller, or that is public to the
  /// world.
  /// This will return a result that is similar to getSyncChunk, but will only
  /// contain entries that are visible to the caller.  I.e. only that particular
  /// Notebook will be visible, along with its Notes, and Tags on those Notes.
  /// 
  /// This function must be called on the shard that owns the referenced
  /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
  /// same as LinkedNotebook.shardId.)
  /// 
  /// @param authenticationToken
  ///   This should be an authenticationToken for the guest who has received
  ///   the invitation to the share.  (I.e. this should not be the result of
  ///   NoteStore.authenticateToSharedNotebook)
  /// 
  /// @param linkedNotebook
  ///   This structure should contain identifying information and permissions
  ///   to access the notebook in question.  This must contain the valid fields
  ///   for either a shared notebook (e.g. shareKey)
  ///   or a public notebook (e.g. username, uri)
  /// 
  /// @param afterUSN
  ///   The client can pass this value to ask only for objects that
  ///   have been updated after a certain point.  This allows the client to
  ///   receive updates after its last checkpoint rather than doing a full
  ///   synchronization on every pass.  The default value of "0" indicates
  ///   that the client wants to get objects from the start of the account.
  /// 
  /// @param maxEntries
  ///   The maximum number of modified objects that should be
  ///   returned in the result SyncChunk.  This can be used to limit the size
  ///   of each individual message to be friendly for network transfer.
  ///   Applications should not request more than 256 objects at a time,
  ///   and must handle the case where the service returns less than the
  ///   requested number of objects in a given request even though more
  ///   objects are available on the service.
  /// 
  /// @param fullSyncOnly
  ///   If true, then the client only wants initial data for a full sync.
  ///   In this case, the service will not return any expunged objects,
  ///   and will not return any Resources, since these are also provided
  ///   in their corresponding Notes.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "LinkedNotebook" - if the provided information doesn't match any
  ///     valid notebook
  ///   </li>
  ///   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
  ///     valid notebook
  ///   </li>
  ///   <li> "SharedNotebook.id" - if the provided information indicates a
  ///      shared notebook that no longer exists
  ///   </li>
  /// </ul>
  fn handle_get_linked_notebook_sync_chunk(&self, authentication_token: String, linked_notebook: types::LinkedNotebook, after_u_s_n: i32, max_entries: i32, full_sync_only: bool) -> thrift::Result<SyncChunk>;
  /// Returns a list of all of the notebooks in the account.
  fn handle_list_notebooks(&self, authentication_token: String) -> thrift::Result<Vec<types::Notebook>>;
  /// Returns a list of all the notebooks in a business that the user has permission to access,
  /// regardless of whether the user has joined them. This includes notebooks that have been shared
  /// with the entire business as well as notebooks that have been shared directly with the user.
  /// 
  /// @param authenticationToken A business authentication token obtained by calling
  ///   UserStore.authenticateToBusiness.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
  ///     business auth token.</li>
  /// </ul>
  fn handle_list_accessible_business_notebooks(&self, authentication_token: String) -> thrift::Result<Vec<types::Notebook>>;
  /// Returns the current state of the notebook with the provided GUID.
  /// The notebook may be active or deleted (but not expunged).
  /// 
  /// @param guid
  ///   The GUID of the notebook to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_notebook(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::Notebook>;
  /// Returns the notebook that should be used to store new notes in the
  /// user's account when no other notebooks are specified.
  fn handle_get_default_notebook(&self, authentication_token: String) -> thrift::Result<types::Notebook>;
  /// Asks the service to make a notebook with the provided name.
  /// 
  /// @param notebook
  ///   The desired fields for the notebook must be provided on this
  ///   object.  The name of the notebook must be set, and either the 'active'
  ///   or 'defaultNotebook' fields may be set by the client at creation.
  ///   If a notebook exists in the account with the same name (via
  ///   case-insensitive compare), this will throw an EDAMUserException.
  /// 
  /// @return
  ///   The newly created Notebook.  The server-side GUID will be
  ///   saved in this object's 'guid' field.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
  ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
  ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
  ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
  ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
  ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
  ///        is set to 'true' for a Notebook that is not owned by the user identified by
  ///        the passed authenticationToken.</li>
  ///   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Workspace.guid" - if workspaceGuid set and no Workspace exists for the GUID
  ///   </li>
  /// </ul>
  fn handle_create_notebook(&self, authentication_token: String, notebook: types::Notebook) -> thrift::Result<types::Notebook>;
  /// Submits notebook changes to the service. The provided data must include the
  /// notebook's guid field for identification.
  /// <p />
  /// The Notebook will be moved to the specified Workspace, if a non empty
  /// Notebook.workspaceGuid is provided. If an empty Notebook.workspaceGuid is set and the
  /// Notebook is in a Workspace, then it will be removed from the Workspace and a full
  /// access SharedNotebook record will be ensured for the caller. If the caller does not
  /// already have a full access share, either the privilege of an existing share will be
  /// upgraded or a new share will be created. It is illegal to set a
  /// Notebook.workspaceGuid on a Workspace backing Notebook.
  /// 
  /// @param notebook
  ///   The notebook object containing the requested changes.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
  ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
  ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
  ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
  ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
  ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
  ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
  ///        is set to 'true' for a Notebook that is not owned by the user identified by
  ///        the passed authenticationToken.</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID</li>
  ///   <li> "Workspace.guid" - if a non empty workspaceGuid set and no Workspace exists
  ///        for the GUID
  ///   </li>
  /// </ul>
  fn handle_update_notebook(&self, authentication_token: String, notebook: types::Notebook) -> thrift::Result<i32>;
  /// Permanently removes the notebook from the user's account.
  /// After this action, the notebook is no longer available for undeletion, etc.
  /// If the notebook contains any Notes, they will be moved to the current
  /// default notebook and moved into the trash (i.e. Note.active=false).
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the notebook to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
  ///   </li>
  ///   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
  ///   </li>
  ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
  ///   </li>
  /// </ul>
  fn handle_expunge_notebook(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Returns a list of the tags in the account.  Evernote does not support
  /// the undeletion of tags, so this will only include active tags.
  fn handle_list_tags(&self, authentication_token: String) -> thrift::Result<Vec<types::Tag>>;
  /// Returns a list of the tags that are applied to at least one note within
  /// the provided notebook.  If the notebook is public, the authenticationToken
  /// may be ignored.
  /// 
  /// @param notebookGuid
  ///    the GUID of the notebook to use to find tags
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - notebook not found by GUID
  ///   </li>
  /// </ul>
  fn handle_list_tags_by_notebook(&self, authentication_token: String, notebook_guid: types::Guid) -> thrift::Result<Vec<types::Tag>>;
  /// Returns the current state of the Tag with the provided GUID.
  /// 
  /// @param guid
  ///   The GUID of the tag to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_tag(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::Tag>;
  /// Asks the service to make a tag with a set of information.
  /// 
  /// @param tag
  ///   The desired list of fields for the tag are specified in this
  ///   object.  The caller must specify the tag name, and may provide
  ///   the parentGUID.
  /// 
  /// @return
  ///   The newly created Tag.  The server-side GUID will be
  ///   saved in this object.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
  ///   </li>
  ///   <li> DATA_CONFLICT "Tag.name" - name already in use
  ///   </li>
  ///   <li> LIMIT_REACHED "Tag" - at max number of tags
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.parentGuid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_create_tag(&self, authentication_token: String, tag: types::Tag) -> thrift::Result<types::Tag>;
  /// Submits tag changes to the service.  The provided data must include
  /// the tag's guid field for identification.  The service will apply
  /// updates to the following tag fields:  name, parentGuid
  /// 
  /// @param tag
  ///   The tag object containing the requested changes.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
  ///   </li>
  ///   <li> DATA_CONFLICT "Tag.name" - name already in use
  ///   </li>
  ///   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  ///   <li> "Tag.parentGuid" - parent not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_update_tag(&self, authentication_token: String, tag: types::Tag) -> thrift::Result<i32>;
  /// Removes the provided tag from every note that is currently tagged with
  /// this tag.  If this operation is successful, the tag will still be in
  /// the account, but it will not be tagged on any notes.
  /// 
  /// This function is not indended for use by full synchronizing clients, since
  /// it does not provide enough result information to the client to reconcile
  /// the local state without performing a follow-up sync from the service.  This
  /// is intended for "thin clients" that need to efficiently support this as
  /// a UI operation.
  /// 
  /// @param guid
  ///   The GUID of the tag to remove from all notes.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_untag_all(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<()>;
  /// Permanently deletes the tag with the provided GUID, if present.
  /// <p/>
  /// NOTE: This function is not generally available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the tag to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Tag.guid" - tag not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_expunge_tag(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Returns a list of the searches in the account.  Evernote does not support
  /// the undeletion of searches, so this will only include active searches.
  fn handle_list_searches(&self, authentication_token: String) -> thrift::Result<Vec<types::SavedSearch>>;
  /// Returns the current state of the search with the provided GUID.
  /// 
  /// @param guid
  ///   The GUID of the search to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
  ///   </li>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SavedSearch.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_search(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::SavedSearch>;
  /// Asks the service to make a saved search with a set of information.
  /// 
  /// @param search
  ///   The desired list of fields for the search are specified in this
  ///   object. The caller must specify the name and query for the
  ///   search, and may optionally specify a search scope.
  ///   The SavedSearch.format field is ignored by the service.
  /// 
  /// @return
  ///   The newly created SavedSearch.  The server-side GUID will be
  ///   saved in this object.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
  ///   </li>
  ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
  ///   </li>
  ///   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
  ///   </li>
  /// </ul>
  fn handle_create_search(&self, authentication_token: String, search: types::SavedSearch) -> thrift::Result<types::SavedSearch>;
  /// Submits search changes to the service. The provided data must include
  /// the search's guid field for identification. The service will apply
  /// updates to the following search fields: name, query, and scope.
  /// 
  /// @param search
  ///   The search object containing the requested changes.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
  ///   </li>
  ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
  ///   </li>
  ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SavedSearch.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_update_search(&self, authentication_token: String, search: types::SavedSearch) -> thrift::Result<i32>;
  /// Permanently deletes the saved search with the provided GUID, if present.
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the search to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
  ///   </li>
  ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SavedSearch.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_expunge_search(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Finds the position of a note within a sorted subset of all of the user's
  /// notes. This may be useful for thin clients that are displaying a paginated
  /// listing of a large account, which need to know where a particular note
  /// sits in the list without retrieving all notes first.
  /// 
  /// @param authenticationToken
  ///   Must be a valid token for the user's account unless the NoteFilter
  ///   'notebookGuid' is the GUID of a public notebook.
  /// 
  /// @param filter
  ///   The list of criteria that will constrain the notes to be returned.
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @return
  ///   If the note with the provided GUID is found within the matching note
  ///   list, this will return the offset of that note within that list (where
  ///   the first offset is 0).  If the note is not found within the set of
  ///   notes, this will return -1.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  ///   </li>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID
  ///   </li>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_find_note_offset(&self, authentication_token: String, filter: NoteFilter, guid: types::Guid) -> thrift::Result<i32>;
  /// Used to find the high-level information about a set of the notes from a
  /// user's account based on various criteria specified via a NoteFilter object.
  /// <p/>
  /// Web applications that wish to periodically check for new content in a user's
  /// Evernote account should consider using webhooks instead of polling this API.
  /// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
  /// for more information.
  /// 
  /// @param authenticationToken
  ///   Must be a valid token for the user's account unless the NoteFilter
  ///   'notebookGuid' is the GUID of a public notebook.
  /// 
  /// @param filter
  ///   The list of criteria that will constrain the notes to be returned.
  /// 
  /// @param offset
  ///   The numeric index of the first note to show within the sorted
  ///   results.  The numbering scheme starts with "0".  This can be used for
  ///   pagination.
  /// 
  /// @param maxNotes
  ///   The maximum notes to return in this query.  The service will return a set
  ///   of notes that is no larger than this number, but may return fewer notes
  ///   if needed.  The NoteList.totalNotes field in the return value will
  ///   indicate whether there are more values available after the returned set.
  ///   Currently, the service will not return more than 250 notes in a single request,
  ///   but this number may change in the future.
  /// 
  /// @param resultSpec
  ///   This specifies which information should be returned for each matching
  ///   Note. The fields on this structure can be used to eliminate data that
  ///   the client doesn't need, which will reduce the time and bandwidth
  ///   to receive and process the reply.
  /// 
  /// @return
  ///   The list of notes that match the criteria.
  ///   The Notes.sharedNotes field will not be set.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_find_notes_metadata(&self, authentication_token: String, filter: NoteFilter, offset: i32, max_notes: i32, result_spec: NotesMetadataResultSpec) -> thrift::Result<NotesMetadataList>;
  /// This function is used to determine how many notes are found for each
  /// notebook and tag in the user's account, given a current set of filter
  /// parameters that determine the current selection.  This function will
  /// return a structure that gives the note count for each notebook and tag
  /// that has at least one note under the requested filter.  Any notebook or
  /// tag that has zero notes in the filtered set will not be listed in the
  /// reply to this function (so they can be assumed to be 0).
  /// 
  /// @param authenticationToken
  ///   Must be a valid token for the user's account unless the NoteFilter
  ///   'notebookGuid' is the GUID of a public notebook.
  /// 
  /// @param filter
  ///   The note selection filter that is currently being applied.  The note
  ///   counts are to be calculated with this filter applied to the total set
  ///   of notes in the user's account.
  /// 
  /// @param withTrash
  ///   If true, then the NoteCollectionCounts.trashCount will be calculated
  ///   and supplied in the reply. Otherwise, the trash value will be omitted.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
  ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
  ///   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID</li>
  /// </ul>
  fn handle_find_note_counts(&self, authentication_token: String, filter: NoteFilter, with_trash: bool) -> thrift::Result<NoteCollectionCounts>;
  /// Returns the current state of the note in the service with the provided
  /// GUID.  The ENML contents of the note will only be provided if the
  /// 'withContent' parameter is true.  The service will include the meta-data
  /// for each resource in the note, but the binary content depends
  /// on whether it is explicitly requested in resultSpec parameter.
  /// If the Note is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).  The applicationData
  /// fields are returned as keysOnly.
  /// 
  /// @param authenticationToken
  ///   An authentication token that grants the caller access to the requested note.
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @param resultSpec
  ///   A structure specifying the fields of the note that the caller would like to get.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_note_with_result_spec(&self, authentication_token: String, guid: types::Guid, result_spec: NoteResultSpec) -> thrift::Result<types::Note>;
  /// DEPRECATED. See getNoteWithResultSpec.
  /// 
  /// This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
  /// mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
  /// populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
  fn handle_get_note(&self, authentication_token: String, guid: types::Guid, with_content: bool, with_resources_data: bool, with_resources_recognition: bool, with_resources_alternate_data: bool) -> thrift::Result<types::Note>;
  /// Get all of the application data for the note identified by GUID,
  /// with values returned within the LazyMap fullMap field.
  /// If there are no applicationData entries, then a LazyMap
  /// with an empty fullMap will be returned. If your application
  /// only needs to fetch its own applicationData entry, use
  /// getNoteApplicationDataEntry instead.
  fn handle_get_note_application_data(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::LazyMap>;
  /// Get the value of a single entry in the applicationData map
  /// for the note identified by GUID.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - note not found, by GUID</li>
  ///   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
  /// </ul>
  fn handle_get_note_application_data_entry(&self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<String>;
  /// Update, or create, an entry in the applicationData map for
  /// the note identified by guid.
  fn handle_set_note_application_data_entry(&self, authentication_token: String, guid: types::Guid, key: String, value: String) -> thrift::Result<i32>;
  /// Remove an entry identified by 'key' from the applicationData map for
  /// the note identified by 'guid'. Silently ignores an unset of a
  /// non-existing key.
  fn handle_unset_note_application_data_entry(&self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<i32>;
  /// Returns XHTML contents of the note with the provided GUID.
  /// If the Note is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_note_content(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<String>;
  /// Returns a block of the extracted plain text contents of the note with the
  /// provided GUID.  This text can be indexed for search purposes by a light
  /// client that doesn't have capabilities to extract all of the searchable
  /// text content from the note and its resources.
  /// 
  /// If the Note is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @param noteOnly
  ///   If true, this will only return the text extracted from the ENML contents
  ///   of the note itself.  If false, this will also include the extracted text
  ///   from any text-bearing resources (PDF, recognized images)
  /// 
  /// @param tokenizeForIndexing
  ///   If true, this will break the text into cleanly separated and sanitized
  ///   tokens.  If false, this will return the more raw text extraction, with
  ///   its original punctuation, capitalization, spacing, etc.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_note_search_text(&self, authentication_token: String, guid: types::Guid, note_only: bool, tokenize_for_indexing: bool) -> thrift::Result<String>;
  /// Returns a block of the extracted plain text contents of the resource with
  /// the provided GUID.  This text can be indexed for search purposes by a light
  /// client that doesn't have capability to extract all of the searchable
  /// text content from a resource.
  /// 
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_resource_search_text(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<String>;
  /// Returns a list of the names of the tags for the note with the provided
  /// guid.  This can be used with authentication to get the tags for a
  /// user's own note, or can be used without valid authentication to retrieve
  /// the names of the tags for a note in a public notebook.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_note_tag_names(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<String>>;
  /// Asks the service to make a note with the provided set of information.
  /// 
  /// @param note
  ///   A Note object containing the desired fields to be populated on
  ///   the service.
  /// 
  /// @return
  ///   The newly created Note from the service.  The server-side
  ///   GUIDs for the Note and any Resources will be saved in this object.
  ///   The service will include the meta-data
  ///   for each resource in the note, but the binary contents of the resources
  ///   and their recognition data will be omitted (except Recognition Resource body,
  ///   for which the behavior is unspecified).
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  ///   </li>
  ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
  ///   </li>
  ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
  ///   </li>
  ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  ///   </li>
  ///   <li> LIMIT_REACHED "Note" - at max number per account
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.size" - total note size too large
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
  ///   </li>
  ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
  ///   </li>
  ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
  ///     of the specified tags had an invalid length or pattern
  ///   </li>
  ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
  ///     new tags would exceed the maximum number per account
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.notebookGuid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_create_note(&self, authentication_token: String, note: types::Note) -> thrift::Result<types::Note>;
  /// Submit a set of changes to a note to the service.  The provided data
  /// must include the note's guid field for identification. The note's
  /// title must also be set.
  /// 
  /// @param note
  ///   A Note object containing the desired fields to be populated on
  ///   the service. With the exception of the note's title and guid, fields
  ///   that are not being changed do not need to be set. If the content is not
  ///   being modified, note.content should be left unset. If the list of
  ///   resources is not being modified, note.resources should be left unset.
  /// 
  /// @return
  ///   The Note.sharedNotes field will not be set.
  ///   The service will include the meta-data
  ///   for each resource in the note, but the binary contents of the resources
  ///   and their recognition data will be omitted.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  ///   </li>
  ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
  ///   </li>
  ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
  ///   </li>
  ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
  ///   </li>
  ///   <li> LIMIT_REACHED "Note.size" - total note size too large
  ///   </li>
  ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
  ///   </li>
  ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
  ///   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
  ///     modify the note's tags. note.tags must be unset.
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
  ///     to modify the note's attributes. note.attributes must be unset.
  ///   </li>
  ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
  ///     of the specified tags had an invalid length or pattern
  ///   </li>
  ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
  ///     new tags would exceed the maximum number per account
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - note not found, by GUID
  ///   </li>
  ///   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
  ///   </li>
  /// </ul>
  fn handle_update_note(&self, authentication_token: String, note: types::Note) -> thrift::Result<types::Note>;
  /// Moves the note into the trash. The note may still be undeleted, unless it
  /// is expunged.  This is equivalent to calling updateNote() after setting
  /// Note.active = false
  /// 
  /// @param guid
  ///   The GUID of the note to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
  ///          update the note.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
  ///   </li>
  /// </ul>
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_delete_note(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Permanently removes a Note, and all of its Resources,
  /// from the service.
  /// <p/>
  /// NOTE: This function is not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The GUID of the note to delete.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "Note" - user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_expunge_note(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
  /// the Notebook with the provided GUID 'toNotebookGuid'.
  /// The caller must be the owner of both the Note and the Notebook.
  /// This creates a new Note in the destination Notebook with new content and
  /// Resources that match all of the content and Resources from the original
  /// Note, but with new GUID identifiers.
  /// The original Note is not modified by this operation.
  /// The copied note is considered as an "upload" for the purpose of upload
  /// transfer limit calculation, so its size is added to the upload count for
  /// the owner.
  /// 
  /// If the original note has been shared and has SharedNote records, the shares
  /// are NOT copied.
  /// 
  /// @param noteGuid
  ///   The GUID of the Note to copy.
  /// 
  /// @param toNotebookGuid
  ///   The GUID of the Notebook that should receive the new Note.
  /// 
  /// @return
  ///   The metadata for the new Note that was created.  This will include the
  ///   new GUID for this Note (and any copied Resources), but will not include
  ///   the content body or the binary bodies of any Resources.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> LIMIT_REACHED "Note" - at max number per account
  ///   </li>
  ///   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - user doesn't own
  ///   </li>
  ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Notebook.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_copy_note(&self, authentication_token: String, note_guid: types::Guid, to_notebook_guid: types::Guid) -> thrift::Result<types::Note>;
  /// Returns a list of the prior versions of a particular note that are
  /// saved within the service.  These prior versions are stored to provide a
  /// recovery from unintentional removal of content from a note. The identifiers
  /// that are returned by this call can be used with getNoteVersion to retrieve
  /// the previous note.
  /// The identifiers will be listed from the most recent versions to the oldest.
  /// This call is only available for notes in Premium accounts. (I.e. access
  /// to past versions of Notes is a Premium-only feature.)
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID.
  ///   </li>
  /// </ul>
  fn handle_list_note_versions(&self, authentication_token: String, note_guid: types::Guid) -> thrift::Result<Vec<NoteVersionId>>;
  /// This can be used to retrieve a previous version of a Note after it has been
  /// updated within the service.  The caller must identify the note (via its
  /// guid) and the version (via the updateSequenceNumber of that version).
  /// to find a listing of the stored version USNs for a note, call
  /// listNoteVersions.
  /// This call is only available for notes in Premium accounts. (I.e. access
  /// to past versions of Notes is a Premium-only feature.)
  /// 
  /// @param noteGuid
  ///   The GUID of the note to be retrieved.
  /// 
  /// @param updateSequenceNum
  ///   The USN of the version of the note that is being retrieved
  /// 
  /// @param withResourcesData
  ///   If true, any Resource elements in this Note will include the binary
  ///   contents of their 'data' field's body.
  /// 
  /// @param withResourcesRecognition
  ///   If true, any Resource elements will include the binary contents of the
  ///   'recognition' field's body if recognition data is present.
  /// 
  /// @param withResourcesAlternateData
  ///   If true, any Resource elements in this Note will include the binary
  ///   contents of their 'alternateData' fields' body, if an alternate form
  ///   is present.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID.
  ///   </li>
  ///   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
  ///      the corresponding USN.
  ///   </li>
  /// </ul>
  fn handle_get_note_version(&self, authentication_token: String, note_guid: types::Guid, update_sequence_num: i32, with_resources_data: bool, with_resources_recognition: bool, with_resources_alternate_data: bool) -> thrift::Result<types::Note>;
  /// Returns the current state of the resource in the service with the
  /// provided GUID.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).  Only the
  /// keys for the applicationData will be returned.
  /// 
  /// @param guid
  ///   The GUID of the resource to be retrieved.
  /// 
  /// @param withData
  ///   If true, the Resource will include the binary contents of the
  ///   'data' field's body.
  /// 
  /// @param withRecognition
  ///   If true, the Resource will include the binary contents of the
  ///   'recognition' field's body if recognition data is present.
  /// 
  /// @param withAttributes
  ///   If true, the Resource will include the attributes
  /// 
  /// @param withAlternateData
  ///   If true, the Resource will include the binary contents of the
  ///   'alternateData' field's body, if an alternate form is present.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_resource(&self, authentication_token: String, guid: types::Guid, with_data: bool, with_recognition: bool, with_attributes: bool, with_alternate_data: bool) -> thrift::Result<types::Resource>;
  /// Get all of the application data for the Resource identified by GUID,
  /// with values returned within the LazyMap fullMap field.
  /// If there are no applicationData entries, then a LazyMap
  /// with an empty fullMap will be returned. If your application
  /// only needs to fetch its own applicationData entry, use
  /// getResourceApplicationDataEntry instead.
  fn handle_get_resource_application_data(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::LazyMap>;
  /// Get the value of a single entry in the applicationData map
  /// for the Resource identified by GUID.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - Resource not found, by GUID</li>
  ///   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
  /// </ul>
  fn handle_get_resource_application_data_entry(&self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<String>;
  /// Update, or create, an entry in the applicationData map for
  /// the Resource identified by guid.
  fn handle_set_resource_application_data_entry(&self, authentication_token: String, guid: types::Guid, key: String, value: String) -> thrift::Result<i32>;
  /// Remove an entry identified by 'key' from the applicationData map for
  /// the Resource identified by 'guid'.
  fn handle_unset_resource_application_data_entry(&self, authentication_token: String, guid: types::Guid, key: String) -> thrift::Result<i32>;
  /// Submit a set of changes to a resource to the service.  This can be used
  /// to update the meta-data about the resource, but cannot be used to change
  /// the binary contents of the resource (including the length and hash).  These
  /// cannot be changed directly without creating a new resource and removing the
  /// old one via updateNote.
  /// 
  /// @param resource
  ///   A Resource object containing the desired fields to be populated on
  ///   the service.  The service will attempt to update the resource with the
  ///   following fields from the client:
  ///   <ul>
  ///      <li>guid:  must be provided to identify the resource
  ///      </li>
  ///      <li>mime
  ///      </li>
  ///      <li>width
  ///      </li>
  ///      <li>height
  ///      </li>
  ///      <li>duration
  ///      </li>
  ///      <li>attributes:  optional.  if present, the set of attributes will
  ///           be replaced.
  ///      </li>
  ///   </ul>
  /// 
  /// @return
  ///   The Update Sequence Number of the resource after the changes have been
  ///   applied.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
  ///   </li>
  ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_update_resource(&self, authentication_token: String, resource: types::Resource) -> thrift::Result<i32>;
  /// Returns binary data of the resource with the provided GUID.  For
  /// example, if this were an image resource, this would contain the
  /// raw bits of the image.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource to be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_resource_data(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>>;
  /// Returns the current state of a resource, referenced by containing
  /// note GUID and resource content hash.
  /// 
  /// @param noteGuid
  ///   The GUID of the note that holds the resource to be retrieved.
  /// 
  /// @param contentHash
  ///   The MD5 checksum of the resource within that note. Note that
  ///   this is the binary checksum, for example from Resource.data.bodyHash,
  ///   and not the hex-encoded checksum that is used within an en-media
  ///   tag in a note body.
  /// 
  /// @param withData
  ///   If true, the Resource will include the binary contents of the
  ///   'data' field's body.
  /// 
  /// @param withRecognition
  ///   If true, the Resource will include the binary contents of the
  ///   'recognition' field's body.
  /// 
  /// @param withAlternateData
  ///   If true, the Resource will include the binary contents of the
  ///   'alternateData' field's body, if an alternate form is present.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
  ///   </li>
  ///   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note" - not found, by guid
  ///   </li>
  ///   <li> "Resource" - not found, by hash
  ///   </li>
  /// </ul>
  fn handle_get_resource_by_hash(&self, authentication_token: String, note_guid: types::Guid, content_hash: Vec<u8>, with_data: bool, with_recognition: bool, with_alternate_data: bool) -> thrift::Result<types::Resource>;
  /// Returns the binary contents of the recognition index for the resource
  /// with the provided GUID.  If the caller asks about a resource that has
  /// no recognition data, this will throw EDAMNotFoundException.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource whose recognition data should be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  ///   <li> "Resource.recognition" - resource has no recognition
  ///   </li>
  /// </ul>
  fn handle_get_resource_recognition(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>>;
  /// If the Resource with the provided GUID has an alternate data representation
  /// (indicated via the Resource.alternateData field), then this request can
  /// be used to retrieve the binary contents of that alternate data file.
  /// If the caller asks about a resource that has no alternate data form, this
  /// will throw EDAMNotFoundException.
  /// 
  /// @param guid
  ///    The GUID of the resource whose recognition data should be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  ///   <li> "Resource.alternateData" - resource has no recognition
  ///   </li>
  /// </ul>
  fn handle_get_resource_alternate_data(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<Vec<u8>>;
  /// Returns the set of attributes for the Resource with the provided GUID.
  /// If the Resource is found in a public notebook, the authenticationToken
  /// will be ignored (so it could be an empty string).
  /// 
  /// @param guid
  ///   The GUID of the resource whose attributes should be retrieved.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
  ///   </li>
  ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Resource.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_get_resource_attributes(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<types::ResourceAttributes>;
  /// <p>
  /// Looks for a user account with the provided userId on this NoteStore
  /// shard and determines whether that account contains a public notebook
  /// with the given URI.  If the account is not found, or no public notebook
  /// exists with this URI, this will throw an EDAMNotFoundException,
  /// otherwise this will return the information for that Notebook.
  /// </p>
  /// <p>
  /// If a notebook is visible on the web with a full URL like
  /// http://www.evernote.com/pub/sethdemo/api
  /// Then 'sethdemo' is the username that can be used to look up the userId,
  /// and 'api' is the publicUri.
  /// </p>
  /// 
  /// @param userId
  ///    The numeric identifier for the user who owns the public notebook.
  ///    To find this value based on a username string, you can invoke
  ///    UserStore.getPublicUserInfo
  /// 
  /// @param publicUri
  ///    The uri string for the public notebook, from Notebook.publishing.uri.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"Publishing.uri" - not found, by URI</li>
  /// </ul>
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
  ///     taken down (for all requesters).</li>
  ///   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
  ///     down for the requester because of an IP-based country lookup.</li>
  /// </ul>
  fn handle_get_public_notebook(&self, user_id: types::UserID, public_uri: String) -> thrift::Result<types::Notebook>;
  /// * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
  /// *
  /// * Share a notebook with an email address, and optionally to a specific
  /// * recipient. If an existing SharedNotebook associated with
  /// * sharedNotebook.notebookGuid is found by recipientUsername or email, then
  /// * the values of sharedNotebook will be used to update the existing record,
  /// * else a new record will be created.
  /// *
  /// * If recipientUsername is set and there is already a SharedNotebook
  /// * for that Notebook with that recipientUsername and the privileges on the
  /// * existing notebook are lower, than on this one, this will update the
  /// * privileges and sharerUserId. If there isn't an existing SharedNotebook for
  /// * recipientUsername, this will create and return a shared notebook for that
  /// * email and recipientUsername. If recipientUsername is not set and there
  /// * already is a SharedNotebook for a Notebook for that email address and the
  /// * privileges on the existing SharedNotebook are lower than on this one, this
  /// * will update the privileges and sharerUserId, and return the updated
  /// * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
  /// * the email address.
  /// *
  /// * If the authenticationToken is a Business auth token, recipientUsername is
  /// * set and the recipient is in the same business as the business auth token,
  /// * this method will also auto-join the business user to the SharedNotebook -
  /// * that is it will set serviceJoined on the SharedNotebook and create a
  /// * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
  /// * The LinkedNotebook creation happens out-of-band, so there will be a delay
  /// * on the order of half a minute between the SharedNotebook and LinkedNotebook
  /// * creation.
  /// *
  /// * Also handles sending an email to the email addresses: if a SharedNotebook
  /// * is being created, this will send the shared notebook invite email, and
  /// * if a SharedNotebook already exists, it will send the shared notebook
  /// * reminder email. Both these emails contain a link to join the notebook.
  /// * If the notebook is being auto-joined, it sends an email with that
  /// * information to the recipient.
  /// *
  /// * @param authenticationToken
  /// *   Must be an authentication token from the owner or a shared notebook
  /// *   authentication token or business authentication token with sufficient
  /// *   permissions to change invitations for a notebook.
  /// *
  /// * @param sharedNotebook
  /// *   A shared notebook object populated with the email address of the share
  /// *   recipient, the notebook guid and the access permissions. All other
  /// *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
  /// *   field must be explicitly set with either a true or false value.
  /// *
  /// * @param message
  /// *   The sharer-defined message to put in the email sent out.
  /// *
  /// * @return
  /// *   The fully populated SharedNotebook object including the server assigned
  /// *   globalId which can both be used to uniquely identify the SharedNotebook.
  /// *
  /// * @throws EDAMUserException <ul>
  /// *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
  /// *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
  /// *       SharedNotebook.privilegeLevel was not set.</li>
  /// *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
  /// *       set. requireLogin is deprecated.</li>
  /// *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
  /// *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
  /// *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
  ///         owner's account is not confirmed.</li>
  /// *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
  /// *       recipientSettings is set in the sharedNotebook.  Only the recipient
  /// *       can set these values via the setSharedNotebookRecipientSettings
  /// *       method.</li>
  /// *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
  /// *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
  /// *   </ul>
  /// * @throws EDAMNotFoundException <ul>
  /// *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
  /// *   </li>
  /// *   </ul>
  fn handle_share_notebook(&self, authentication_token: String, shared_notebook: types::SharedNotebook, message: String) -> thrift::Result<types::SharedNotebook>;
  /// Share a notebook by a messaging thread ID or a list of contacts. This function is
  /// intended to be used in conjunction with Evernote messaging, and as such does not
  /// notify the recipient that a notebook has been shared with them.
  /// 
  /// Sharing with a subset of participants on a thread is accomplished by specifying both
  /// a thread ID and a list of contacts. This ensures that even if those contacts are
  /// on the thread under a deactivated identity, the correct user (the one who has the
  /// given contact on the thread) receives the share.
  /// 
  /// @param authenticationToken
  ///   An authentication token that grants the caller permission to share the notebook.
  ///   This should be an owner token if the notebook is owned by the caller.
  ///   If the notebook is a business notebook to which the caller has full access,
  ///   this should be their business authentication token. If the notebook is a shared
  ///   (non-business) notebook to which the caller has full access, this should be the
  ///   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
  /// 
  /// @param shareTemplate
  ///   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
  ///   should be shared, and the recipient information.
  /// 
  /// @return
  ///   A structure containing the USN of the Notebook after the change and a list of created
  ///   or updated SharedNotebooks.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
  ///   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
  ///     valid GUID</li>
  ///   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
  ///   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
  ///     specified</li>
  ///   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
  ///     is not allowed.</li>
  ///   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
  ///     specified, either by thread ID or as a list of contacts</li>
  ///   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
  ///     number of shares</li>
  /// </ul>
  /// 
  /// @throws EDAMInvalidContactsException <ul>
  ///   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
  ///     in shareTemplate.recipients was not syntactically valid, or if attempting to
  ///     share a notebook with an Evernote identity that the sharer does not have a
  ///     connection to. The exception will specify which recipients were invalid.</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
  ///   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
  ///     specified, but no thread with that ID exists</li>
  /// </ul>
  fn handle_create_or_update_notebook_shares(&self, authentication_token: String, share_template: NotebookShareTemplate) -> thrift::Result<CreateOrUpdateNotebookSharesResult>;
  /// @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
  fn handle_update_shared_notebook(&self, authentication_token: String, shared_notebook: types::SharedNotebook) -> thrift::Result<i32>;
  /// Set values for the recipient settings associated with a notebook share. Only the
  /// recipient of the share can update their recipient settings.
  /// 
  /// If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
  /// you must leave that field unset in recipientSettings.
  /// This method will skip that field for updates and attempt to leave the existing value as
  /// it is.
  /// 
  /// If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
  /// will be either left as null or converted to false (if currently true).
  /// 
  /// To unset a notebook's stack, pass in the empty string for the stack field.
  /// 
  /// @param authenticationToken The owner authentication token for the recipient of the share.
  /// 
  /// @return The updated Notebook with the new recipient settings. Note that some of the
  /// recipient settings may differ from what was requested. Clients should update their state
  /// based on this return value.
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
  ///       notebookGuid on the given shard.</li>
  ///   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
  ///       user and is also not published to their business.</li>
  /// </ul>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
  ///       allowed to set recipient settings on the specified notebook.</li>
  ///   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
  ///       is allowed only for notebooks which belong to the same business as the user.</li>
  ///   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
  ///       to false and any of reminder* settings to true.</li>
  /// </ul>
  fn handle_set_notebook_recipient_settings(&self, authentication_token: String, notebook_guid: String, recipient_settings: types::NotebookRecipientSettings) -> thrift::Result<types::Notebook>;
  /// Lists the collection of shared notebooks for all notebooks in the
  /// users account.
  /// 
  /// @return
  ///  The list of all SharedNotebooks for the user
  fn handle_list_shared_notebooks(&self, authentication_token: String) -> thrift::Result<Vec<types::SharedNotebook>>;
  /// Asks the service to make a linked notebook with the provided name, username
  /// of the owner and identifiers provided. A linked notebook can be either a
  /// link to a public notebook or to a private shared notebook.
  /// 
  /// @param linkedNotebook
  ///   The desired fields for the linked notebook must be provided on this
  ///   object.  The name of the linked notebook must be set. Either a username
  ///   uri or a shard id and share key must be provided otherwise a
  ///   EDAMUserException is thrown.
  /// 
  /// @return
  ///   The newly created LinkedNotebook.  The server-side id will be
  ///   saved in this object's 'id' field.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
  ///     if public notebook set but bad uri
  ///   </li>
  ///   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
  ///     if private notebook but shard id not provided
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
  ///     if a bad global identifer was set on a private notebook
  ///   </li>
  /// </ul>
  fn handle_create_linked_notebook(&self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<types::LinkedNotebook>;
  /// @param linkedNotebook
  ///   Updates the name of a linked notebook.
  /// 
  /// @return
  ///   The Update Sequence Number for this change within the account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
  ///   </li>
  /// </ul>
  fn handle_update_linked_notebook(&self, authentication_token: String, linked_notebook: types::LinkedNotebook) -> thrift::Result<i32>;
  /// Returns a list of linked notebooks
  fn handle_list_linked_notebooks(&self, authentication_token: String) -> thrift::Result<Vec<types::LinkedNotebook>>;
  /// Permanently expunges the linked notebook from the account.
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param guid
  ///   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
  ///   from the account.
  fn handle_expunge_linked_notebook(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<i32>;
  /// Asks the service to produce an authentication token that can be used to
  /// access the contents of a shared notebook from someone else's account.
  /// This authenticationToken can be used with the various other NoteStore
  /// calls to find and retrieve notes, and if the permissions in the shared
  /// notebook are sufficient, to make changes to the contents of the notebook.
  /// 
  /// @param shareKeyOrGlobalId
  ///   May be one of the following:
  ///   <ul>
  ///     <li>A share key for a shared notebook that was granted to some recipient
  ///         Must be used if you are joining a notebook unless it was shared via
  ///         createOrUpdateNotebookShares. Share keys are delivered out-of-band
  ///         and are generally not available to clients. For security reasons,
  ///         share keys may be invalidated at the discretion of the service.
  ///     </li>
  ///     <li>The shared notebook global identifier. May be used to access a
  ///         notebook that is already joined.
  ///     </li>
  ///     <li>The Notebook GUID. May be used to access a notebook that was already
  ///         joined, or to access a notebook that was shared with the recipient
  ///         via createOrUpdateNotebookShares.
  ///     </li>
  ///   </ul>
  /// 
  /// @param authenticationToken
  ///   If a non-empty string is provided, this is the full user-based
  ///   authentication token that identifies the user who is currently logged in
  ///   and trying to access the shared notebook.
  ///   If this string is empty, the service will attempt to authenticate to the
  ///   shared notebook without any logged in user.
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
  ///   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
  /// </ul>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
  ///          no valid authentication token was provided.
  ///   </li>
  ///   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
  ///          and another username has already been bound to this notebook.
  ///   </li>
  /// </ul>
  fn handle_authenticate_to_shared_notebook(&self, share_key_or_global_id: String, authentication_token: String) -> thrift::Result<user_store::AuthenticationResult>;
  /// This function is used to retrieve extended information about a shared
  /// notebook by a guest who has already authenticated to access that notebook.
  /// This requires an 'authenticationToken' parameter which should be the
  /// resut of a call to authenticateToSharedNotebook(...).
  /// I.e. this is the token that gives access to the particular shared notebook
  /// in someone else's account -- it's not the authenticationToken for the
  /// owner of the notebook itself.
  /// 
  /// @param authenticationToken
  ///   Should be the authentication token retrieved from the reply of
  ///   authenticateToSharedNotebook(), proving access to a particular shared
  ///   notebook.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "authenticationToken" -
  ///          authentication token doesn't correspond to a valid shared notebook
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "SharedNotebook.id" - the shared notebook no longer exists
  ///   </li>
  /// </ul>
  fn handle_get_shared_notebook_by_auth(&self, authentication_token: String) -> thrift::Result<types::SharedNotebook>;
  /// Attempts to send a single note to one or more email recipients.
  /// <p/>
  /// NOTE: This function is generally not available to third party applications.
  /// Calls will result in an EDAMUserException with the error code
  /// PERMISSION_DENIED.
  /// 
  /// @param authenticationToken
  ///    The note will be sent as the user logged in via this token, using that
  ///    user's registered email address.  If the authenticated user doesn't
  ///    have permission to read that note, the emailing will fail.
  /// 
  /// @param parameters
  ///    The note must be specified either by GUID (in which case it will be
  ///    sent using the existing data in the service), or else the full Note
  ///    must be passed to this call.  This also specifies the additional
  ///    email fields that will be used in the email.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
  ///     The email can't be sent because this would exceed the user's daily
  ///     email limit.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "(email address)" -
  ///     email address malformed
  ///   </li>
  ///   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
  ///     if there are no To: or Cc: addresses provided.
  ///   </li>
  ///   <li> DATA_REQUIRED "Note.title" -
  ///     if the caller provides a Note parameter with no title
  ///   </li>
  ///   <li> DATA_REQUIRED "Note.content" -
  ///     if the caller provides a Note parameter with no content
  ///   </li>
  ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
  ///   </li>
  ///   <li> DATA_REQUIRED "NoteEmailParameters.note" -
  ///     if no guid or note provided
  ///   </li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID
  ///   </li>
  /// </ul>
  fn handle_email_note(&self, authentication_token: String, parameters: NoteEmailParameters) -> thrift::Result<()>;
  /// If this note is not already shared publicly (via its own direct URL), then this
  /// will start sharing that note.
  /// This will return the secret "Note Key" for this note that
  /// can currently be used in conjunction with the Note's GUID to gain direct
  /// read-only access to the Note.
  /// If the note is already shared, then this won't make any changes to the
  /// note, and the existing "Note Key" will be returned.  The only way to change
  /// the Note Key for an existing note is to stopSharingNote first, and then
  /// call this function.
  /// 
  /// @param guid
  ///   The GUID of the note to be shared.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "Note.guid" - not found, by GUID</li>
  /// </ul>
  fn handle_share_note(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<String>;
  /// If this note is shared publicly then this will stop sharing that note
  /// and invalidate its "Note Key", so any existing URLs to access that Note
  /// will stop working.
  /// 
  /// If the Note is not shared, then this function will do nothing.
  /// 
  /// This function does not remove invididual shares for the note. To remove
  /// individual shares, see stopSharingNoteWithRecipients.
  /// 
  /// @param guid
  ///   The GUID of the note to be un-shared.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
  ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"Note.guid" - not found, by GUID</li>
  /// </ul>
  fn handle_stop_sharing_note(&self, authentication_token: String, guid: types::Guid) -> thrift::Result<()>;
  /// Asks the service to produce an authentication token that can be used to
  /// access the contents of a single Note which was individually shared
  /// from someone's account.
  /// This authenticationToken can be used with the various other NoteStore
  /// calls to find and retrieve the Note and its directly-referenced children.
  /// 
  /// @param guid
  ///   The GUID identifying this Note on this shard.
  /// 
  /// @param noteKey
  ///   The 'noteKey' identifier from the Note that was originally created via
  ///   a call to shareNote() and then given to a recipient to access.
  /// 
  /// @param authenticationToken
  ///   An optional authenticationToken that identifies the user accessing the
  ///   shared note. This parameter may be required to access some shared notes.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
  ///     shared, or the noteKey doesn't match the current key for this note
  ///   </li>
  ///   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
  ///     required to access this Note, but either no authentication token or a
  ///     "non-owner" authentication token was provided.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "guid" - the note with that GUID is not found
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMSystemException <ul>
  ///   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
  ///     all requesters).
  ///   </li>
  ///   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
  ///     for the requester because of an IP-based country lookup.
  ///   </ul>
  /// </ul>
  fn handle_authenticate_to_shared_note(&self, guid: String, note_key: String, authentication_token: String) -> thrift::Result<user_store::AuthenticationResult>;
  /// Identify related entities on the service, such as notes,
  /// notebooks, tags and users in a business related to notes or content.
  /// 
  /// @param query
  ///   The information about which we are finding related entities.
  /// 
  /// @param resultSpec
  ///   Allows the client to indicate the type and quantity of
  ///   information to be returned, allowing a saving of time and
  ///   bandwidth.
  /// 
  /// @return
  ///   The result of the query, with information considered
  ///   to likely be relevantly related to the information
  ///   described by the query.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
  ///     a zero-length plain text value.
  ///   </li>
  ///   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
  ///     invalid Note GUID, that is, one that does not match the constraints
  ///     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
  ///   </li>
  ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
  ///   </li>
  ///   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
  ///     the note identified by RelatedQuery.noteGuid.
  ///   </li>
  ///   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
  ///     findExperts in the context of a non business user (i.e. The authenticationToken
  ///     is not a business auth token).
  ///   </li>
  ///   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
  ///     in the result spec.
  ///   </li>
  /// </ul>
  /// 
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
  ///     found, if that field has been set in the query.
  ///   </li>
  /// </ul>
  fn handle_find_related(&self, authentication_token: String, query: RelatedQuery, result_spec: RelatedResultSpec) -> thrift::Result<RelatedResult>;
  /// Perform the same operation as updateNote() would provided that the update
  /// sequence number on the parameter Note object matches the current update sequence
  /// number that the service has for the note.  If they do <i>not</i> match, then
  /// <i>no</i> update is performed and the return value will have the current server
  /// state in the note field and updated will be false.  If the update sequence
  /// numbers between the client and server do match, then the note will be updated
  /// and the note field of the return value will be returned as it would be for the
  /// updateNote method.  This method allows you to check for an update to the note
  /// on the service, by another client instance, from when you obtained the
  /// note state as a baseline for your edits and the time when you wish to save your
  /// edits.  If your client can merge the conflict, you can avoid overwriting changes
  /// that were saved to the service by the other client.
  /// 
  /// See the updateNote method for information on the exceptions and parameters for
  /// this method.  The only difference is that you must have an update sequence number
  /// defined on the note parameter (equal to the USN of the note as synched to the
  /// client), and the following additional exceptions might be thrown.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
  ///       not provided.  This includes a value that is set as 0.</li>
  ///   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
  ///       sequence number that is larger than the current server value, which should
  ///       not happen if your client is working correctly.</li>
  /// </ul>
  fn handle_update_note_if_usn_matches(&self, authentication_token: String, note: types::Note) -> thrift::Result<UpdateNoteIfUsnMatchesResult>;
  /// Manage invitations and memberships associated with a given notebook.
  /// 
  /// <i>Note:</i> Beta method! This method is currently intended for
  /// limited use by Evernote clients that have discussed using this
  /// routine with the platform team.
  /// 
  /// @param parameters A structure containing all parameters for the updates.
  ///    See the structure documentation for details.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
  ///    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
  ///    shares.</li>
  /// </ul>
  fn handle_manage_notebook_shares(&self, authentication_token: String, parameters: ManageNotebookSharesParameters) -> thrift::Result<ManageNotebookSharesResult>;
  /// Return the share relationships for the given notebook, including
  /// both the invitations and the memberships.
  /// 
  /// <i>Note:</i> Beta method! This method is currently intended for
  /// limited use by Evernote clients that have discussed using this
  /// routine with the platform team.
  fn handle_get_notebook_shares(&self, authentication_token: String, notebook_guid: String) -> thrift::Result<ShareRelationships>;
}

pub struct NoteStoreSyncProcessor<H: NoteStoreSyncHandler> {
  handler: H,
}

impl <H: NoteStoreSyncHandler> NoteStoreSyncProcessor<H> {
  pub fn new(handler: H) -> NoteStoreSyncProcessor<H> {
    NoteStoreSyncProcessor {
      handler,
    }
  }
  fn process_get_sync_state(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_sync_state(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_filtered_sync_chunk(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_filtered_sync_chunk(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_linked_notebook_sync_state(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_linked_notebook_sync_state(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_linked_notebook_sync_chunk(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_linked_notebook_sync_chunk(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_notebooks(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_notebooks(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_accessible_business_notebooks(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_accessible_business_notebooks(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_default_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_default_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_create_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_expunge_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_expunge_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_tags(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_tags(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_tags_by_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_tags_by_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tag(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_tag(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_tag(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_create_tag(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_tag(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_tag(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_untag_all(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_untag_all(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_expunge_tag(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_expunge_tag(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_searches(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_searches(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_search(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_search(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_search(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_create_search(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_search(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_search(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_expunge_search(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_expunge_search(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_note_offset(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_find_note_offset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_notes_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_find_notes_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_note_counts(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_find_note_counts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note_with_result_spec(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note_with_result_spec(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note_application_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note_application_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note_application_data_entry(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note_application_data_entry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_note_application_data_entry(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_set_note_application_data_entry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unset_note_application_data_entry(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_unset_note_application_data_entry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note_content(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note_content(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note_search_text(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note_search_text(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_search_text(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_search_text(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note_tag_names(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note_tag_names(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_create_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_delete_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_expunge_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_expunge_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_copy_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_copy_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_note_versions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_note_versions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_note_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_note_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_application_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_application_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_application_data_entry(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_application_data_entry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_resource_application_data_entry(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_set_resource_application_data_entry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unset_resource_application_data_entry(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_unset_resource_application_data_entry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_resource(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_resource(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_by_hash(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_by_hash(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_recognition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_recognition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_alternate_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_alternate_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_attributes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_resource_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_public_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_public_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_share_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_share_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_or_update_notebook_shares(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_create_or_update_notebook_shares(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_shared_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_shared_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_notebook_recipient_settings(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_set_notebook_recipient_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_shared_notebooks(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_shared_notebooks(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_linked_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_create_linked_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_linked_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_linked_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_linked_notebooks(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_list_linked_notebooks(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_expunge_linked_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_expunge_linked_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authenticate_to_shared_notebook(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_authenticate_to_shared_notebook(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_shared_notebook_by_auth(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_shared_notebook_by_auth(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_email_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_email_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_share_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_share_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_stop_sharing_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_stop_sharing_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authenticate_to_shared_note(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_authenticate_to_shared_note(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_find_related(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_find_related(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_note_if_usn_matches(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_update_note_if_usn_matches(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_manage_notebook_shares(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_manage_notebook_shares(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_notebook_shares(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TNoteStoreProcessFunctions::process_get_notebook_shares(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TNoteStoreProcessFunctions;

impl TNoteStoreProcessFunctions {
  pub fn process_get_sync_state<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetSyncStateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_sync_state(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSyncState", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetSyncStateResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSyncStateResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("getSyncState", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSyncStateResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSyncState", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getSyncState", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSyncState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getSyncState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_filtered_sync_chunk<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetFilteredSyncChunkArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_filtered_sync_chunk(args.authentication_token, args.after_u_s_n, args.max_entries, args.filter) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getFilteredSyncChunk", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetFilteredSyncChunkResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetFilteredSyncChunkResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("getFilteredSyncChunk", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetFilteredSyncChunkResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getFilteredSyncChunk", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getFilteredSyncChunk", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getFilteredSyncChunk", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getFilteredSyncChunk", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_linked_notebook_sync_state<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetLinkedNotebookSyncStateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_linked_notebook_sync_state(args.authentication_token, args.linked_notebook) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetLinkedNotebookSyncStateResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetLinkedNotebookSyncStateResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetLinkedNotebookSyncStateResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetLinkedNotebookSyncStateResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_linked_notebook_sync_chunk<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetLinkedNotebookSyncChunkArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_linked_notebook_sync_chunk(args.authentication_token, args.linked_notebook, args.after_u_s_n, args.max_entries, args.full_sync_only) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetLinkedNotebookSyncChunkResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetLinkedNotebookSyncChunkResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetLinkedNotebookSyncChunkResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetLinkedNotebookSyncChunkResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getLinkedNotebookSyncChunk", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_notebooks<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListNotebooksArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_notebooks(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listNotebooks", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListNotebooksResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListNotebooksResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListNotebooksResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listNotebooks", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_accessible_business_notebooks<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListAccessibleBusinessNotebooksArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_accessible_business_notebooks(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listAccessibleBusinessNotebooks", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListAccessibleBusinessNotebooksResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListAccessibleBusinessNotebooksResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listAccessibleBusinessNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListAccessibleBusinessNotebooksResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listAccessibleBusinessNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listAccessibleBusinessNotebooks", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listAccessibleBusinessNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listAccessibleBusinessNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_notebook(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNotebookResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNotebookResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNotebookResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNotebookResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_default_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetDefaultNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_default_notebook(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getDefaultNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetDefaultNotebookResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetDefaultNotebookResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("getDefaultNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetDefaultNotebookResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getDefaultNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getDefaultNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getDefaultNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getDefaultNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreCreateNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_notebook(args.authentication_token, args.notebook) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreCreateNotebookResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateNotebookResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateNotebookResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateNotebookResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_notebook(args.authentication_token, args.notebook) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateNotebookResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNotebookResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNotebookResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNotebookResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_expunge_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreExpungeNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_expunge_notebook(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreExpungeNotebookResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeNotebookResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeNotebookResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeNotebookResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("expungeNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_tags<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListTagsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_tags(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listTags", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListTagsResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListTagsResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listTags", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListTagsResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listTags", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listTags", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_tags_by_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListTagsByNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_tags_by_notebook(args.authentication_token, args.notebook_guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListTagsByNotebookResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListTagsByNotebookResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListTagsByNotebookResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreListTagsByNotebookResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listTagsByNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tag<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetTagArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tag(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getTag", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetTagResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetTagResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetTagResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetTagResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getTag", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_tag<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreCreateTagArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_tag(args.authentication_token, args.tag) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createTag", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreCreateTagResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateTagResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("createTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateTagResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("createTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateTagResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("createTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("createTag", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_tag<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateTagArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_tag(args.authentication_token, args.tag) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateTagResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateTagResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateTagResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateTagResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_untag_all<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUntagAllArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_untag_all(args.authentication_token, args.guid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUntagAllResult { user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUntagAllResult{ user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUntagAllResult{ user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUntagAllResult{ user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("untagAll", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_expunge_tag<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreExpungeTagArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_expunge_tag(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreExpungeTagResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeTagResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeTagResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeTagResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("expungeTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_searches<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListSearchesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_searches(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listSearches", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListSearchesResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListSearchesResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listSearches", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListSearchesResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listSearches", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listSearches", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listSearches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listSearches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_search<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetSearchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_search(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetSearchResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSearchResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSearchResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSearchResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_search<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreCreateSearchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_search(args.authentication_token, args.search) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createSearch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreCreateSearchResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateSearchResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("createSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateSearchResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("createSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("createSearch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_search<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateSearchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_search(args.authentication_token, args.search) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateSearchResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateSearchResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateSearchResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateSearchResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_expunge_search<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreExpungeSearchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_expunge_search(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreExpungeSearchResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeSearchResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeSearchResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeSearchResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("expungeSearch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_note_offset<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreFindNoteOffsetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_note_offset(args.authentication_token, args.filter, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreFindNoteOffsetResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNoteOffsetResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNoteOffsetResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNoteOffsetResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("findNoteOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_notes_metadata<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreFindNotesMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_notes_metadata(args.authentication_token, args.filter, args.offset, args.max_notes, args.result_spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreFindNotesMetadataResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNotesMetadataResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNotesMetadataResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNotesMetadataResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("findNotesMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_note_counts<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreFindNoteCountsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_note_counts(args.authentication_token, args.filter, args.with_trash) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreFindNoteCountsResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNoteCountsResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNoteCountsResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreFindNoteCountsResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("findNoteCounts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note_with_result_spec<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteWithResultSpecArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note_with_result_spec(args.authentication_token, args.guid, args.result_spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteWithResultSpecResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteWithResultSpecResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteWithResultSpecResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteWithResultSpecResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNoteWithResultSpec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note(args.authentication_token, args.guid, args.with_content, args.with_resources_data, args.with_resources_recognition, args.with_resources_alternate_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note_application_data<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteApplicationDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note_application_data(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteApplicationDataResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteApplicationDataResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteApplicationDataResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteApplicationDataResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNoteApplicationData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note_application_data_entry<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteApplicationDataEntryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note_application_data_entry(args.authentication_token, args.guid, args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteApplicationDataEntryResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteApplicationDataEntryResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_note_application_data_entry<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreSetNoteApplicationDataEntryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_note_application_data_entry(args.authentication_token, args.guid, args.key, args.value) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreSetNoteApplicationDataEntryResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreSetNoteApplicationDataEntryResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreSetNoteApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreSetNoteApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unset_note_application_data_entry<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUnsetNoteApplicationDataEntryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unset_note_application_data_entry(args.authentication_token, args.guid, args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUnsetNoteApplicationDataEntryResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUnsetNoteApplicationDataEntryResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUnsetNoteApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUnsetNoteApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unsetNoteApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note_content<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteContentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note_content(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteContentResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteContentResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteContentResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteContentResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNoteContent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note_search_text<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteSearchTextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note_search_text(args.authentication_token, args.guid, args.note_only, args.tokenize_for_indexing) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteSearchTextResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteSearchTextResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteSearchTextResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteSearchTextResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNoteSearchText", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_search_text<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceSearchTextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_search_text(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceSearchTextResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceSearchTextResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceSearchTextResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceSearchTextResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceSearchText", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note_tag_names<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteTagNamesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note_tag_names(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteTagNamesResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteTagNamesResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteTagNamesResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteTagNamesResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNoteTagNames", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreCreateNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_note(args.authentication_token, args.note) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreCreateNoteResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateNoteResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("createNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateNoteResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("createNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateNoteResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("createNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("createNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_note(args.authentication_token, args.note) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateNoteResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNoteResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNoteResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNoteResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreDeleteNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_note(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreDeleteNoteResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreDeleteNoteResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreDeleteNoteResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreDeleteNoteResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deleteNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_expunge_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreExpungeNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_expunge_note(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreExpungeNoteResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeNoteResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeNoteResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeNoteResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("expungeNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_copy_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreCopyNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_copy_note(args.authentication_token, args.note_guid, args.to_notebook_guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreCopyNoteResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreCopyNoteResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreCopyNoteResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreCopyNoteResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("copyNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_note_versions<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListNoteVersionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_note_versions(args.authentication_token, args.note_guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListNoteVersionsResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListNoteVersionsResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListNoteVersionsResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreListNoteVersionsResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listNoteVersions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_note_version<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNoteVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_note_version(args.authentication_token, args.note_guid, args.update_sequence_num, args.with_resources_data, args.with_resources_recognition, args.with_resources_alternate_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNoteVersionResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteVersionResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteVersionResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNoteVersionResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNoteVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource(args.authentication_token, args.guid, args.with_data, args.with_recognition, args.with_attributes, args.with_alternate_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResource", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResource", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResource", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResource", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResource", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResource", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResource", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_application_data<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceApplicationDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_application_data(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceApplicationDataResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceApplicationDataResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceApplicationDataResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceApplicationDataResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceApplicationData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_application_data_entry<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceApplicationDataEntryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_application_data_entry(args.authentication_token, args.guid, args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceApplicationDataEntryResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceApplicationDataEntryResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_resource_application_data_entry<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreSetResourceApplicationDataEntryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_resource_application_data_entry(args.authentication_token, args.guid, args.key, args.value) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreSetResourceApplicationDataEntryResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreSetResourceApplicationDataEntryResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreSetResourceApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreSetResourceApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unset_resource_application_data_entry<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUnsetResourceApplicationDataEntryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unset_resource_application_data_entry(args.authentication_token, args.guid, args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUnsetResourceApplicationDataEntryResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUnsetResourceApplicationDataEntryResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUnsetResourceApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUnsetResourceApplicationDataEntryResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unsetResourceApplicationDataEntry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_resource<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateResourceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_resource(args.authentication_token, args.resource) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateResourceResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateResourceResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateResourceResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateResourceResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateResource", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_data<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_data(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceDataResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceDataResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceDataResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceDataResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_by_hash<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceByHashArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_by_hash(args.authentication_token, args.note_guid, args.content_hash, args.with_data, args.with_recognition, args.with_alternate_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceByHashResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceByHashResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceByHashResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceByHashResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceByHash", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_recognition<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceRecognitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_recognition(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceRecognitionResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceRecognitionResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceRecognitionResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceRecognitionResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceRecognition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_alternate_data<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceAlternateDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_alternate_data(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceAlternateDataResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceAlternateDataResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceAlternateDataResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceAlternateDataResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceAlternateData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_attributes<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetResourceAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_attributes(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetResourceAttributesResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceAttributesResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceAttributesResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetResourceAttributesResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getResourceAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_public_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetPublicNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_public_notebook(args.user_id, args.public_uri) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPublicNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetPublicNotebookResult { result_value: Some(handler_return), system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetPublicNotebookResult{ result_value: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("getPublicNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetPublicNotebookResult{ result_value: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPublicNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getPublicNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPublicNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getPublicNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_share_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreShareNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_share_notebook(args.authentication_token, args.shared_notebook, args.message) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreShareNotebookResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreShareNotebookResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreShareNotebookResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreShareNotebookResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("shareNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_or_update_notebook_shares<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreCreateOrUpdateNotebookSharesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_or_update_notebook_shares(args.authentication_token, args.share_template) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreCreateOrUpdateNotebookSharesResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None, invalid_contacts_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateOrUpdateNotebookSharesResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None, invalid_contacts_exception: None };
              let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateOrUpdateNotebookSharesResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None, invalid_contacts_exception: None };
              let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateOrUpdateNotebookSharesResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err), invalid_contacts_exception: None };
              let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMInvalidContactsException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMInvalidContactsException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateOrUpdateNotebookSharesResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: None, invalid_contacts_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createOrUpdateNotebookShares", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_shared_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateSharedNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_shared_notebook(args.authentication_token, args.shared_notebook) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateSharedNotebookResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateSharedNotebookResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateSharedNotebookResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateSharedNotebookResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateSharedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_notebook_recipient_settings<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreSetNotebookRecipientSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_notebook_recipient_settings(args.authentication_token, args.notebook_guid, args.recipient_settings) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreSetNotebookRecipientSettingsResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreSetNotebookRecipientSettingsResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreSetNotebookRecipientSettingsResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreSetNotebookRecipientSettingsResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setNotebookRecipientSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_shared_notebooks<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListSharedNotebooksArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_shared_notebooks(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListSharedNotebooksResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListSharedNotebooksResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreListSharedNotebooksResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListSharedNotebooksResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listSharedNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_linked_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreCreateLinkedNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_linked_notebook(args.authentication_token, args.linked_notebook) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreCreateLinkedNotebookResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateLinkedNotebookResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateLinkedNotebookResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreCreateLinkedNotebookResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_linked_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateLinkedNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_linked_notebook(args.authentication_token, args.linked_notebook) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateLinkedNotebookResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateLinkedNotebookResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateLinkedNotebookResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateLinkedNotebookResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_linked_notebooks<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreListLinkedNotebooksArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_linked_notebooks(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreListLinkedNotebooksResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreListLinkedNotebooksResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreListLinkedNotebooksResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreListLinkedNotebooksResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listLinkedNotebooks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_expunge_linked_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreExpungeLinkedNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_expunge_linked_notebook(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreExpungeLinkedNotebookResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeLinkedNotebookResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeLinkedNotebookResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreExpungeLinkedNotebookResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("expungeLinkedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authenticate_to_shared_notebook<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreAuthenticateToSharedNotebookArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authenticate_to_shared_notebook(args.share_key_or_global_id, args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreAuthenticateToSharedNotebookResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreAuthenticateToSharedNotebookResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreAuthenticateToSharedNotebookResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreAuthenticateToSharedNotebookResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("authenticateToSharedNotebook", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_shared_notebook_by_auth<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetSharedNotebookByAuthArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_shared_notebook_by_auth(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetSharedNotebookByAuthResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSharedNotebookByAuthResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSharedNotebookByAuthResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetSharedNotebookByAuthResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getSharedNotebookByAuth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_email_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreEmailNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_email_note(args.authentication_token, args.parameters) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreEmailNoteResult { user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreEmailNoteResult{ user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreEmailNoteResult{ user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreEmailNoteResult{ user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("emailNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_share_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreShareNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_share_note(args.authentication_token, args.guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreShareNoteResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreShareNoteResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreShareNoteResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreShareNoteResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("shareNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_stop_sharing_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreStopSharingNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_stop_sharing_note(args.authentication_token, args.guid) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreStopSharingNoteResult { user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreStopSharingNoteResult{ user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreStopSharingNoteResult{ user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreStopSharingNoteResult{ user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("stopSharingNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authenticate_to_shared_note<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreAuthenticateToSharedNoteArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authenticate_to_shared_note(args.guid, args.note_key, args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreAuthenticateToSharedNoteResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreAuthenticateToSharedNoteResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreAuthenticateToSharedNoteResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreAuthenticateToSharedNoteResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("authenticateToSharedNote", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_find_related<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreFindRelatedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_find_related(args.authentication_token, args.query, args.result_spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreFindRelatedResult { result_value: Some(handler_return), user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreFindRelatedResult{ result_value: None, user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreFindRelatedResult{ result_value: None, user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreFindRelatedResult{ result_value: None, user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("findRelated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_note_if_usn_matches<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreUpdateNoteIfUsnMatchesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_note_if_usn_matches(args.authentication_token, args.note) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreUpdateNoteIfUsnMatchesResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNoteIfUsnMatchesResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNoteIfUsnMatchesResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreUpdateNoteIfUsnMatchesResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateNoteIfUsnMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_manage_notebook_shares<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreManageNotebookSharesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_manage_notebook_shares(args.authentication_token, args.parameters) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreManageNotebookSharesResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreManageNotebookSharesResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreManageNotebookSharesResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreManageNotebookSharesResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("manageNotebookShares", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_notebook_shares<H: NoteStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = NoteStoreGetNotebookSharesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_notebook_shares(args.authentication_token, args.notebook_guid) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = NoteStoreGetNotebookSharesResult { result_value: Some(handler_return), user_exception: None, not_found_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNotebookSharesResult{ result_value: None, user_exception: Some(*err), not_found_exception: None, system_exception: None };
              let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNotebookSharesResult{ result_value: None, user_exception: None, not_found_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = NoteStoreGetNotebookSharesResult{ result_value: None, user_exception: None, not_found_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getNotebookShares", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: NoteStoreSyncHandler> TProcessor for NoteStoreSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "getSyncState" => {
        self.process_get_sync_state(message_ident.sequence_number, i_prot, o_prot)
      },
      "getFilteredSyncChunk" => {
        self.process_get_filtered_sync_chunk(message_ident.sequence_number, i_prot, o_prot)
      },
      "getLinkedNotebookSyncState" => {
        self.process_get_linked_notebook_sync_state(message_ident.sequence_number, i_prot, o_prot)
      },
      "getLinkedNotebookSyncChunk" => {
        self.process_get_linked_notebook_sync_chunk(message_ident.sequence_number, i_prot, o_prot)
      },
      "listNotebooks" => {
        self.process_list_notebooks(message_ident.sequence_number, i_prot, o_prot)
      },
      "listAccessibleBusinessNotebooks" => {
        self.process_list_accessible_business_notebooks(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNotebook" => {
        self.process_get_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "getDefaultNotebook" => {
        self.process_get_default_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "createNotebook" => {
        self.process_create_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateNotebook" => {
        self.process_update_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "expungeNotebook" => {
        self.process_expunge_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "listTags" => {
        self.process_list_tags(message_ident.sequence_number, i_prot, o_prot)
      },
      "listTagsByNotebook" => {
        self.process_list_tags_by_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "getTag" => {
        self.process_get_tag(message_ident.sequence_number, i_prot, o_prot)
      },
      "createTag" => {
        self.process_create_tag(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateTag" => {
        self.process_update_tag(message_ident.sequence_number, i_prot, o_prot)
      },
      "untagAll" => {
        self.process_untag_all(message_ident.sequence_number, i_prot, o_prot)
      },
      "expungeTag" => {
        self.process_expunge_tag(message_ident.sequence_number, i_prot, o_prot)
      },
      "listSearches" => {
        self.process_list_searches(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSearch" => {
        self.process_get_search(message_ident.sequence_number, i_prot, o_prot)
      },
      "createSearch" => {
        self.process_create_search(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateSearch" => {
        self.process_update_search(message_ident.sequence_number, i_prot, o_prot)
      },
      "expungeSearch" => {
        self.process_expunge_search(message_ident.sequence_number, i_prot, o_prot)
      },
      "findNoteOffset" => {
        self.process_find_note_offset(message_ident.sequence_number, i_prot, o_prot)
      },
      "findNotesMetadata" => {
        self.process_find_notes_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "findNoteCounts" => {
        self.process_find_note_counts(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNoteWithResultSpec" => {
        self.process_get_note_with_result_spec(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNote" => {
        self.process_get_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNoteApplicationData" => {
        self.process_get_note_application_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNoteApplicationDataEntry" => {
        self.process_get_note_application_data_entry(message_ident.sequence_number, i_prot, o_prot)
      },
      "setNoteApplicationDataEntry" => {
        self.process_set_note_application_data_entry(message_ident.sequence_number, i_prot, o_prot)
      },
      "unsetNoteApplicationDataEntry" => {
        self.process_unset_note_application_data_entry(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNoteContent" => {
        self.process_get_note_content(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNoteSearchText" => {
        self.process_get_note_search_text(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceSearchText" => {
        self.process_get_resource_search_text(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNoteTagNames" => {
        self.process_get_note_tag_names(message_ident.sequence_number, i_prot, o_prot)
      },
      "createNote" => {
        self.process_create_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateNote" => {
        self.process_update_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "deleteNote" => {
        self.process_delete_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "expungeNote" => {
        self.process_expunge_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "copyNote" => {
        self.process_copy_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "listNoteVersions" => {
        self.process_list_note_versions(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNoteVersion" => {
        self.process_get_note_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResource" => {
        self.process_get_resource(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceApplicationData" => {
        self.process_get_resource_application_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceApplicationDataEntry" => {
        self.process_get_resource_application_data_entry(message_ident.sequence_number, i_prot, o_prot)
      },
      "setResourceApplicationDataEntry" => {
        self.process_set_resource_application_data_entry(message_ident.sequence_number, i_prot, o_prot)
      },
      "unsetResourceApplicationDataEntry" => {
        self.process_unset_resource_application_data_entry(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateResource" => {
        self.process_update_resource(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceData" => {
        self.process_get_resource_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceByHash" => {
        self.process_get_resource_by_hash(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceRecognition" => {
        self.process_get_resource_recognition(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceAlternateData" => {
        self.process_get_resource_alternate_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "getResourceAttributes" => {
        self.process_get_resource_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPublicNotebook" => {
        self.process_get_public_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "shareNotebook" => {
        self.process_share_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "createOrUpdateNotebookShares" => {
        self.process_create_or_update_notebook_shares(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateSharedNotebook" => {
        self.process_update_shared_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "setNotebookRecipientSettings" => {
        self.process_set_notebook_recipient_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "listSharedNotebooks" => {
        self.process_list_shared_notebooks(message_ident.sequence_number, i_prot, o_prot)
      },
      "createLinkedNotebook" => {
        self.process_create_linked_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateLinkedNotebook" => {
        self.process_update_linked_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "listLinkedNotebooks" => {
        self.process_list_linked_notebooks(message_ident.sequence_number, i_prot, o_prot)
      },
      "expungeLinkedNotebook" => {
        self.process_expunge_linked_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "authenticateToSharedNotebook" => {
        self.process_authenticate_to_shared_notebook(message_ident.sequence_number, i_prot, o_prot)
      },
      "getSharedNotebookByAuth" => {
        self.process_get_shared_notebook_by_auth(message_ident.sequence_number, i_prot, o_prot)
      },
      "emailNote" => {
        self.process_email_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "shareNote" => {
        self.process_share_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "stopSharingNote" => {
        self.process_stop_sharing_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "authenticateToSharedNote" => {
        self.process_authenticate_to_shared_note(message_ident.sequence_number, i_prot, o_prot)
      },
      "findRelated" => {
        self.process_find_related(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateNoteIfUsnMatches" => {
        self.process_update_note_if_usn_matches(message_ident.sequence_number, i_prot, o_prot)
      },
      "manageNotebookShares" => {
        self.process_manage_notebook_shares(message_ident.sequence_number, i_prot, o_prot)
      },
      "getNotebookShares" => {
        self.process_get_notebook_shares(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// NoteStoreGetSyncStateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetSyncStateArgs {
  authentication_token: String,
}

impl NoteStoreGetSyncStateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetSyncStateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetSyncStateArgs.authentication_token", &f_1)?;
    let ret = NoteStoreGetSyncStateArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSyncState_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetSyncStateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetSyncStateResult {
  result_value: Option<SyncState>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreGetSyncStateResult {
  fn ok_or(self) -> thrift::Result<SyncState> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetSyncState"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetSyncStateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SyncState> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SyncState::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetSyncStateResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetSyncStateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetFilteredSyncChunkArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetFilteredSyncChunkArgs {
  authentication_token: String,
  after_u_s_n: i32,
  max_entries: i32,
  filter: SyncChunkFilter,
}

impl NoteStoreGetFilteredSyncChunkArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetFilteredSyncChunkArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<SyncChunkFilter> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = SyncChunkFilter::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetFilteredSyncChunkArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetFilteredSyncChunkArgs.after_u_s_n", &f_2)?;
    verify_required_field_exists("NoteStoreGetFilteredSyncChunkArgs.max_entries", &f_3)?;
    verify_required_field_exists("NoteStoreGetFilteredSyncChunkArgs.filter", &f_4)?;
    let ret = NoteStoreGetFilteredSyncChunkArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      after_u_s_n: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_entries: f_3.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getFilteredSyncChunk_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("afterUSN", TType::I32, 2))?;
    o_prot.write_i32(self.after_u_s_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxEntries", TType::I32, 3))?;
    o_prot.write_i32(self.max_entries)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::Struct, 4))?;
    self.filter.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetFilteredSyncChunkResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetFilteredSyncChunkResult {
  result_value: Option<SyncChunk>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreGetFilteredSyncChunkResult {
  fn ok_or(self) -> thrift::Result<SyncChunk> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetFilteredSyncChunk"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetFilteredSyncChunkResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SyncChunk> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SyncChunk::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetFilteredSyncChunkResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetFilteredSyncChunkResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetLinkedNotebookSyncStateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetLinkedNotebookSyncStateArgs {
  authentication_token: String,
  linked_notebook: types::LinkedNotebook,
}

impl NoteStoreGetLinkedNotebookSyncStateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetLinkedNotebookSyncStateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::LinkedNotebook> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::LinkedNotebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetLinkedNotebookSyncStateArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetLinkedNotebookSyncStateArgs.linked_notebook", &f_2)?;
    let ret = NoteStoreGetLinkedNotebookSyncStateArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      linked_notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getLinkedNotebookSyncState_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("linkedNotebook", TType::Struct, 2))?;
    self.linked_notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetLinkedNotebookSyncStateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetLinkedNotebookSyncStateResult {
  result_value: Option<SyncState>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetLinkedNotebookSyncStateResult {
  fn ok_or(self) -> thrift::Result<SyncState> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetLinkedNotebookSyncState"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetLinkedNotebookSyncStateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SyncState> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SyncState::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetLinkedNotebookSyncStateResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetLinkedNotebookSyncStateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetLinkedNotebookSyncChunkArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetLinkedNotebookSyncChunkArgs {
  authentication_token: String,
  linked_notebook: types::LinkedNotebook,
  after_u_s_n: i32,
  max_entries: i32,
  full_sync_only: bool,
}

impl NoteStoreGetLinkedNotebookSyncChunkArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetLinkedNotebookSyncChunkArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::LinkedNotebook> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::LinkedNotebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetLinkedNotebookSyncChunkArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetLinkedNotebookSyncChunkArgs.linked_notebook", &f_2)?;
    verify_required_field_exists("NoteStoreGetLinkedNotebookSyncChunkArgs.after_u_s_n", &f_3)?;
    verify_required_field_exists("NoteStoreGetLinkedNotebookSyncChunkArgs.max_entries", &f_4)?;
    verify_required_field_exists("NoteStoreGetLinkedNotebookSyncChunkArgs.full_sync_only", &f_5)?;
    let ret = NoteStoreGetLinkedNotebookSyncChunkArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      linked_notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
      after_u_s_n: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_entries: f_4.expect("auto-generated code should have checked for presence of required fields"),
      full_sync_only: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getLinkedNotebookSyncChunk_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("linkedNotebook", TType::Struct, 2))?;
    self.linked_notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("afterUSN", TType::I32, 3))?;
    o_prot.write_i32(self.after_u_s_n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxEntries", TType::I32, 4))?;
    o_prot.write_i32(self.max_entries)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fullSyncOnly", TType::Bool, 5))?;
    o_prot.write_bool(self.full_sync_only)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetLinkedNotebookSyncChunkResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetLinkedNotebookSyncChunkResult {
  result_value: Option<SyncChunk>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetLinkedNotebookSyncChunkResult {
  fn ok_or(self) -> thrift::Result<SyncChunk> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetLinkedNotebookSyncChunk"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetLinkedNotebookSyncChunkResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SyncChunk> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SyncChunk::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetLinkedNotebookSyncChunkResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetLinkedNotebookSyncChunkResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListNotebooksArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListNotebooksArgs {
  authentication_token: String,
}

impl NoteStoreListNotebooksArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListNotebooksArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListNotebooksArgs.authentication_token", &f_1)?;
    let ret = NoteStoreListNotebooksArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listNotebooks_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListNotebooksResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListNotebooksResult {
  result_value: Option<Vec<types::Notebook>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreListNotebooksResult {
  pub fn ok_or(self) -> thrift::Result<Vec<types::Notebook>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListNotebooks"
          )
        )
      )
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListNotebooksResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::Notebook>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Notebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = types::Notebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListNotebooksResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListNotebooksResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListAccessibleBusinessNotebooksArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListAccessibleBusinessNotebooksArgs {
  authentication_token: String,
}

impl NoteStoreListAccessibleBusinessNotebooksArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListAccessibleBusinessNotebooksArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListAccessibleBusinessNotebooksArgs.authentication_token", &f_1)?;
    let ret = NoteStoreListAccessibleBusinessNotebooksArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listAccessibleBusinessNotebooks_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListAccessibleBusinessNotebooksResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListAccessibleBusinessNotebooksResult {
  result_value: Option<Vec<types::Notebook>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreListAccessibleBusinessNotebooksResult {
  fn ok_or(self) -> thrift::Result<Vec<types::Notebook>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListAccessibleBusinessNotebooks"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListAccessibleBusinessNotebooksResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::Notebook>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Notebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = types::Notebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListAccessibleBusinessNotebooksResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListAccessibleBusinessNotebooksResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNotebookArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNotebookArgs.guid", &f_2)?;
    let ret = NoteStoreGetNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNotebookResult {
  result_value: Option<types::Notebook>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNotebookResult {
  fn ok_or(self) -> thrift::Result<types::Notebook> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Notebook> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Notebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetDefaultNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetDefaultNotebookArgs {
  authentication_token: String,
}

impl NoteStoreGetDefaultNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetDefaultNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetDefaultNotebookArgs.authentication_token", &f_1)?;
    let ret = NoteStoreGetDefaultNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getDefaultNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetDefaultNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetDefaultNotebookResult {
  result_value: Option<types::Notebook>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreGetDefaultNotebookResult {
  fn ok_or(self) -> thrift::Result<types::Notebook> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetDefaultNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetDefaultNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Notebook> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Notebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetDefaultNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetDefaultNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateNotebookArgs {
  authentication_token: String,
  notebook: types::Notebook,
}

impl NoteStoreCreateNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Notebook> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Notebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreCreateNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreCreateNotebookArgs.notebook", &f_2)?;
    let ret = NoteStoreCreateNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notebook", TType::Struct, 2))?;
    self.notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateNotebookResult {
  result_value: Option<types::Notebook>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreCreateNotebookResult {
  fn ok_or(self) -> thrift::Result<types::Notebook> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreCreateNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Notebook> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Notebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreCreateNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreCreateNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateNotebookArgs {
  authentication_token: String,
  notebook: types::Notebook,
}

impl NoteStoreUpdateNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Notebook> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Notebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateNotebookArgs.notebook", &f_2)?;
    let ret = NoteStoreUpdateNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notebook", TType::Struct, 2))?;
    self.notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateNotebookResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUpdateNotebookResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeNotebookArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreExpungeNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreExpungeNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreExpungeNotebookArgs.guid", &f_2)?;
    let ret = NoteStoreExpungeNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("expungeNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeNotebookResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreExpungeNotebookResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreExpungeNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreExpungeNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreExpungeNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListTagsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListTagsArgs {
  authentication_token: String,
}

impl NoteStoreListTagsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListTagsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListTagsArgs.authentication_token", &f_1)?;
    let ret = NoteStoreListTagsArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listTags_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListTagsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListTagsResult {
  result_value: Option<Vec<types::Tag>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreListTagsResult {
  fn ok_or(self) -> thrift::Result<Vec<types::Tag>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListTags"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListTagsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::Tag>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Tag> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = types::Tag::read_from_in_protocol(i_prot)?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListTagsResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListTagsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListTagsByNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListTagsByNotebookArgs {
  authentication_token: String,
  notebook_guid: types::Guid,
}

impl NoteStoreListTagsByNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListTagsByNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListTagsByNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreListTagsByNotebookArgs.notebook_guid", &f_2)?;
    let ret = NoteStoreListTagsByNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notebook_guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listTagsByNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 2))?;
    o_prot.write_string(&self.notebook_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListTagsByNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListTagsByNotebookResult {
  result_value: Option<Vec<types::Tag>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreListTagsByNotebookResult {
  fn ok_or(self) -> thrift::Result<Vec<types::Tag>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListTagsByNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListTagsByNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::Tag>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::Tag> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_52 = types::Tag::read_from_in_protocol(i_prot)?;
            val.push(list_elem_52);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListTagsByNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListTagsByNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetTagArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetTagArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetTagArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetTagArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetTagArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetTagArgs.guid", &f_2)?;
    let ret = NoteStoreGetTagArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getTag_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetTagResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetTagResult {
  result_value: Option<types::Tag>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetTagResult {
  fn ok_or(self) -> thrift::Result<types::Tag> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetTag"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetTagResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Tag> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Tag::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetTagResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetTagResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateTagArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateTagArgs {
  authentication_token: String,
  tag: types::Tag,
}

impl NoteStoreCreateTagArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateTagArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Tag> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Tag::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreCreateTagArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreCreateTagArgs.tag", &f_2)?;
    let ret = NoteStoreCreateTagArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tag: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createTag_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tag", TType::Struct, 2))?;
    self.tag.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateTagResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateTagResult {
  result_value: Option<types::Tag>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreCreateTagResult {
  fn ok_or(self) -> thrift::Result<types::Tag> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreCreateTag"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateTagResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Tag> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Tag::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreCreateTagResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreCreateTagResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateTagArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateTagArgs {
  authentication_token: String,
  tag: types::Tag,
}

impl NoteStoreUpdateTagArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateTagArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Tag> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Tag::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateTagArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateTagArgs.tag", &f_2)?;
    let ret = NoteStoreUpdateTagArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tag: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateTag_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tag", TType::Struct, 2))?;
    self.tag.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateTagResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateTagResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUpdateTagResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateTag"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateTagResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateTagResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateTagResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUntagAllArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUntagAllArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreUntagAllArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUntagAllArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUntagAllArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUntagAllArgs.guid", &f_2)?;
    let ret = NoteStoreUntagAllArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("untagAll_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUntagAllResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUntagAllResult {
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUntagAllResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUntagAllResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUntagAllResult {
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUntagAllResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeTagArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeTagArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreExpungeTagArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeTagArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreExpungeTagArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreExpungeTagArgs.guid", &f_2)?;
    let ret = NoteStoreExpungeTagArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("expungeTag_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeTagResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeTagResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreExpungeTagResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreExpungeTag"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeTagResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreExpungeTagResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreExpungeTagResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListSearchesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListSearchesArgs {
  authentication_token: String,
}

impl NoteStoreListSearchesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListSearchesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListSearchesArgs.authentication_token", &f_1)?;
    let ret = NoteStoreListSearchesArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listSearches_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListSearchesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListSearchesResult {
  result_value: Option<Vec<types::SavedSearch>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreListSearchesResult {
  fn ok_or(self) -> thrift::Result<Vec<types::SavedSearch>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListSearches"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListSearchesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::SavedSearch>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::SavedSearch> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_53 = types::SavedSearch::read_from_in_protocol(i_prot)?;
            val.push(list_elem_53);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListSearchesResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListSearchesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetSearchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetSearchArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetSearchArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetSearchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetSearchArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetSearchArgs.guid", &f_2)?;
    let ret = NoteStoreGetSearchArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSearch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetSearchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetSearchResult {
  result_value: Option<types::SavedSearch>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetSearchResult {
  fn ok_or(self) -> thrift::Result<types::SavedSearch> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetSearch"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetSearchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::SavedSearch> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::SavedSearch::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetSearchResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetSearchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateSearchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateSearchArgs {
  authentication_token: String,
  search: types::SavedSearch,
}

impl NoteStoreCreateSearchArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateSearchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::SavedSearch> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::SavedSearch::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreCreateSearchArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreCreateSearchArgs.search", &f_2)?;
    let ret = NoteStoreCreateSearchArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      search: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createSearch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("search", TType::Struct, 2))?;
    self.search.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateSearchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateSearchResult {
  result_value: Option<types::SavedSearch>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreCreateSearchResult {
  fn ok_or(self) -> thrift::Result<types::SavedSearch> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreCreateSearch"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateSearchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::SavedSearch> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::SavedSearch::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreCreateSearchResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreCreateSearchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateSearchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateSearchArgs {
  authentication_token: String,
  search: types::SavedSearch,
}

impl NoteStoreUpdateSearchArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateSearchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::SavedSearch> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::SavedSearch::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateSearchArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateSearchArgs.search", &f_2)?;
    let ret = NoteStoreUpdateSearchArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      search: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateSearch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("search", TType::Struct, 2))?;
    self.search.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateSearchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateSearchResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUpdateSearchResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateSearch"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateSearchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateSearchResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateSearchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeSearchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeSearchArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreExpungeSearchArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeSearchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreExpungeSearchArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreExpungeSearchArgs.guid", &f_2)?;
    let ret = NoteStoreExpungeSearchArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("expungeSearch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeSearchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeSearchResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreExpungeSearchResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreExpungeSearch"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeSearchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreExpungeSearchResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreExpungeSearchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindNoteOffsetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindNoteOffsetArgs {
  authentication_token: String,
  filter: NoteFilter,
  guid: types::Guid,
}

impl NoteStoreFindNoteOffsetArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindNoteOffsetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<NoteFilter> = None;
    let mut f_3: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoteFilter::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreFindNoteOffsetArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreFindNoteOffsetArgs.filter", &f_2)?;
    verify_required_field_exists("NoteStoreFindNoteOffsetArgs.guid", &f_3)?;
    let ret = NoteStoreFindNoteOffsetArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_2.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findNoteOffset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::Struct, 2))?;
    self.filter.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 3))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindNoteOffsetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindNoteOffsetResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreFindNoteOffsetResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreFindNoteOffset"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindNoteOffsetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreFindNoteOffsetResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreFindNoteOffsetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindNotesMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindNotesMetadataArgs {
  authentication_token: String,
  filter: NoteFilter,
  offset: i32,
  max_notes: i32,
  result_spec: NotesMetadataResultSpec,
}

impl NoteStoreFindNotesMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindNotesMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<NoteFilter> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<NotesMetadataResultSpec> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoteFilter::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = NotesMetadataResultSpec::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreFindNotesMetadataArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreFindNotesMetadataArgs.filter", &f_2)?;
    verify_required_field_exists("NoteStoreFindNotesMetadataArgs.offset", &f_3)?;
    verify_required_field_exists("NoteStoreFindNotesMetadataArgs.max_notes", &f_4)?;
    verify_required_field_exists("NoteStoreFindNotesMetadataArgs.result_spec", &f_5)?;
    let ret = NoteStoreFindNotesMetadataArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_2.expect("auto-generated code should have checked for presence of required fields"),
      offset: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_notes: f_4.expect("auto-generated code should have checked for presence of required fields"),
      result_spec: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findNotesMetadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::Struct, 2))?;
    self.filter.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("offset", TType::I32, 3))?;
    o_prot.write_i32(self.offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxNotes", TType::I32, 4))?;
    o_prot.write_i32(self.max_notes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resultSpec", TType::Struct, 5))?;
    self.result_spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindNotesMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindNotesMetadataResult {
  result_value: Option<NotesMetadataList>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreFindNotesMetadataResult {
  fn ok_or(self) -> thrift::Result<NotesMetadataList> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreFindNotesMetadata"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindNotesMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NotesMetadataList> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NotesMetadataList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreFindNotesMetadataResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreFindNotesMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindNoteCountsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindNoteCountsArgs {
  authentication_token: String,
  filter: NoteFilter,
  with_trash: bool,
}

impl NoteStoreFindNoteCountsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindNoteCountsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<NoteFilter> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoteFilter::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreFindNoteCountsArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreFindNoteCountsArgs.filter", &f_2)?;
    verify_required_field_exists("NoteStoreFindNoteCountsArgs.with_trash", &f_3)?;
    let ret = NoteStoreFindNoteCountsArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_2.expect("auto-generated code should have checked for presence of required fields"),
      with_trash: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findNoteCounts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::Struct, 2))?;
    self.filter.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withTrash", TType::Bool, 3))?;
    o_prot.write_bool(self.with_trash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindNoteCountsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindNoteCountsResult {
  result_value: Option<NoteCollectionCounts>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreFindNoteCountsResult {
  fn ok_or(self) -> thrift::Result<NoteCollectionCounts> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreFindNoteCounts"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindNoteCountsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NoteCollectionCounts> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NoteCollectionCounts::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreFindNoteCountsResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreFindNoteCountsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteWithResultSpecArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteWithResultSpecArgs {
  authentication_token: String,
  guid: types::Guid,
  result_spec: NoteResultSpec,
}

impl NoteStoreGetNoteWithResultSpecArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteWithResultSpecArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<NoteResultSpec> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = NoteResultSpec::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteWithResultSpecArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteWithResultSpecArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetNoteWithResultSpecArgs.result_spec", &f_3)?;
    let ret = NoteStoreGetNoteWithResultSpecArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      result_spec: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNoteWithResultSpec_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resultSpec", TType::Struct, 3))?;
    self.result_spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteWithResultSpecResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteWithResultSpecResult {
  result_value: Option<types::Note>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteWithResultSpecResult {
  fn ok_or(self) -> thrift::Result<types::Note> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNoteWithSpecResult"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteWithResultSpecResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Note> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteWithResultSpecResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteWithResultSpecResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteArgs {
  authentication_token: String,
  guid: types::Guid,
  with_content: bool,
  with_resources_data: bool,
  with_resources_recognition: bool,
  with_resources_alternate_data: bool,
}

impl NoteStoreGetNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetNoteArgs.with_content", &f_3)?;
    verify_required_field_exists("NoteStoreGetNoteArgs.with_resources_data", &f_4)?;
    verify_required_field_exists("NoteStoreGetNoteArgs.with_resources_recognition", &f_5)?;
    verify_required_field_exists("NoteStoreGetNoteArgs.with_resources_alternate_data", &f_6)?;
    let ret = NoteStoreGetNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      with_content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      with_resources_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      with_resources_recognition: f_5.expect("auto-generated code should have checked for presence of required fields"),
      with_resources_alternate_data: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withContent", TType::Bool, 3))?;
    o_prot.write_bool(self.with_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withResourcesData", TType::Bool, 4))?;
    o_prot.write_bool(self.with_resources_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withResourcesRecognition", TType::Bool, 5))?;
    o_prot.write_bool(self.with_resources_recognition)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withResourcesAlternateData", TType::Bool, 6))?;
    o_prot.write_bool(self.with_resources_alternate_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteResult {
  result_value: Option<types::Note>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteResult {
  fn ok_or(self) -> thrift::Result<types::Note> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Note> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteApplicationDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteApplicationDataArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetNoteApplicationDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteApplicationDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteApplicationDataArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteApplicationDataArgs.guid", &f_2)?;
    let ret = NoteStoreGetNoteApplicationDataArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNoteApplicationData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteApplicationDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteApplicationDataResult {
  result_value: Option<types::LazyMap>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteApplicationDataResult {
  fn ok_or(self) -> thrift::Result<types::LazyMap> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNoteApplicationData"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteApplicationDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::LazyMap> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::LazyMap::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteApplicationDataResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteApplicationDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteApplicationDataEntryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteApplicationDataEntryArgs {
  authentication_token: String,
  guid: types::Guid,
  key: String,
}

impl NoteStoreGetNoteApplicationDataEntryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteApplicationDataEntryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteApplicationDataEntryArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteApplicationDataEntryArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetNoteApplicationDataEntryArgs.key", &f_3)?;
    let ret = NoteStoreGetNoteApplicationDataEntryArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      key: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNoteApplicationDataEntry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 3))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteApplicationDataEntryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteApplicationDataEntryResult {
  result_value: Option<String>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteApplicationDataEntryResult {
  fn ok_or(self) -> thrift::Result<String> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNoteApplicationDataEntry"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteApplicationDataEntryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteApplicationDataEntryResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteApplicationDataEntryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreSetNoteApplicationDataEntryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreSetNoteApplicationDataEntryArgs {
  authentication_token: String,
  guid: types::Guid,
  key: String,
  value: String,
}

impl NoteStoreSetNoteApplicationDataEntryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreSetNoteApplicationDataEntryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreSetNoteApplicationDataEntryArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreSetNoteApplicationDataEntryArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreSetNoteApplicationDataEntryArgs.key", &f_3)?;
    verify_required_field_exists("NoteStoreSetNoteApplicationDataEntryArgs.value", &f_4)?;
    let ret = NoteStoreSetNoteApplicationDataEntryArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      key: f_3.expect("auto-generated code should have checked for presence of required fields"),
      value: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setNoteApplicationDataEntry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 3))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 4))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreSetNoteApplicationDataEntryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreSetNoteApplicationDataEntryResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreSetNoteApplicationDataEntryResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreSetNoteApplicationDataEntry"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreSetNoteApplicationDataEntryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreSetNoteApplicationDataEntryResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreSetNoteApplicationDataEntryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUnsetNoteApplicationDataEntryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUnsetNoteApplicationDataEntryArgs {
  authentication_token: String,
  guid: types::Guid,
  key: String,
}

impl NoteStoreUnsetNoteApplicationDataEntryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUnsetNoteApplicationDataEntryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUnsetNoteApplicationDataEntryArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUnsetNoteApplicationDataEntryArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreUnsetNoteApplicationDataEntryArgs.key", &f_3)?;
    let ret = NoteStoreUnsetNoteApplicationDataEntryArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      key: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unsetNoteApplicationDataEntry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 3))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUnsetNoteApplicationDataEntryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUnsetNoteApplicationDataEntryResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUnsetNoteApplicationDataEntryResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUnsetNoteApplicationDataEntry"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUnsetNoteApplicationDataEntryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUnsetNoteApplicationDataEntryResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUnsetNoteApplicationDataEntryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteContentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteContentArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetNoteContentArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteContentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteContentArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteContentArgs.guid", &f_2)?;
    let ret = NoteStoreGetNoteContentArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNoteContent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteContentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteContentResult {
  result_value: Option<String>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteContentResult {
  fn ok_or(self) -> thrift::Result<String> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNoteContent"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteContentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteContentResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteContentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteSearchTextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteSearchTextArgs {
  authentication_token: String,
  guid: types::Guid,
  note_only: bool,
  tokenize_for_indexing: bool,
}

impl NoteStoreGetNoteSearchTextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteSearchTextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteSearchTextArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteSearchTextArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetNoteSearchTextArgs.note_only", &f_3)?;
    verify_required_field_exists("NoteStoreGetNoteSearchTextArgs.tokenize_for_indexing", &f_4)?;
    let ret = NoteStoreGetNoteSearchTextArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      note_only: f_3.expect("auto-generated code should have checked for presence of required fields"),
      tokenize_for_indexing: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNoteSearchText_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("noteOnly", TType::Bool, 3))?;
    o_prot.write_bool(self.note_only)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tokenizeForIndexing", TType::Bool, 4))?;
    o_prot.write_bool(self.tokenize_for_indexing)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteSearchTextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteSearchTextResult {
  result_value: Option<String>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteSearchTextResult {
  fn ok_or(self) -> thrift::Result<String> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNoteSearchText"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteSearchTextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteSearchTextResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteSearchTextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceSearchTextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceSearchTextArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetResourceSearchTextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceSearchTextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceSearchTextArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceSearchTextArgs.guid", &f_2)?;
    let ret = NoteStoreGetResourceSearchTextArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceSearchText_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceSearchTextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceSearchTextResult {
  result_value: Option<String>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceSearchTextResult {
  fn ok_or(self) -> thrift::Result<String> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceSearchText"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceSearchTextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceSearchTextResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceSearchTextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteTagNamesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteTagNamesArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetNoteTagNamesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteTagNamesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteTagNamesArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteTagNamesArgs.guid", &f_2)?;
    let ret = NoteStoreGetNoteTagNamesArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNoteTagNames_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteTagNamesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteTagNamesResult {
  result_value: Option<Vec<String>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteTagNamesResult {
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNoteTagNames"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteTagNamesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = i_prot.read_string()?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteTagNamesResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteTagNamesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateNoteArgs {
  authentication_token: String,
  note: types::Note,
}

impl NoteStoreCreateNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Note> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreCreateNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreCreateNoteArgs.note", &f_2)?;
    let ret = NoteStoreCreateNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("note", TType::Struct, 2))?;
    self.note.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateNoteResult {
  result_value: Option<types::Note>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreCreateNoteResult {
  fn ok_or(self) -> thrift::Result<types::Note> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreCreateNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Note> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreCreateNoteResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreCreateNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateNoteArgs {
  authentication_token: String,
  note: types::Note,
}

impl NoteStoreUpdateNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Note> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateNoteArgs.note", &f_2)?;
    let ret = NoteStoreUpdateNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("note", TType::Struct, 2))?;
    self.note.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateNoteResult {
  result_value: Option<types::Note>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUpdateNoteResult {
  fn ok_or(self) -> thrift::Result<types::Note> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Note> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateNoteResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreDeleteNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreDeleteNoteArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreDeleteNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreDeleteNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreDeleteNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreDeleteNoteArgs.guid", &f_2)?;
    let ret = NoteStoreDeleteNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deleteNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreDeleteNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreDeleteNoteResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreDeleteNoteResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreDeleteNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreDeleteNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreDeleteNoteResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreDeleteNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeNoteArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreExpungeNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreExpungeNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreExpungeNoteArgs.guid", &f_2)?;
    let ret = NoteStoreExpungeNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("expungeNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeNoteResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreExpungeNoteResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreExpungeNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreExpungeNoteResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreExpungeNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCopyNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCopyNoteArgs {
  authentication_token: String,
  note_guid: types::Guid,
  to_notebook_guid: types::Guid,
}

impl NoteStoreCopyNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCopyNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreCopyNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreCopyNoteArgs.note_guid", &f_2)?;
    verify_required_field_exists("NoteStoreCopyNoteArgs.to_notebook_guid", &f_3)?;
    let ret = NoteStoreCopyNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note_guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      to_notebook_guid: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("copyNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 2))?;
    o_prot.write_string(&self.note_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toNotebookGuid", TType::String, 3))?;
    o_prot.write_string(&self.to_notebook_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCopyNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCopyNoteResult {
  result_value: Option<types::Note>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreCopyNoteResult {
  fn ok_or(self) -> thrift::Result<types::Note> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreCopyNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCopyNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Note> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreCopyNoteResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreCopyNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListNoteVersionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListNoteVersionsArgs {
  authentication_token: String,
  note_guid: types::Guid,
}

impl NoteStoreListNoteVersionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListNoteVersionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListNoteVersionsArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreListNoteVersionsArgs.note_guid", &f_2)?;
    let ret = NoteStoreListNoteVersionsArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note_guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listNoteVersions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 2))?;
    o_prot.write_string(&self.note_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListNoteVersionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListNoteVersionsResult {
  result_value: Option<Vec<NoteVersionId>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreListNoteVersionsResult {
  fn ok_or(self) -> thrift::Result<Vec<NoteVersionId>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListNoteVersions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListNoteVersionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<NoteVersionId>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NoteVersionId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = NoteVersionId::read_from_in_protocol(i_prot)?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListNoteVersionsResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListNoteVersionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteVersionArgs {
  authentication_token: String,
  note_guid: types::Guid,
  update_sequence_num: i32,
  with_resources_data: bool,
  with_resources_recognition: bool,
  with_resources_alternate_data: bool,
}

impl NoteStoreGetNoteVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNoteVersionArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNoteVersionArgs.note_guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetNoteVersionArgs.update_sequence_num", &f_3)?;
    verify_required_field_exists("NoteStoreGetNoteVersionArgs.with_resources_data", &f_4)?;
    verify_required_field_exists("NoteStoreGetNoteVersionArgs.with_resources_recognition", &f_5)?;
    verify_required_field_exists("NoteStoreGetNoteVersionArgs.with_resources_alternate_data", &f_6)?;
    let ret = NoteStoreGetNoteVersionArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note_guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      update_sequence_num: f_3.expect("auto-generated code should have checked for presence of required fields"),
      with_resources_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      with_resources_recognition: f_5.expect("auto-generated code should have checked for presence of required fields"),
      with_resources_alternate_data: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNoteVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 2))?;
    o_prot.write_string(&self.note_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 3))?;
    o_prot.write_i32(self.update_sequence_num)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withResourcesData", TType::Bool, 4))?;
    o_prot.write_bool(self.with_resources_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withResourcesRecognition", TType::Bool, 5))?;
    o_prot.write_bool(self.with_resources_recognition)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withResourcesAlternateData", TType::Bool, 6))?;
    o_prot.write_bool(self.with_resources_alternate_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNoteVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNoteVersionResult {
  result_value: Option<types::Note>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetNoteVersionResult {
  fn ok_or(self) -> thrift::Result<types::Note> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNoteVersion"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNoteVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Note> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNoteVersionResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNoteVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceArgs {
  authentication_token: String,
  guid: types::Guid,
  with_data: bool,
  with_recognition: bool,
  with_attributes: bool,
  with_alternate_data: bool,
}

impl NoteStoreGetResourceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetResourceArgs.with_data", &f_3)?;
    verify_required_field_exists("NoteStoreGetResourceArgs.with_recognition", &f_4)?;
    verify_required_field_exists("NoteStoreGetResourceArgs.with_attributes", &f_5)?;
    verify_required_field_exists("NoteStoreGetResourceArgs.with_alternate_data", &f_6)?;
    let ret = NoteStoreGetResourceArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      with_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      with_recognition: f_4.expect("auto-generated code should have checked for presence of required fields"),
      with_attributes: f_5.expect("auto-generated code should have checked for presence of required fields"),
      with_alternate_data: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResource_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withData", TType::Bool, 3))?;
    o_prot.write_bool(self.with_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withRecognition", TType::Bool, 4))?;
    o_prot.write_bool(self.with_recognition)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withAttributes", TType::Bool, 5))?;
    o_prot.write_bool(self.with_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withAlternateData", TType::Bool, 6))?;
    o_prot.write_bool(self.with_alternate_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceResult {
  result_value: Option<types::Resource>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceResult {
  fn ok_or(self) -> thrift::Result<types::Resource> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResource"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Resource> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Resource::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceApplicationDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceApplicationDataArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetResourceApplicationDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceApplicationDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceApplicationDataArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceApplicationDataArgs.guid", &f_2)?;
    let ret = NoteStoreGetResourceApplicationDataArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceApplicationData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceApplicationDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceApplicationDataResult {
  result_value: Option<types::LazyMap>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceApplicationDataResult {
  fn ok_or(self) -> thrift::Result<types::LazyMap> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceApplicationData"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceApplicationDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::LazyMap> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::LazyMap::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceApplicationDataResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceApplicationDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceApplicationDataEntryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceApplicationDataEntryArgs {
  authentication_token: String,
  guid: types::Guid,
  key: String,
}

impl NoteStoreGetResourceApplicationDataEntryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceApplicationDataEntryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceApplicationDataEntryArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceApplicationDataEntryArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetResourceApplicationDataEntryArgs.key", &f_3)?;
    let ret = NoteStoreGetResourceApplicationDataEntryArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      key: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceApplicationDataEntry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 3))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceApplicationDataEntryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceApplicationDataEntryResult {
  result_value: Option<String>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceApplicationDataEntryResult {
  fn ok_or(self) -> thrift::Result<String> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceApplicationDataEntry"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceApplicationDataEntryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceApplicationDataEntryResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceApplicationDataEntryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreSetResourceApplicationDataEntryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreSetResourceApplicationDataEntryArgs {
  authentication_token: String,
  guid: types::Guid,
  key: String,
  value: String,
}

impl NoteStoreSetResourceApplicationDataEntryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreSetResourceApplicationDataEntryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreSetResourceApplicationDataEntryArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreSetResourceApplicationDataEntryArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreSetResourceApplicationDataEntryArgs.key", &f_3)?;
    verify_required_field_exists("NoteStoreSetResourceApplicationDataEntryArgs.value", &f_4)?;
    let ret = NoteStoreSetResourceApplicationDataEntryArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      key: f_3.expect("auto-generated code should have checked for presence of required fields"),
      value: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setResourceApplicationDataEntry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 3))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 4))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreSetResourceApplicationDataEntryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreSetResourceApplicationDataEntryResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreSetResourceApplicationDataEntryResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreSetResourceApplicationDataEntry"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreSetResourceApplicationDataEntryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreSetResourceApplicationDataEntryResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreSetResourceApplicationDataEntryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUnsetResourceApplicationDataEntryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUnsetResourceApplicationDataEntryArgs {
  authentication_token: String,
  guid: types::Guid,
  key: String,
}

impl NoteStoreUnsetResourceApplicationDataEntryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUnsetResourceApplicationDataEntryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUnsetResourceApplicationDataEntryArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUnsetResourceApplicationDataEntryArgs.guid", &f_2)?;
    verify_required_field_exists("NoteStoreUnsetResourceApplicationDataEntryArgs.key", &f_3)?;
    let ret = NoteStoreUnsetResourceApplicationDataEntryArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      key: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unsetResourceApplicationDataEntry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 3))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUnsetResourceApplicationDataEntryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUnsetResourceApplicationDataEntryResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUnsetResourceApplicationDataEntryResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUnsetResourceApplicationDataEntry"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUnsetResourceApplicationDataEntryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUnsetResourceApplicationDataEntryResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUnsetResourceApplicationDataEntryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateResourceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateResourceArgs {
  authentication_token: String,
  resource: types::Resource,
}

impl NoteStoreUpdateResourceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateResourceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Resource> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Resource::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateResourceArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateResourceArgs.resource", &f_2)?;
    let ret = NoteStoreUpdateResourceArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateResource_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::Struct, 2))?;
    self.resource.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateResourceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateResourceResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreUpdateResourceResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateResource"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateResourceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateResourceResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateResourceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceDataArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetResourceDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceDataArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceDataArgs.guid", &f_2)?;
    let ret = NoteStoreGetResourceDataArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceDataResult {
  result_value: Option<Vec<u8>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceDataResult {
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceData"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceDataResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceByHashArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceByHashArgs {
  authentication_token: String,
  note_guid: types::Guid,
  content_hash: Vec<u8>,
  with_data: bool,
  with_recognition: bool,
  with_alternate_data: bool,
}

impl NoteStoreGetResourceByHashArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceByHashArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceByHashArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceByHashArgs.note_guid", &f_2)?;
    verify_required_field_exists("NoteStoreGetResourceByHashArgs.content_hash", &f_3)?;
    verify_required_field_exists("NoteStoreGetResourceByHashArgs.with_data", &f_4)?;
    verify_required_field_exists("NoteStoreGetResourceByHashArgs.with_recognition", &f_5)?;
    verify_required_field_exists("NoteStoreGetResourceByHashArgs.with_alternate_data", &f_6)?;
    let ret = NoteStoreGetResourceByHashArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note_guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content_hash: f_3.expect("auto-generated code should have checked for presence of required fields"),
      with_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      with_recognition: f_5.expect("auto-generated code should have checked for presence of required fields"),
      with_alternate_data: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceByHash_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 2))?;
    o_prot.write_string(&self.note_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contentHash", TType::String, 3))?;
    o_prot.write_bytes(&self.content_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withData", TType::Bool, 4))?;
    o_prot.write_bool(self.with_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withRecognition", TType::Bool, 5))?;
    o_prot.write_bool(self.with_recognition)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("withAlternateData", TType::Bool, 6))?;
    o_prot.write_bool(self.with_alternate_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceByHashResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceByHashResult {
  result_value: Option<types::Resource>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceByHashResult {
  fn ok_or(self) -> thrift::Result<types::Resource> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceByHash"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceByHashResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Resource> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Resource::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceByHashResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceByHashResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceRecognitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceRecognitionArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetResourceRecognitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceRecognitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceRecognitionArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceRecognitionArgs.guid", &f_2)?;
    let ret = NoteStoreGetResourceRecognitionArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceRecognition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceRecognitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceRecognitionResult {
  result_value: Option<Vec<u8>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceRecognitionResult {
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceRecognition"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceRecognitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceRecognitionResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceRecognitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceAlternateDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceAlternateDataArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetResourceAlternateDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceAlternateDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceAlternateDataArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceAlternateDataArgs.guid", &f_2)?;
    let ret = NoteStoreGetResourceAlternateDataArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceAlternateData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceAlternateDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceAlternateDataResult {
  result_value: Option<Vec<u8>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceAlternateDataResult {
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceAlternateData"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceAlternateDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceAlternateDataResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceAlternateDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceAttributesArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreGetResourceAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetResourceAttributesArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetResourceAttributesArgs.guid", &f_2)?;
    let ret = NoteStoreGetResourceAttributesArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getResourceAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetResourceAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetResourceAttributesResult {
  result_value: Option<types::ResourceAttributes>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetResourceAttributesResult {
  fn ok_or(self) -> thrift::Result<types::ResourceAttributes> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetResourceAttributes"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetResourceAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::ResourceAttributes> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::ResourceAttributes::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetResourceAttributesResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetResourceAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetPublicNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetPublicNotebookArgs {
  user_id: types::UserID,
  public_uri: String,
}

impl NoteStoreGetPublicNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetPublicNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::UserID> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetPublicNotebookArgs.user_id", &f_1)?;
    verify_required_field_exists("NoteStoreGetPublicNotebookArgs.public_uri", &f_2)?;
    let ret = NoteStoreGetPublicNotebookArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      public_uri: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPublicNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::I32, 1))?;
    o_prot.write_i32(self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("publicUri", TType::String, 2))?;
    o_prot.write_string(&self.public_uri)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetPublicNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetPublicNotebookResult {
  result_value: Option<types::Notebook>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreGetPublicNotebookResult {
  fn ok_or(self) -> thrift::Result<types::Notebook> {
    if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetPublicNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetPublicNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Notebook> = None;
    let mut f_1: Option<errors::EDAMSystemException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Notebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetPublicNotebookResult {
      result_value: f_0,
      system_exception: f_1,
      not_found_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetPublicNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreShareNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreShareNotebookArgs {
  authentication_token: String,
  shared_notebook: types::SharedNotebook,
  message: String,
}

impl NoteStoreShareNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreShareNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::SharedNotebook> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::SharedNotebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreShareNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreShareNotebookArgs.shared_notebook", &f_2)?;
    verify_required_field_exists("NoteStoreShareNotebookArgs.message", &f_3)?;
    let ret = NoteStoreShareNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      shared_notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
      message: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("shareNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sharedNotebook", TType::Struct, 2))?;
    self.shared_notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 3))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreShareNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreShareNotebookResult {
  result_value: Option<types::SharedNotebook>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreShareNotebookResult {
  fn ok_or(self) -> thrift::Result<types::SharedNotebook> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreShareNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreShareNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::SharedNotebook> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::SharedNotebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreShareNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreShareNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateOrUpdateNotebookSharesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateOrUpdateNotebookSharesArgs {
  authentication_token: String,
  share_template: NotebookShareTemplate,
}

impl NoteStoreCreateOrUpdateNotebookSharesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateOrUpdateNotebookSharesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<NotebookShareTemplate> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = NotebookShareTemplate::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreCreateOrUpdateNotebookSharesArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreCreateOrUpdateNotebookSharesArgs.share_template", &f_2)?;
    let ret = NoteStoreCreateOrUpdateNotebookSharesArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      share_template: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createOrUpdateNotebookShares_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("shareTemplate", TType::Struct, 2))?;
    self.share_template.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateOrUpdateNotebookSharesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateOrUpdateNotebookSharesResult {
  result_value: Option<CreateOrUpdateNotebookSharesResult>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
  invalid_contacts_exception: Option<errors::EDAMInvalidContactsException>,
}

impl NoteStoreCreateOrUpdateNotebookSharesResult {
  fn ok_or(self) -> thrift::Result<CreateOrUpdateNotebookSharesResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.invalid_contacts_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.invalid_contacts_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreCreateOrUpdateNotebookShares"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateOrUpdateNotebookSharesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CreateOrUpdateNotebookSharesResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    let mut f_4: Option<errors::EDAMInvalidContactsException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CreateOrUpdateNotebookSharesResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = errors::EDAMInvalidContactsException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreCreateOrUpdateNotebookSharesResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
      invalid_contacts_exception: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreCreateOrUpdateNotebookSharesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.invalid_contacts_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("invalidContactsException", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateSharedNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateSharedNotebookArgs {
  authentication_token: String,
  shared_notebook: types::SharedNotebook,
}

impl NoteStoreUpdateSharedNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateSharedNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::SharedNotebook> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::SharedNotebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateSharedNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateSharedNotebookArgs.shared_notebook", &f_2)?;
    let ret = NoteStoreUpdateSharedNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      shared_notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateSharedNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sharedNotebook", TType::Struct, 2))?;
    self.shared_notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateSharedNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateSharedNotebookResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreUpdateSharedNotebookResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateSharedNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateSharedNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateSharedNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateSharedNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreSetNotebookRecipientSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreSetNotebookRecipientSettingsArgs {
  authentication_token: String,
  notebook_guid: String,
  recipient_settings: types::NotebookRecipientSettings,
}

impl NoteStoreSetNotebookRecipientSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreSetNotebookRecipientSettingsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<types::NotebookRecipientSettings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::NotebookRecipientSettings::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreSetNotebookRecipientSettingsArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreSetNotebookRecipientSettingsArgs.notebook_guid", &f_2)?;
    verify_required_field_exists("NoteStoreSetNotebookRecipientSettingsArgs.recipient_settings", &f_3)?;
    let ret = NoteStoreSetNotebookRecipientSettingsArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notebook_guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      recipient_settings: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setNotebookRecipientSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 2))?;
    o_prot.write_string(&self.notebook_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("recipientSettings", TType::Struct, 3))?;
    self.recipient_settings.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreSetNotebookRecipientSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreSetNotebookRecipientSettingsResult {
  result_value: Option<types::Notebook>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreSetNotebookRecipientSettingsResult {
  fn ok_or(self) -> thrift::Result<types::Notebook> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreSetNotebookRecipientSettings"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreSetNotebookRecipientSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::Notebook> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::Notebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreSetNotebookRecipientSettingsResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreSetNotebookRecipientSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListSharedNotebooksArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListSharedNotebooksArgs {
  authentication_token: String,
}

impl NoteStoreListSharedNotebooksArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListSharedNotebooksArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListSharedNotebooksArgs.authentication_token", &f_1)?;
    let ret = NoteStoreListSharedNotebooksArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listSharedNotebooks_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListSharedNotebooksResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListSharedNotebooksResult {
  result_value: Option<Vec<types::SharedNotebook>>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreListSharedNotebooksResult {
  fn ok_or(self) -> thrift::Result<Vec<types::SharedNotebook>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListSharedNotebooks"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListSharedNotebooksResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::SharedNotebook>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::SharedNotebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = types::SharedNotebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListSharedNotebooksResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListSharedNotebooksResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateLinkedNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateLinkedNotebookArgs {
  authentication_token: String,
  linked_notebook: types::LinkedNotebook,
}

impl NoteStoreCreateLinkedNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateLinkedNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::LinkedNotebook> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::LinkedNotebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreCreateLinkedNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreCreateLinkedNotebookArgs.linked_notebook", &f_2)?;
    let ret = NoteStoreCreateLinkedNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      linked_notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createLinkedNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("linkedNotebook", TType::Struct, 2))?;
    self.linked_notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreCreateLinkedNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreCreateLinkedNotebookResult {
  result_value: Option<types::LinkedNotebook>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreCreateLinkedNotebookResult {
  fn ok_or(self) -> thrift::Result<types::LinkedNotebook> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreCreateLinkedNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreCreateLinkedNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::LinkedNotebook> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::LinkedNotebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreCreateLinkedNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreCreateLinkedNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateLinkedNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateLinkedNotebookArgs {
  authentication_token: String,
  linked_notebook: types::LinkedNotebook,
}

impl NoteStoreUpdateLinkedNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateLinkedNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::LinkedNotebook> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::LinkedNotebook::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateLinkedNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateLinkedNotebookArgs.linked_notebook", &f_2)?;
    let ret = NoteStoreUpdateLinkedNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      linked_notebook: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateLinkedNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("linkedNotebook", TType::Struct, 2))?;
    self.linked_notebook.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateLinkedNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateLinkedNotebookResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreUpdateLinkedNotebookResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateLinkedNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateLinkedNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateLinkedNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateLinkedNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListLinkedNotebooksArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListLinkedNotebooksArgs {
  authentication_token: String,
}

impl NoteStoreListLinkedNotebooksArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListLinkedNotebooksArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreListLinkedNotebooksArgs.authentication_token", &f_1)?;
    let ret = NoteStoreListLinkedNotebooksArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listLinkedNotebooks_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreListLinkedNotebooksResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreListLinkedNotebooksResult {
  result_value: Option<Vec<types::LinkedNotebook>>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreListLinkedNotebooksResult {
  fn ok_or(self) -> thrift::Result<Vec<types::LinkedNotebook>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreListLinkedNotebooks"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreListLinkedNotebooksResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::LinkedNotebook>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::LinkedNotebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = types::LinkedNotebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreListLinkedNotebooksResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreListLinkedNotebooksResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeLinkedNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeLinkedNotebookArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreExpungeLinkedNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeLinkedNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreExpungeLinkedNotebookArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreExpungeLinkedNotebookArgs.guid", &f_2)?;
    let ret = NoteStoreExpungeLinkedNotebookArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("expungeLinkedNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreExpungeLinkedNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreExpungeLinkedNotebookResult {
  result_value: Option<i32>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreExpungeLinkedNotebookResult {
  fn ok_or(self) -> thrift::Result<i32> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreExpungeLinkedNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreExpungeLinkedNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreExpungeLinkedNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreExpungeLinkedNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreAuthenticateToSharedNotebookArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreAuthenticateToSharedNotebookArgs {
  share_key_or_global_id: String,
  authentication_token: String,
}

impl NoteStoreAuthenticateToSharedNotebookArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreAuthenticateToSharedNotebookArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreAuthenticateToSharedNotebookArgs.share_key_or_global_id", &f_1)?;
    verify_required_field_exists("NoteStoreAuthenticateToSharedNotebookArgs.authentication_token", &f_2)?;
    let ret = NoteStoreAuthenticateToSharedNotebookArgs {
      share_key_or_global_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      authentication_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("authenticateToSharedNotebook_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("shareKeyOrGlobalId", TType::String, 1))?;
    o_prot.write_string(&self.share_key_or_global_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 2))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreAuthenticateToSharedNotebookResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreAuthenticateToSharedNotebookResult {
  result_value: Option<user_store::AuthenticationResult>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreAuthenticateToSharedNotebookResult {
  fn ok_or(self) -> thrift::Result<user_store::AuthenticationResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreAuthenticateToSharedNotebook"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreAuthenticateToSharedNotebookResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<user_store::AuthenticationResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = user_store::AuthenticationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreAuthenticateToSharedNotebookResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreAuthenticateToSharedNotebookResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetSharedNotebookByAuthArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetSharedNotebookByAuthArgs {
  authentication_token: String,
}

impl NoteStoreGetSharedNotebookByAuthArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetSharedNotebookByAuthArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetSharedNotebookByAuthArgs.authentication_token", &f_1)?;
    let ret = NoteStoreGetSharedNotebookByAuthArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getSharedNotebookByAuth_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetSharedNotebookByAuthResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetSharedNotebookByAuthResult {
  result_value: Option<types::SharedNotebook>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreGetSharedNotebookByAuthResult {
  fn ok_or(self) -> thrift::Result<types::SharedNotebook> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetSharedNotebookByAuth"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetSharedNotebookByAuthResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::SharedNotebook> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::SharedNotebook::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetSharedNotebookByAuthResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetSharedNotebookByAuthResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreEmailNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreEmailNoteArgs {
  authentication_token: String,
  parameters: NoteEmailParameters,
}

impl NoteStoreEmailNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreEmailNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<NoteEmailParameters> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoteEmailParameters::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreEmailNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreEmailNoteArgs.parameters", &f_2)?;
    let ret = NoteStoreEmailNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parameters: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("emailNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Struct, 2))?;
    self.parameters.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreEmailNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreEmailNoteResult {
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreEmailNoteResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreEmailNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreEmailNoteResult {
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreEmailNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreShareNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreShareNoteArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreShareNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreShareNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreShareNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreShareNoteArgs.guid", &f_2)?;
    let ret = NoteStoreShareNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("shareNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreShareNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreShareNoteResult {
  result_value: Option<String>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreShareNoteResult {
  fn ok_or(self) -> thrift::Result<String> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreShareNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreShareNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreShareNoteResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreShareNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreStopSharingNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreStopSharingNoteArgs {
  authentication_token: String,
  guid: types::Guid,
}

impl NoteStoreStopSharingNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreStopSharingNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Guid> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreStopSharingNoteArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreStopSharingNoteArgs.guid", &f_2)?;
    let ret = NoteStoreStopSharingNoteArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("stopSharingNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 2))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreStopSharingNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreStopSharingNoteResult {
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreStopSharingNoteResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreStopSharingNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreStopSharingNoteResult {
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreStopSharingNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreAuthenticateToSharedNoteArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreAuthenticateToSharedNoteArgs {
  guid: String,
  note_key: String,
  authentication_token: String,
}

impl NoteStoreAuthenticateToSharedNoteArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreAuthenticateToSharedNoteArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreAuthenticateToSharedNoteArgs.guid", &f_1)?;
    verify_required_field_exists("NoteStoreAuthenticateToSharedNoteArgs.note_key", &f_2)?;
    verify_required_field_exists("NoteStoreAuthenticateToSharedNoteArgs.authentication_token", &f_3)?;
    let ret = NoteStoreAuthenticateToSharedNoteArgs {
      guid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      authentication_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("authenticateToSharedNote_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
    o_prot.write_string(&self.guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("noteKey", TType::String, 2))?;
    o_prot.write_string(&self.note_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 3))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreAuthenticateToSharedNoteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreAuthenticateToSharedNoteResult {
  result_value: Option<user_store::AuthenticationResult>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreAuthenticateToSharedNoteResult {
  fn ok_or(self) -> thrift::Result<user_store::AuthenticationResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreAuthenticateToSharedNote"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreAuthenticateToSharedNoteResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<user_store::AuthenticationResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = user_store::AuthenticationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreAuthenticateToSharedNoteResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreAuthenticateToSharedNoteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindRelatedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindRelatedArgs {
  authentication_token: String,
  query: RelatedQuery,
  result_spec: RelatedResultSpec,
}

impl NoteStoreFindRelatedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindRelatedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<RelatedQuery> = None;
    let mut f_3: Option<RelatedResultSpec> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = RelatedQuery::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = RelatedResultSpec::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreFindRelatedArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreFindRelatedArgs.query", &f_2)?;
    verify_required_field_exists("NoteStoreFindRelatedArgs.result_spec", &f_3)?;
    let ret = NoteStoreFindRelatedArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
      result_spec: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("findRelated_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::Struct, 2))?;
    self.query.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resultSpec", TType::Struct, 3))?;
    self.result_spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreFindRelatedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreFindRelatedResult {
  result_value: Option<RelatedResult>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl NoteStoreFindRelatedResult {
  fn ok_or(self) -> thrift::Result<RelatedResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreFindRelated"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreFindRelatedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<RelatedResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = RelatedResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreFindRelatedResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreFindRelatedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateNoteIfUsnMatchesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateNoteIfUsnMatchesArgs {
  authentication_token: String,
  note: types::Note,
}

impl NoteStoreUpdateNoteIfUsnMatchesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateNoteIfUsnMatchesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::Note> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::Note::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreUpdateNoteIfUsnMatchesArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreUpdateNoteIfUsnMatchesArgs.note", &f_2)?;
    let ret = NoteStoreUpdateNoteIfUsnMatchesArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      note: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateNoteIfUsnMatches_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("note", TType::Struct, 2))?;
    self.note.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreUpdateNoteIfUsnMatchesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreUpdateNoteIfUsnMatchesResult {
  result_value: Option<UpdateNoteIfUsnMatchesResult>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreUpdateNoteIfUsnMatchesResult {
  fn ok_or(self) -> thrift::Result<UpdateNoteIfUsnMatchesResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreUpdateNoteIfUsnMatches"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreUpdateNoteIfUsnMatchesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UpdateNoteIfUsnMatchesResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UpdateNoteIfUsnMatchesResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreUpdateNoteIfUsnMatchesResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreUpdateNoteIfUsnMatchesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreManageNotebookSharesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreManageNotebookSharesArgs {
  authentication_token: String,
  parameters: ManageNotebookSharesParameters,
}

impl NoteStoreManageNotebookSharesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreManageNotebookSharesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<ManageNotebookSharesParameters> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = ManageNotebookSharesParameters::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreManageNotebookSharesArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreManageNotebookSharesArgs.parameters", &f_2)?;
    let ret = NoteStoreManageNotebookSharesArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parameters: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("manageNotebookShares_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Struct, 2))?;
    self.parameters.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreManageNotebookSharesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreManageNotebookSharesResult {
  result_value: Option<ManageNotebookSharesResult>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreManageNotebookSharesResult {
  fn ok_or(self) -> thrift::Result<ManageNotebookSharesResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreManageNotebookShares"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreManageNotebookSharesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ManageNotebookSharesResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ManageNotebookSharesResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreManageNotebookSharesResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreManageNotebookSharesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNotebookSharesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNotebookSharesArgs {
  authentication_token: String,
  notebook_guid: String,
}

impl NoteStoreGetNotebookSharesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNotebookSharesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NoteStoreGetNotebookSharesArgs.authentication_token", &f_1)?;
    verify_required_field_exists("NoteStoreGetNotebookSharesArgs.notebook_guid", &f_2)?;
    let ret = NoteStoreGetNotebookSharesArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notebook_guid: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getNotebookShares_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 2))?;
    o_prot.write_string(&self.notebook_guid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteStoreGetNotebookSharesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteStoreGetNotebookSharesResult {
  result_value: Option<ShareRelationships>,
  user_exception: Option<errors::EDAMUserException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl NoteStoreGetNotebookSharesResult {
  fn ok_or(self) -> thrift::Result<ShareRelationships> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for NoteStoreGetNotebookShares"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteStoreGetNotebookSharesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ShareRelationships> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMNotFoundException> = None;
    let mut f_3: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ShareRelationships::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteStoreGetNotebookSharesResult {
      result_value: f_0,
      user_exception: f_1,
      not_found_exception: f_2,
      system_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteStoreGetNotebookSharesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

