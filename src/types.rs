// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::limits;

/// This enumeration defines the possible permission levels for a user.
/// Free accounts will have a level of NORMAL and paid Premium accounts
/// will have a level of PREMIUM.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrivilegeLevel(pub i32);

impl PrivilegeLevel {
  pub const NORMAL: PrivilegeLevel = PrivilegeLevel(1);
  pub const PREMIUM: PrivilegeLevel = PrivilegeLevel(3);
  pub const VIP: PrivilegeLevel = PrivilegeLevel(5);
  pub const MANAGER: PrivilegeLevel = PrivilegeLevel(7);
  pub const SUPPORT: PrivilegeLevel = PrivilegeLevel(8);
  pub const ADMIN: PrivilegeLevel = PrivilegeLevel(9);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::PREMIUM,
    Self::VIP,
    Self::MANAGER,
    Self::SUPPORT,
    Self::ADMIN,
  ];
}

impl TSerializable for PrivilegeLevel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrivilegeLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(PrivilegeLevel::from(enum_value))
  }
}

impl From<i32> for PrivilegeLevel {
  fn from(i: i32) -> Self {
    match i {
      1 => PrivilegeLevel::NORMAL,
      3 => PrivilegeLevel::PREMIUM,
      5 => PrivilegeLevel::VIP,
      7 => PrivilegeLevel::MANAGER,
      8 => PrivilegeLevel::SUPPORT,
      9 => PrivilegeLevel::ADMIN,
      _ => PrivilegeLevel(i)
    }
  }
}

impl From<&i32> for PrivilegeLevel {
  fn from(i: &i32) -> Self {
    PrivilegeLevel::from(*i)
  }
}

impl From<PrivilegeLevel> for i32 {
  fn from(e: PrivilegeLevel) -> i32 {
    e.0
  }
}

impl From<&PrivilegeLevel> for i32 {
  fn from(e: &PrivilegeLevel) -> i32 {
    e.0
  }
}

/// This enumeration defines the possible tiers of service that a user may have. A
/// ServiceLevel of BUSINESS signifies a business-only account, which can never be any
/// other ServiceLevel.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ServiceLevel(pub i32);

impl ServiceLevel {
  pub const BASIC: ServiceLevel = ServiceLevel(1);
  pub const PLUS: ServiceLevel = ServiceLevel(2);
  pub const PREMIUM: ServiceLevel = ServiceLevel(3);
  pub const BUSINESS: ServiceLevel = ServiceLevel(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BASIC,
    Self::PLUS,
    Self::PREMIUM,
    Self::BUSINESS,
  ];
}

impl TSerializable for ServiceLevel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(ServiceLevel::from(enum_value))
  }
}

impl From<i32> for ServiceLevel {
  fn from(i: i32) -> Self {
    match i {
      1 => ServiceLevel::BASIC,
      2 => ServiceLevel::PLUS,
      3 => ServiceLevel::PREMIUM,
      4 => ServiceLevel::BUSINESS,
      _ => ServiceLevel(i)
    }
  }
}

impl From<&i32> for ServiceLevel {
  fn from(i: &i32) -> Self {
    ServiceLevel::from(*i)
  }
}

impl From<ServiceLevel> for i32 {
  fn from(e: ServiceLevel) -> i32 {
    e.0
  }
}

impl From<&ServiceLevel> for i32 {
  fn from(e: &ServiceLevel) -> i32 {
    e.0
  }
}

/// Every search query is specified as a sequence of characters.
/// Currently, only the USER query format is supported.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryFormat(pub i32);

impl QueryFormat {
  pub const USER: QueryFormat = QueryFormat(1);
  pub const SEXP: QueryFormat = QueryFormat(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::USER,
    Self::SEXP,
  ];
}

impl TSerializable for QueryFormat {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryFormat> {
    let enum_value = i_prot.read_i32()?;
    Ok(QueryFormat::from(enum_value))
  }
}

impl From<i32> for QueryFormat {
  fn from(i: i32) -> Self {
    match i {
      1 => QueryFormat::USER,
      2 => QueryFormat::SEXP,
      _ => QueryFormat(i)
    }
  }
}

impl From<&i32> for QueryFormat {
  fn from(i: &i32) -> Self {
    QueryFormat::from(*i)
  }
}

impl From<QueryFormat> for i32 {
  fn from(e: QueryFormat) -> i32 {
    e.0
  }
}

impl From<&QueryFormat> for i32 {
  fn from(e: &QueryFormat) -> i32 {
    e.0
  }
}

/// This enumeration defines the possible sort ordering for notes when
/// they are returned from a search result.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteSortOrder(pub i32);

impl NoteSortOrder {
  pub const CREATED: NoteSortOrder = NoteSortOrder(1);
  pub const UPDATED: NoteSortOrder = NoteSortOrder(2);
  pub const RELEVANCE: NoteSortOrder = NoteSortOrder(3);
  pub const UPDATE_SEQUENCE_NUMBER: NoteSortOrder = NoteSortOrder(4);
  pub const TITLE: NoteSortOrder = NoteSortOrder(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CREATED,
    Self::UPDATED,
    Self::RELEVANCE,
    Self::UPDATE_SEQUENCE_NUMBER,
    Self::TITLE,
  ];
}

impl TSerializable for NoteSortOrder {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteSortOrder> {
    let enum_value = i_prot.read_i32()?;
    Ok(NoteSortOrder::from(enum_value))
  }
}

impl From<i32> for NoteSortOrder {
  fn from(i: i32) -> Self {
    match i {
      1 => NoteSortOrder::CREATED,
      2 => NoteSortOrder::UPDATED,
      3 => NoteSortOrder::RELEVANCE,
      4 => NoteSortOrder::UPDATE_SEQUENCE_NUMBER,
      5 => NoteSortOrder::TITLE,
      _ => NoteSortOrder(i)
    }
  }
}

impl From<&i32> for NoteSortOrder {
  fn from(i: &i32) -> Self {
    NoteSortOrder::from(*i)
  }
}

impl From<NoteSortOrder> for i32 {
  fn from(e: NoteSortOrder) -> i32 {
    e.0
  }
}

impl From<&NoteSortOrder> for i32 {
  fn from(e: &NoteSortOrder) -> i32 {
    e.0
  }
}

/// This enumeration defines the possible states of a premium account
/// 
/// NONE:    the user has never attempted to become a premium subscriber
/// 
/// PENDING: the user has requested a premium account but their charge has not
///   been confirmed
/// 
/// ACTIVE:  the user has been charged and their premium account is in good
///  standing
/// 
/// FAILED:  the system attempted to charge the was denied. We will periodically attempt to
///  re-validate their order.
/// 
/// CANCELLATION_PENDING: the user has requested that no further charges be made
///   but the current account is still active.
/// 
/// CANCELED: the premium account was canceled either because of failure to pay
///   or user cancelation. No more attempts will be made to activate the account.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PremiumOrderStatus(pub i32);

impl PremiumOrderStatus {
  pub const NONE: PremiumOrderStatus = PremiumOrderStatus(0);
  pub const PENDING: PremiumOrderStatus = PremiumOrderStatus(1);
  pub const ACTIVE: PremiumOrderStatus = PremiumOrderStatus(2);
  pub const FAILED: PremiumOrderStatus = PremiumOrderStatus(3);
  pub const CANCELLATION_PENDING: PremiumOrderStatus = PremiumOrderStatus(4);
  pub const CANCELED: PremiumOrderStatus = PremiumOrderStatus(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PENDING,
    Self::ACTIVE,
    Self::FAILED,
    Self::CANCELLATION_PENDING,
    Self::CANCELED,
  ];
}

impl TSerializable for PremiumOrderStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PremiumOrderStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(PremiumOrderStatus::from(enum_value))
  }
}

impl From<i32> for PremiumOrderStatus {
  fn from(i: i32) -> Self {
    match i {
      0 => PremiumOrderStatus::NONE,
      1 => PremiumOrderStatus::PENDING,
      2 => PremiumOrderStatus::ACTIVE,
      3 => PremiumOrderStatus::FAILED,
      4 => PremiumOrderStatus::CANCELLATION_PENDING,
      5 => PremiumOrderStatus::CANCELED,
      _ => PremiumOrderStatus(i)
    }
  }
}

impl From<&i32> for PremiumOrderStatus {
  fn from(i: &i32) -> Self {
    PremiumOrderStatus::from(*i)
  }
}

impl From<PremiumOrderStatus> for i32 {
  fn from(e: PremiumOrderStatus) -> i32 {
    e.0
  }
}

impl From<&PremiumOrderStatus> for i32 {
  fn from(e: &PremiumOrderStatus) -> i32 {
    e.0
  }
}

/// Privilege levels for accessing shared notebooks.
/// 
/// Note that as of 2014-04, FULL_ACCESS is synonymous with BUSINESS_FULL_ACCESS.  If a
/// user is a member of a business and has FULL_ACCESS privileges, then they will
/// automatically be granted BUSINESS_FULL_ACCESS for notebooks in their business.  This
/// will happen implicitly when they attempt to access the corresponding notebooks of
/// the business.  BUSINESS_FULL_ACCESS is therefore deprecated.
/// 
/// READ_NOTEBOOK: Recipient is able to read the contents of the shared notebook
///   but does not have access to information about other recipients of the
///   notebook or the activity stream information.
/// 
/// MODIFY_NOTEBOOK_PLUS_ACTIVITY: Recipient has rights to read and modify the contents
///   of the shared notebook, including the right to move notes to the trash and to create
///   notes in the notebook.  The recipient can also access information about other
///   recipients and the activity stream.
/// 
/// READ_NOTEBOOK_PLUS_ACTIVITY: Recipient has READ_NOTEBOOK rights and can also
///   access information about other recipients and the activity stream.
/// 
/// GROUP: If the user belongs to a group, such as a Business, that has a defined
///   privilege level, use the privilege level of the group as the privilege for
///   the individual.
/// 
/// FULL_ACCESS: Recipient has full rights to the shared notebook and recipient lists,
///   including privilege to revoke and create invitations and to change privilege
///   levels on invitations for individuals.  For members of a business, FULL_ACCESS
///   privilege on business notebooks also grants the ability to change how the notebook
///   will appear when shared with the business, including the rights to share and
///   unshare the notebook with the business.
/// 
/// BUSINESS_FULL_ACCESS: Deprecated.  See the note above about BUSINESS_FULL_ACCESS and
///   FULL_ACCESS being synonymous.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SharedNotebookPrivilegeLevel(pub i32);

impl SharedNotebookPrivilegeLevel {
  pub const READ_NOTEBOOK: SharedNotebookPrivilegeLevel = SharedNotebookPrivilegeLevel(0);
  pub const MODIFY_NOTEBOOK_PLUS_ACTIVITY: SharedNotebookPrivilegeLevel = SharedNotebookPrivilegeLevel(1);
  pub const READ_NOTEBOOK_PLUS_ACTIVITY: SharedNotebookPrivilegeLevel = SharedNotebookPrivilegeLevel(2);
  pub const GROUP: SharedNotebookPrivilegeLevel = SharedNotebookPrivilegeLevel(3);
  pub const FULL_ACCESS: SharedNotebookPrivilegeLevel = SharedNotebookPrivilegeLevel(4);
  pub const BUSINESS_FULL_ACCESS: SharedNotebookPrivilegeLevel = SharedNotebookPrivilegeLevel(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::READ_NOTEBOOK,
    Self::MODIFY_NOTEBOOK_PLUS_ACTIVITY,
    Self::READ_NOTEBOOK_PLUS_ACTIVITY,
    Self::GROUP,
    Self::FULL_ACCESS,
    Self::BUSINESS_FULL_ACCESS,
  ];
}

impl TSerializable for SharedNotebookPrivilegeLevel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SharedNotebookPrivilegeLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(SharedNotebookPrivilegeLevel::from(enum_value))
  }
}

impl From<i32> for SharedNotebookPrivilegeLevel {
  fn from(i: i32) -> Self {
    match i {
      0 => SharedNotebookPrivilegeLevel::READ_NOTEBOOK,
      1 => SharedNotebookPrivilegeLevel::MODIFY_NOTEBOOK_PLUS_ACTIVITY,
      2 => SharedNotebookPrivilegeLevel::READ_NOTEBOOK_PLUS_ACTIVITY,
      3 => SharedNotebookPrivilegeLevel::GROUP,
      4 => SharedNotebookPrivilegeLevel::FULL_ACCESS,
      5 => SharedNotebookPrivilegeLevel::BUSINESS_FULL_ACCESS,
      _ => SharedNotebookPrivilegeLevel(i)
    }
  }
}

impl From<&i32> for SharedNotebookPrivilegeLevel {
  fn from(i: &i32) -> Self {
    SharedNotebookPrivilegeLevel::from(*i)
  }
}

impl From<SharedNotebookPrivilegeLevel> for i32 {
  fn from(e: SharedNotebookPrivilegeLevel) -> i32 {
    e.0
  }
}

impl From<&SharedNotebookPrivilegeLevel> for i32 {
  fn from(e: &SharedNotebookPrivilegeLevel) -> i32 {
    e.0
  }
}

/// Privilege levels for accessing a shared note. All privilege levels convey "activity feed" access,
/// which allows the recipient to access information about other recipients and the activity stream.
/// 
/// READ_NOTE: Recipient has rights to read the shared note.
/// 
/// MODIFY_NOTE: Recipient has all of the rights of READ_NOTE, plus rights to modify the shared
///   note's content, title and resources. Other fields, including the notebook, tags and metadata,
///   may not be modified.
/// 
/// FULL_ACCESS: Recipient has all of the rights of MODIFY_NOTE, plus rights to share the note with
///   other users via email, public note links, and note sharing. Recipient may also update and
///   remove other recipient's note sharing rights.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SharedNotePrivilegeLevel(pub i32);

impl SharedNotePrivilegeLevel {
  pub const READ_NOTE: SharedNotePrivilegeLevel = SharedNotePrivilegeLevel(0);
  pub const MODIFY_NOTE: SharedNotePrivilegeLevel = SharedNotePrivilegeLevel(1);
  pub const FULL_ACCESS: SharedNotePrivilegeLevel = SharedNotePrivilegeLevel(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::READ_NOTE,
    Self::MODIFY_NOTE,
    Self::FULL_ACCESS,
  ];
}

impl TSerializable for SharedNotePrivilegeLevel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SharedNotePrivilegeLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(SharedNotePrivilegeLevel::from(enum_value))
  }
}

impl From<i32> for SharedNotePrivilegeLevel {
  fn from(i: i32) -> Self {
    match i {
      0 => SharedNotePrivilegeLevel::READ_NOTE,
      1 => SharedNotePrivilegeLevel::MODIFY_NOTE,
      2 => SharedNotePrivilegeLevel::FULL_ACCESS,
      _ => SharedNotePrivilegeLevel(i)
    }
  }
}

impl From<&i32> for SharedNotePrivilegeLevel {
  fn from(i: &i32) -> Self {
    SharedNotePrivilegeLevel::from(*i)
  }
}

impl From<SharedNotePrivilegeLevel> for i32 {
  fn from(e: SharedNotePrivilegeLevel) -> i32 {
    e.0
  }
}

impl From<&SharedNotePrivilegeLevel> for i32 {
  fn from(e: &SharedNotePrivilegeLevel) -> i32 {
    e.0
  }
}

/// Enumeration of the roles that a User can have within a sponsored group.
/// 
/// GROUP_MEMBER: The user is a member of the group with no special privileges.
/// 
/// GROUP_ADMIN: The user is an administrator within the group.
/// 
/// GROUP_OWNER: The user is the owner of the group.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SponsoredGroupRole(pub i32);

impl SponsoredGroupRole {
  pub const GROUP_MEMBER: SponsoredGroupRole = SponsoredGroupRole(1);
  pub const GROUP_ADMIN: SponsoredGroupRole = SponsoredGroupRole(2);
  pub const GROUP_OWNER: SponsoredGroupRole = SponsoredGroupRole(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GROUP_MEMBER,
    Self::GROUP_ADMIN,
    Self::GROUP_OWNER,
  ];
}

impl TSerializable for SponsoredGroupRole {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SponsoredGroupRole> {
    let enum_value = i_prot.read_i32()?;
    Ok(SponsoredGroupRole::from(enum_value))
  }
}

impl From<i32> for SponsoredGroupRole {
  fn from(i: i32) -> Self {
    match i {
      1 => SponsoredGroupRole::GROUP_MEMBER,
      2 => SponsoredGroupRole::GROUP_ADMIN,
      3 => SponsoredGroupRole::GROUP_OWNER,
      _ => SponsoredGroupRole(i)
    }
  }
}

impl From<&i32> for SponsoredGroupRole {
  fn from(i: &i32) -> Self {
    SponsoredGroupRole::from(*i)
  }
}

impl From<SponsoredGroupRole> for i32 {
  fn from(e: SponsoredGroupRole) -> i32 {
    e.0
  }
}

impl From<&SponsoredGroupRole> for i32 {
  fn from(e: &SponsoredGroupRole) -> i32 {
    e.0
  }
}

/// Enumeration of the roles that a User can have within an Evernote Business account.
/// 
/// ADMIN: The user is an administrator of the Evernote Business account.
/// 
/// NORMAL: The user is a regular user within the Evernote Business account.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BusinessUserRole(pub i32);

impl BusinessUserRole {
  pub const ADMIN: BusinessUserRole = BusinessUserRole(1);
  pub const NORMAL: BusinessUserRole = BusinessUserRole(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ADMIN,
    Self::NORMAL,
  ];
}

impl TSerializable for BusinessUserRole {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BusinessUserRole> {
    let enum_value = i_prot.read_i32()?;
    Ok(BusinessUserRole::from(enum_value))
  }
}

impl From<i32> for BusinessUserRole {
  fn from(i: i32) -> Self {
    match i {
      1 => BusinessUserRole::ADMIN,
      2 => BusinessUserRole::NORMAL,
      _ => BusinessUserRole(i)
    }
  }
}

impl From<&i32> for BusinessUserRole {
  fn from(i: &i32) -> Self {
    BusinessUserRole::from(*i)
  }
}

impl From<BusinessUserRole> for i32 {
  fn from(e: BusinessUserRole) -> i32 {
    e.0
  }
}

impl From<&BusinessUserRole> for i32 {
  fn from(e: &BusinessUserRole) -> i32 {
    e.0
  }
}

/// The BusinessUserStatus indicates the status of the user in the business.
/// 
/// A BusinessUser will typically start as ACTIVE.
/// Only ACTIVE users can authenticate to the Business.
/// 
/// <dl>
/// <dt>ACTIVE<dt>
/// <dd>The business user can authenticate to and access the business.</dd>
/// <dt>DEACTIVATED<dt>
/// <dd>The business user has been deactivated and cannot access the business</dd>
/// </dl>
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BusinessUserStatus(pub i32);

impl BusinessUserStatus {
  pub const ACTIVE: BusinessUserStatus = BusinessUserStatus(1);
  pub const DEACTIVATED: BusinessUserStatus = BusinessUserStatus(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ACTIVE,
    Self::DEACTIVATED,
  ];
}

impl TSerializable for BusinessUserStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BusinessUserStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(BusinessUserStatus::from(enum_value))
  }
}

impl From<i32> for BusinessUserStatus {
  fn from(i: i32) -> Self {
    match i {
      1 => BusinessUserStatus::ACTIVE,
      2 => BusinessUserStatus::DEACTIVATED,
      _ => BusinessUserStatus(i)
    }
  }
}

impl From<&i32> for BusinessUserStatus {
  fn from(i: &i32) -> Self {
    BusinessUserStatus::from(*i)
  }
}

impl From<BusinessUserStatus> for i32 {
  fn from(e: BusinessUserStatus) -> i32 {
    e.0
  }
}

impl From<&BusinessUserStatus> for i32 {
  fn from(e: &BusinessUserStatus) -> i32 {
    e.0
  }
}

/// An enumeration describing restrictions on the domain of shared notebook
/// instances that are valid for a given operation, as used, for example, in
/// NotebookRestrictions.
/// 
/// ASSIGNED: The domain consists of shared notebooks that belong, or are assigned,
/// to the recipient.
/// 
/// NO_SHARED_NOTEBOOKS: No shared notebooks are applicable to the operation.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SharedNotebookInstanceRestrictions(pub i32);

impl SharedNotebookInstanceRestrictions {
  pub const ASSIGNED: SharedNotebookInstanceRestrictions = SharedNotebookInstanceRestrictions(1);
  pub const NO_SHARED_NOTEBOOKS: SharedNotebookInstanceRestrictions = SharedNotebookInstanceRestrictions(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ASSIGNED,
    Self::NO_SHARED_NOTEBOOKS,
  ];
}

impl TSerializable for SharedNotebookInstanceRestrictions {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SharedNotebookInstanceRestrictions> {
    let enum_value = i_prot.read_i32()?;
    Ok(SharedNotebookInstanceRestrictions::from(enum_value))
  }
}

impl From<i32> for SharedNotebookInstanceRestrictions {
  fn from(i: i32) -> Self {
    match i {
      1 => SharedNotebookInstanceRestrictions::ASSIGNED,
      2 => SharedNotebookInstanceRestrictions::NO_SHARED_NOTEBOOKS,
      _ => SharedNotebookInstanceRestrictions(i)
    }
  }
}

impl From<&i32> for SharedNotebookInstanceRestrictions {
  fn from(i: &i32) -> Self {
    SharedNotebookInstanceRestrictions::from(*i)
  }
}

impl From<SharedNotebookInstanceRestrictions> for i32 {
  fn from(e: SharedNotebookInstanceRestrictions) -> i32 {
    e.0
  }
}

impl From<&SharedNotebookInstanceRestrictions> for i32 {
  fn from(e: &SharedNotebookInstanceRestrictions) -> i32 {
    e.0
  }
}

/// An enumeration describing the configuration state related to receiving
/// reminder e-mails from the service.  Reminder e-mails summarize notes
/// based on their Note.attributes.reminderTime values.
/// 
/// DO_NOT_SEND: The user has selected to not receive reminder e-mail.
/// 
/// SEND_DAILY_EMAIL: The user has selected to receive reminder e-mail for those
///   days when there is a reminder.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ReminderEmailConfig(pub i32);

impl ReminderEmailConfig {
  pub const DO_NOT_SEND: ReminderEmailConfig = ReminderEmailConfig(1);
  pub const SEND_DAILY_EMAIL: ReminderEmailConfig = ReminderEmailConfig(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DO_NOT_SEND,
    Self::SEND_DAILY_EMAIL,
  ];
}

impl TSerializable for ReminderEmailConfig {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReminderEmailConfig> {
    let enum_value = i_prot.read_i32()?;
    Ok(ReminderEmailConfig::from(enum_value))
  }
}

impl From<i32> for ReminderEmailConfig {
  fn from(i: i32) -> Self {
    match i {
      1 => ReminderEmailConfig::DO_NOT_SEND,
      2 => ReminderEmailConfig::SEND_DAILY_EMAIL,
      _ => ReminderEmailConfig(i)
    }
  }
}

impl From<&i32> for ReminderEmailConfig {
  fn from(i: &i32) -> Self {
    ReminderEmailConfig::from(*i)
  }
}

impl From<ReminderEmailConfig> for i32 {
  fn from(e: ReminderEmailConfig) -> i32 {
    e.0
  }
}

impl From<&ReminderEmailConfig> for i32 {
  fn from(e: &ReminderEmailConfig) -> i32 {
    e.0
  }
}

/// An enumeration defining the possible states of a BusinessInvitation.
/// 
/// APPROVED: The invitation was created or approved by a business admin and may be redeemed by the
///   invited email.
/// 
/// REQUESTED: The invitation was requested by a non-admin member of the business and must be
///   approved by an admin before it may be redeemed. Invitations in this state do not count
///   against a business' seat limit.
/// 
/// REDEEMED: The invitation has already been redeemed. Invitations in this state do not count
///   against a business' seat limit.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BusinessInvitationStatus(pub i32);

impl BusinessInvitationStatus {
  pub const APPROVED: BusinessInvitationStatus = BusinessInvitationStatus(0);
  pub const REQUESTED: BusinessInvitationStatus = BusinessInvitationStatus(1);
  pub const REDEEMED: BusinessInvitationStatus = BusinessInvitationStatus(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::APPROVED,
    Self::REQUESTED,
    Self::REDEEMED,
  ];
}

impl TSerializable for BusinessInvitationStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BusinessInvitationStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(BusinessInvitationStatus::from(enum_value))
  }
}

impl From<i32> for BusinessInvitationStatus {
  fn from(i: i32) -> Self {
    match i {
      0 => BusinessInvitationStatus::APPROVED,
      1 => BusinessInvitationStatus::REQUESTED,
      2 => BusinessInvitationStatus::REDEEMED,
      _ => BusinessInvitationStatus(i)
    }
  }
}

impl From<&i32> for BusinessInvitationStatus {
  fn from(i: &i32) -> Self {
    BusinessInvitationStatus::from(*i)
  }
}

impl From<BusinessInvitationStatus> for i32 {
  fn from(e: BusinessInvitationStatus) -> i32 {
    e.0
  }
}

impl From<&BusinessInvitationStatus> for i32 {
  fn from(e: &BusinessInvitationStatus) -> i32 {
    e.0
  }
}

/// What kinds of Contacts does the Evernote service know about?
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ContactType(pub i32);

impl ContactType {
  pub const EVERNOTE: ContactType = ContactType(1);
  pub const SMS: ContactType = ContactType(2);
  pub const FACEBOOK: ContactType = ContactType(3);
  pub const EMAIL: ContactType = ContactType(4);
  pub const TWITTER: ContactType = ContactType(5);
  pub const LINKEDIN: ContactType = ContactType(6);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EVERNOTE,
    Self::SMS,
    Self::FACEBOOK,
    Self::EMAIL,
    Self::TWITTER,
    Self::LINKEDIN,
  ];
}

impl TSerializable for ContactType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContactType> {
    let enum_value = i_prot.read_i32()?;
    Ok(ContactType::from(enum_value))
  }
}

impl From<i32> for ContactType {
  fn from(i: i32) -> Self {
    match i {
      1 => ContactType::EVERNOTE,
      2 => ContactType::SMS,
      3 => ContactType::FACEBOOK,
      4 => ContactType::EMAIL,
      5 => ContactType::TWITTER,
      6 => ContactType::LINKEDIN,
      _ => ContactType(i)
    }
  }
}

impl From<&i32> for ContactType {
  fn from(i: &i32) -> Self {
    ContactType::from(*i)
  }
}

impl From<ContactType> for i32 {
  fn from(e: ContactType) -> i32 {
    e.0
  }
}

impl From<&ContactType> for i32 {
  fn from(e: &ContactType) -> i32 {
    e.0
  }
}

/// Entity types
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EntityType(pub i32);

impl EntityType {
  pub const NOTE: EntityType = EntityType(1);
  pub const NOTEBOOK: EntityType = EntityType(2);
  pub const WORKSPACE: EntityType = EntityType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NOTE,
    Self::NOTEBOOK,
    Self::WORKSPACE,
  ];
}

impl TSerializable for EntityType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EntityType> {
    let enum_value = i_prot.read_i32()?;
    Ok(EntityType::from(enum_value))
  }
}

impl From<i32> for EntityType {
  fn from(i: i32) -> Self {
    match i {
      1 => EntityType::NOTE,
      2 => EntityType::NOTEBOOK,
      3 => EntityType::WORKSPACE,
      _ => EntityType(i)
    }
  }
}

impl From<&i32> for EntityType {
  fn from(i: &i32) -> Self {
    EntityType::from(*i)
  }
}

impl From<EntityType> for i32 {
  fn from(e: EntityType) -> i32 {
    e.0
  }
}

impl From<&EntityType> for i32 {
  fn from(e: &EntityType) -> i32 {
    e.0
  }
}

/// This enumeration defines the possible states that a notebook can be in for a recipient.
/// It encompasses the "inMyList" boolean and default notebook status.
/// 
/// <dl>
/// <dt>NOT_IN_MY_LIST</dt>
/// <dd>The notebook is not in the recipient's list (not "joined").</dd>
/// <dt>IN_MY_LIST</dt>
/// <dd>The notebook is in the recipient's notebook list (formerly, we would say
///     that the recipient has "joined" the notebook)</dd>
/// <dt>IN_MY_LIST_AND_DEFAULT_NOTEBOOK</dt>
/// <dd>The same as IN_MY_LIST and this notebook is the user's default notebook.</dd>
/// </dl>
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RecipientStatus(pub i32);

impl RecipientStatus {
  pub const NOT_IN_MY_LIST: RecipientStatus = RecipientStatus(1);
  pub const IN_MY_LIST: RecipientStatus = RecipientStatus(2);
  pub const IN_MY_LIST_AND_DEFAULT_NOTEBOOK: RecipientStatus = RecipientStatus(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NOT_IN_MY_LIST,
    Self::IN_MY_LIST,
    Self::IN_MY_LIST_AND_DEFAULT_NOTEBOOK,
  ];
}

impl TSerializable for RecipientStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RecipientStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(RecipientStatus::from(enum_value))
  }
}

impl From<i32> for RecipientStatus {
  fn from(i: i32) -> Self {
    match i {
      1 => RecipientStatus::NOT_IN_MY_LIST,
      2 => RecipientStatus::IN_MY_LIST,
      3 => RecipientStatus::IN_MY_LIST_AND_DEFAULT_NOTEBOOK,
      _ => RecipientStatus(i)
    }
  }
}

impl From<&i32> for RecipientStatus {
  fn from(i: &i32) -> Self {
    RecipientStatus::from(*i)
  }
}

impl From<RecipientStatus> for i32 {
  fn from(e: RecipientStatus) -> i32 {
    e.0
  }
}

impl From<&RecipientStatus> for i32 {
  fn from(e: &RecipientStatus) -> i32 {
    e.0
  }
}

/// This enumeration defines the possible types of canMoveToContainer outcomes.
/// <p />
/// An outdated client is expected to signal a "Cannot Move, Please Upgrade To Learn Why"
/// like response to the user if an unknown enumeration value is received.
/// <dl>
/// <dt>CAN_BE_MOVED</dt>
/// <dd>Can move Notebook to Workspace.</dd>
/// <dt>INSUFFICIENT_ENTITY_PRIVILEGE</dt>
/// <dd>Can not move Notebook to Workspace, because either:
///  a) Notebook not in Workspace and insufficient privilege on Notebook
///  or b) Notebook in Workspace and membership on Workspace with insufficient privilege
///  for move</dd>
/// <dt>INSUFFICIENT_CONTAINER_PRIVILEGE</dt>
/// <dd>Notebook in Workspace and no membership on Workspace.
/// </dd>
/// </dl>
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CanMoveToContainerStatus(pub i32);

impl CanMoveToContainerStatus {
  pub const CAN_BE_MOVED: CanMoveToContainerStatus = CanMoveToContainerStatus(1);
  pub const INSUFFICIENT_ENTITY_PRIVILEGE: CanMoveToContainerStatus = CanMoveToContainerStatus(2);
  pub const INSUFFICIENT_CONTAINER_PRIVILEGE: CanMoveToContainerStatus = CanMoveToContainerStatus(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CAN_BE_MOVED,
    Self::INSUFFICIENT_ENTITY_PRIVILEGE,
    Self::INSUFFICIENT_CONTAINER_PRIVILEGE,
  ];
}

impl TSerializable for CanMoveToContainerStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CanMoveToContainerStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(CanMoveToContainerStatus::from(enum_value))
  }
}

impl From<i32> for CanMoveToContainerStatus {
  fn from(i: i32) -> Self {
    match i {
      1 => CanMoveToContainerStatus::CAN_BE_MOVED,
      2 => CanMoveToContainerStatus::INSUFFICIENT_ENTITY_PRIVILEGE,
      3 => CanMoveToContainerStatus::INSUFFICIENT_CONTAINER_PRIVILEGE,
      _ => CanMoveToContainerStatus(i)
    }
  }
}

impl From<&i32> for CanMoveToContainerStatus {
  fn from(i: &i32) -> Self {
    CanMoveToContainerStatus::from(*i)
  }
}

impl From<CanMoveToContainerStatus> for i32 {
  fn from(e: CanMoveToContainerStatus) -> i32 {
    e.0
  }
}

impl From<&CanMoveToContainerStatus> for i32 {
  fn from(e: &CanMoveToContainerStatus) -> i32 {
    e.0
  }
}

/// This enumeration defines the possible types of related content.
/// 
/// NEWS_ARTICLE: This related content is a news article
/// PROFILE_PERSON: This match refers to the profile of an individual person
/// PROFILE_ORGANIZATION: This match refers to the profile of an organization
/// REFERENCE_MATERIAL: This related content is material from reference works
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RelatedContentType(pub i32);

impl RelatedContentType {
  pub const NEWS_ARTICLE: RelatedContentType = RelatedContentType(1);
  pub const PROFILE_PERSON: RelatedContentType = RelatedContentType(2);
  pub const PROFILE_ORGANIZATION: RelatedContentType = RelatedContentType(3);
  pub const REFERENCE_MATERIAL: RelatedContentType = RelatedContentType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NEWS_ARTICLE,
    Self::PROFILE_PERSON,
    Self::PROFILE_ORGANIZATION,
    Self::REFERENCE_MATERIAL,
  ];
}

impl TSerializable for RelatedContentType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RelatedContentType> {
    let enum_value = i_prot.read_i32()?;
    Ok(RelatedContentType::from(enum_value))
  }
}

impl From<i32> for RelatedContentType {
  fn from(i: i32) -> Self {
    match i {
      1 => RelatedContentType::NEWS_ARTICLE,
      2 => RelatedContentType::PROFILE_PERSON,
      3 => RelatedContentType::PROFILE_ORGANIZATION,
      4 => RelatedContentType::REFERENCE_MATERIAL,
      _ => RelatedContentType(i)
    }
  }
}

impl From<&i32> for RelatedContentType {
  fn from(i: &i32) -> Self {
    RelatedContentType::from(*i)
  }
}

impl From<RelatedContentType> for i32 {
  fn from(e: RelatedContentType) -> i32 {
    e.0
  }
}

impl From<&RelatedContentType> for i32 {
  fn from(e: &RelatedContentType) -> i32 {
    e.0
  }
}

/// This enumeration defines the possible ways to access related content.
/// 
/// NOT_ACCESSIBLE: The content is not accessible given the user's privilege level, but
///     still worth showing as a snippet. The content url may point to a webpage that
///     explains why not, or explains how to access that content.
/// 
/// DIRECT_LINK_ACCESS_OK: The content is accessible directly, and no additional login is
///     required.
/// 
/// DIRECT_LINK_LOGIN_REQUIRED: The content is accessible directly, but an additional login
///     is required.
/// 
/// DIRECT_LINK_EMBEDDED_VIEW: The content is accessible directly, and should be shown in
///     an embedded web view.
///     If the URL refers to a secured location under our control (for example,
///     https://www.evernote.com/*), the client may include user-specific authentication
///     credentials with the request.
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RelatedContentAccess(pub i32);

impl RelatedContentAccess {
  pub const NOT_ACCESSIBLE: RelatedContentAccess = RelatedContentAccess(0);
  pub const DIRECT_LINK_ACCESS_OK: RelatedContentAccess = RelatedContentAccess(1);
  pub const DIRECT_LINK_LOGIN_REQUIRED: RelatedContentAccess = RelatedContentAccess(2);
  pub const DIRECT_LINK_EMBEDDED_VIEW: RelatedContentAccess = RelatedContentAccess(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NOT_ACCESSIBLE,
    Self::DIRECT_LINK_ACCESS_OK,
    Self::DIRECT_LINK_LOGIN_REQUIRED,
    Self::DIRECT_LINK_EMBEDDED_VIEW,
  ];
}

impl TSerializable for RelatedContentAccess {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RelatedContentAccess> {
    let enum_value = i_prot.read_i32()?;
    Ok(RelatedContentAccess::from(enum_value))
  }
}

impl From<i32> for RelatedContentAccess {
  fn from(i: i32) -> Self {
    match i {
      0 => RelatedContentAccess::NOT_ACCESSIBLE,
      1 => RelatedContentAccess::DIRECT_LINK_ACCESS_OK,
      2 => RelatedContentAccess::DIRECT_LINK_LOGIN_REQUIRED,
      3 => RelatedContentAccess::DIRECT_LINK_EMBEDDED_VIEW,
      _ => RelatedContentAccess(i)
    }
  }
}

impl From<&i32> for RelatedContentAccess {
  fn from(i: &i32) -> Self {
    RelatedContentAccess::from(*i)
  }
}

impl From<RelatedContentAccess> for i32 {
  fn from(e: RelatedContentAccess) -> i32 {
    e.0
  }
}

impl From<&RelatedContentAccess> for i32 {
  fn from(e: &RelatedContentAccess) -> i32 {
    e.0
  }
}

/// 
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserIdentityType(pub i32);

impl UserIdentityType {
  pub const EVERNOTE_USERID: UserIdentityType = UserIdentityType(1);
  pub const EMAIL: UserIdentityType = UserIdentityType(2);
  pub const IDENTITYID: UserIdentityType = UserIdentityType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EVERNOTE_USERID,
    Self::EMAIL,
    Self::IDENTITYID,
  ];
}

impl TSerializable for UserIdentityType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserIdentityType> {
    let enum_value = i_prot.read_i32()?;
    Ok(UserIdentityType::from(enum_value))
  }
}

impl From<i32> for UserIdentityType {
  fn from(i: i32) -> Self {
    match i {
      1 => UserIdentityType::EVERNOTE_USERID,
      2 => UserIdentityType::EMAIL,
      3 => UserIdentityType::IDENTITYID,
      _ => UserIdentityType(i)
    }
  }
}

impl From<&i32> for UserIdentityType {
  fn from(i: &i32) -> Self {
    UserIdentityType::from(*i)
  }
}

impl From<UserIdentityType> for i32 {
  fn from(e: UserIdentityType) -> i32 {
    e.0
  }
}

impl From<&UserIdentityType> for i32 {
  fn from(e: &UserIdentityType) -> i32 {
    e.0
  }
}

pub type InvalidationSequenceNumber = i64;

pub type IdentityID = i64;

pub type UserID = i32;

pub type Guid = String;

pub type Timestamp = i64;

pub type MessageEventID = i64;

pub type MessageThreadID = i64;

//
// Data
//

///  In several places, EDAM exchanges blocks of bytes of data for a component
///  which may be relatively large.  For example:  the contents of a clipped
///  HTML note, the bytes of an embedded image, or the recognition XML for
///  a large image.  This structure is used in the protocol to represent
///  any of those large blocks of data when they are transmitted or when
///  they are only referenced their metadata.
/// 
/// <dl>
///  <dt>bodyHash</dt>
///    <dd>This field carries a one-way hash of the contents of the
///    data body, in binary form.  The hash function is MD5<br/>
///    Length:  EDAM_HASH_LEN (exactly)
///    </dd>
/// 
///  <dt>size</dt>
///    <dd>The length, in bytes, of the data body.
///    </dd>
/// 
///  <dt>body</dt>
///    <dd>This field is set to contain the binary contents of the data
///    whenever the resource is being transferred.  If only metadata is
///    being exchanged, this field will be empty.  For example, a client could
///    notify the service about the change to an attribute for a resource
///    without transmitting the binary resource contents.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Data {
  pub body_hash: Option<Vec<u8>>,
  pub size: Option<i32>,
  pub body: Option<Vec<u8>>,
}

impl Data {
  pub fn new<F1, F2, F3>(body_hash: F1, size: F2, body: F3) -> Data where F1: Into<Option<Vec<u8>>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<u8>>> {
    Data {
      body_hash: body_hash.into(),
      size: size.into(),
      body: body.into(),
    }
  }
}

impl TSerializable for Data {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Data> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Data {
      body_hash: f_1,
      size: f_2,
      body: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Data");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.body_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("bodyHash", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.size {
      o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.body {
      o_prot.write_field_begin(&TFieldIdentifier::new("body", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserAttributes
//

///  A structure holding the optional attributes that can be stored
///  on a User.  These are generally less critical than the core User fields.
/// 
/// <dl>
///  <dt>defaultLocationName</dt>
///    <dd>the location string that should be associated
///    with the user in order to determine where notes are taken if not otherwise
///    specified.<br/>
///    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///    </dd>
/// 
///  <dt>defaultLatitude</dt>
///    <dd>if set, this is the latitude that should be
///    assigned to any notes that have no other latitude information.
///    </dd>
/// 
///  <dt>defaultLongitude</dt>
///    <dd>if set, this is the longitude that should be
///    assigned to any notes that have no other longitude information.
///    </dd>
/// 
///  <dt>preactivation</dt>
///    <dd>if set, the user account is not yet confirmed for
///    login.  I.e. the account has been created, but we are still waiting for
///    the user to complete the activation step.
///    </dd>
/// 
///  <dt>viewedPromotions</dt>
///    <dd>a list of promotions the user has seen.
///     This list may occasionally be modified by the system when promotions are
///     no longer available.<br/>
///     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///    </dd>
/// 
///  <dt>incomingEmailAddress</dt>
///    <dd>if set, this is the email address that the
///     user may send email to in order to add an email note directly into the
///     account via the SMTP email gateway.  This is the part of the email
///     address before the '@' symbol ... our domain is not included.
///     If this is not set, the user may not add notes via the gateway.<br/>
///     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///    </dd>
/// 
///  <dt>recentMailedAddresses</dt>
///    <dd>if set, this will contain a list of email
///     addresses that have recently been used as recipients
///     of outbound emails by the user.  This can be used to pre-populate a
///     list of possible destinations when a user wishes to send a note via
///     email.<br/>
///     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX each<br/>
///     Max:  EDAM_USER_RECENT_MAILED_ADDRESSES_MAX entries
///    </dd>
/// 
///  <dt>comments</dt>
///    <dd>Free-form text field that may hold general support
///     information, etc.<br/>
///     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///    </dd>
/// 
///  <dt>dateAgreedToTermsOfService</dt>
///    <dd>The date/time when the user agreed to
///     the terms of service.  This can be used as the effective "start date"
///     for the account.
///    </dd>
/// 
///  <dt>maxReferrals</dt>
///    <dd>The number of referrals that the user is permitted
///     to make.
///    </dd>
/// 
///  <dt>referralCount</dt>
///    <dd>The number of referrals sent from this account.
///    </dd>
/// 
///  <dt>refererCode</dt>
///    <dd>A code indicating where the user was sent from. AKA
///     promotion code
///    </dd>
/// 
///  <dt>sentEmailDate</dt>
///    <dd>The most recent date when the user sent outbound
///     emails from the service.  Used with sentEmailCount to limit the number
///     of emails that can be sent per day.
///    </dd>
/// 
///  <dt>sentEmailCount</dt>
///    <dd>The number of emails that were sent from the user
///     via the service on sentEmailDate.  Used to enforce a limit on the number
///     of emails per user per day to prevent spamming.
///    </dd>
/// 
///  <dt>dailyEmailLimit</dt>
///    <dd>If set, this is the maximum number of emails that
///     may be sent in a given day from this account.  If unset, the server will
///     use the configured default limit.
///    </dd>
/// 
///  <dt>emailOptOutDate</dt>
///    <dd>If set, this is the date when the user asked
///     to be excluded from offers and promotions sent by Evernote.  If not set,
///     then the user currently agrees to receive these messages.
///    </dd>
/// 
///  <dt>partnerEmailOptInDate</dt>
///    <dd>If set, this is the date when the user asked
///     to be included in offers and promotions sent by Evernote's partners.
///     If not sent, then the user currently does not agree to receive these
///     emails.
///    </dd>
/// 
///  <dt>preferredLanguage</dt>
///    <dd>a 2 character language codes based on:
///        http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt used for
///       localization purposes to determine what language to use for the web
///       interface and for other direct communication (e.g. emails).
///    </dd>
/// 
///  <dt>preferredCountry</dt>
///    <dd>Preferred country code based on ISO 3166-1-alpha-2 indicating the
///    users preferred country</dd>
/// 
///  <dt>clipFullPage</dt>
///    <dd>Boolean flag set to true if the user wants to clip full pages by
///    default when they use the web clipper without a selection.</dd>
/// 
///  <dt>twitterUserName</dt>
///    <dd>The username of the account of someone who has chosen to enable
///    Twittering into Evernote.  This value is subject to change, since users
///    may change their Twitter user name.</dd>
/// 
///  <dt>twitterId</dt>
///    <dd>The unique identifier of the user's Twitter account if that user
///    has chosen to enable Twittering into Evernote.</dd>
/// 
///  <dt>groupName</dt>
///    <dd>A name identifier used to identify a particular set of branding and
///     light customization.</dd>
/// 
///  <dt>recognitionLanguage</dt>
///    <dd>a 2 character language codes based on:
///        http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt
///        If set, this is used to determine the language that should be used
///        when processing images and PDF files to find text.
///        If not set, then the 'preferredLanguage' will be used.
///    </dd>
/// 
///  <dt>educationalInstitution</dt>
///    <dd>a flag indicating that the user is part of an educational institution which
///    makes them eligible for discounts on bulk purchases
///    </dd>
/// 
///  <dt>businessAddress</dt>
///    <dd>A string recording the business address of a Sponsored Account user who has requested invoicing.
///    </dd>
/// 
///  <dt>hideSponsorBilling</dt>
///    <dd>A flag indicating whether to hide the billing information on a sponsored
///        account owner's settings page
///    </dd>
/// 
///  <dt>useEmailAutoFiling</dt>
///    <dd>A flag indicating whether the user chooses to allow Evernote to automatically
///        file and tag emailed notes
///    </dd>
/// 
///  <dt>reminderEmailConfig</dt>
///    <dd>Configuration state for whether or not the user wishes to receive
///        reminder e-mail.  This setting applies to both the reminder e-mail sent
///        for personal reminder notes and for the reminder e-mail sent for reminder
///        notes in the user's business notebooks that the user has configured for
///        e-mail notifications.
///    </dd>
/// 
///  <dt>emailAddressLastConfirmed</dt>
///    <dd>If set, this contains the time at which the user last confirmed that the
///        configured email address for this account is correct and up-to-date. If this is
///        unset that indicates that the user's email address is unverified.
///    </dd>
/// 
///  <dt>passwordUpdated</dt>
///    <dd>If set, this contains the time at which the user's password last changed. This
///        will be unset for users created before the addition of this field who have not
///        changed their passwords since the addition of this field.
///    </dd>
/// 
///  <dt>shouldLogClientEvent</dt>
///    <dd>If set to True, the server will record LogRequest send from clients of this
///         user as ClientEventLog.
///    </dd>
/// 
///  <dt>optOutMachineLearning</dt>
///    <dd>If set to True, no Machine Learning nor human review will be done to this
///         user's note contents.
///    </dd>
///    </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserAttributes {
  pub default_location_name: Option<String>,
  pub default_latitude: Option<OrderedFloat<f64>>,
  pub default_longitude: Option<OrderedFloat<f64>>,
  pub preactivation: Option<bool>,
  pub viewed_promotions: Option<Vec<String>>,
  pub incoming_email_address: Option<String>,
  pub recent_mailed_addresses: Option<Vec<String>>,
  pub comments: Option<String>,
  pub date_agreed_to_terms_of_service: Option<Timestamp>,
  pub max_referrals: Option<i32>,
  pub referral_count: Option<i32>,
  pub referer_code: Option<String>,
  pub sent_email_date: Option<Timestamp>,
  pub sent_email_count: Option<i32>,
  pub daily_email_limit: Option<i32>,
  pub email_opt_out_date: Option<Timestamp>,
  pub partner_email_opt_in_date: Option<Timestamp>,
  pub preferred_language: Option<String>,
  pub preferred_country: Option<String>,
  pub clip_full_page: Option<bool>,
  pub twitter_user_name: Option<String>,
  pub twitter_id: Option<String>,
  pub group_name: Option<String>,
  pub recognition_language: Option<String>,
  pub referral_proof: Option<String>,
  pub educational_discount: Option<bool>,
  pub business_address: Option<String>,
  pub hide_sponsor_billing: Option<bool>,
  pub use_email_auto_filing: Option<bool>,
  pub reminder_email_config: Option<ReminderEmailConfig>,
  pub email_address_last_confirmed: Option<Timestamp>,
  pub password_updated: Option<Timestamp>,
  pub salesforce_push_enabled: Option<bool>,
  pub should_log_client_event: Option<bool>,
  pub opt_out_machine_learning: Option<bool>,
}

impl UserAttributes {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F9, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F28, F29, F30, F31, F33, F34, F35, F36, F37, F38, F39>(default_location_name: F1, default_latitude: F2, default_longitude: F3, preactivation: F4, viewed_promotions: F5, incoming_email_address: F6, recent_mailed_addresses: F7, comments: F9, date_agreed_to_terms_of_service: F11, max_referrals: F12, referral_count: F13, referer_code: F14, sent_email_date: F15, sent_email_count: F16, daily_email_limit: F17, email_opt_out_date: F18, partner_email_opt_in_date: F19, preferred_language: F20, preferred_country: F21, clip_full_page: F22, twitter_user_name: F23, twitter_id: F24, group_name: F25, recognition_language: F26, referral_proof: F28, educational_discount: F29, business_address: F30, hide_sponsor_billing: F31, use_email_auto_filing: F33, reminder_email_config: F34, email_address_last_confirmed: F35, password_updated: F36, salesforce_push_enabled: F37, should_log_client_event: F38, opt_out_machine_learning: F39) -> UserAttributes where F1: Into<Option<String>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<bool>>, F5: Into<Option<Vec<String>>>, F6: Into<Option<String>>, F7: Into<Option<Vec<String>>>, F9: Into<Option<String>>, F11: Into<Option<Timestamp>>, F12: Into<Option<i32>>, F13: Into<Option<i32>>, F14: Into<Option<String>>, F15: Into<Option<Timestamp>>, F16: Into<Option<i32>>, F17: Into<Option<i32>>, F18: Into<Option<Timestamp>>, F19: Into<Option<Timestamp>>, F20: Into<Option<String>>, F21: Into<Option<String>>, F22: Into<Option<bool>>, F23: Into<Option<String>>, F24: Into<Option<String>>, F25: Into<Option<String>>, F26: Into<Option<String>>, F28: Into<Option<String>>, F29: Into<Option<bool>>, F30: Into<Option<String>>, F31: Into<Option<bool>>, F33: Into<Option<bool>>, F34: Into<Option<ReminderEmailConfig>>, F35: Into<Option<Timestamp>>, F36: Into<Option<Timestamp>>, F37: Into<Option<bool>>, F38: Into<Option<bool>>, F39: Into<Option<bool>> {
    UserAttributes {
      default_location_name: default_location_name.into(),
      default_latitude: default_latitude.into(),
      default_longitude: default_longitude.into(),
      preactivation: preactivation.into(),
      viewed_promotions: viewed_promotions.into(),
      incoming_email_address: incoming_email_address.into(),
      recent_mailed_addresses: recent_mailed_addresses.into(),
      comments: comments.into(),
      date_agreed_to_terms_of_service: date_agreed_to_terms_of_service.into(),
      max_referrals: max_referrals.into(),
      referral_count: referral_count.into(),
      referer_code: referer_code.into(),
      sent_email_date: sent_email_date.into(),
      sent_email_count: sent_email_count.into(),
      daily_email_limit: daily_email_limit.into(),
      email_opt_out_date: email_opt_out_date.into(),
      partner_email_opt_in_date: partner_email_opt_in_date.into(),
      preferred_language: preferred_language.into(),
      preferred_country: preferred_country.into(),
      clip_full_page: clip_full_page.into(),
      twitter_user_name: twitter_user_name.into(),
      twitter_id: twitter_id.into(),
      group_name: group_name.into(),
      recognition_language: recognition_language.into(),
      referral_proof: referral_proof.into(),
      educational_discount: educational_discount.into(),
      business_address: business_address.into(),
      hide_sponsor_billing: hide_sponsor_billing.into(),
      use_email_auto_filing: use_email_auto_filing.into(),
      reminder_email_config: reminder_email_config.into(),
      email_address_last_confirmed: email_address_last_confirmed.into(),
      password_updated: password_updated.into(),
      salesforce_push_enabled: salesforce_push_enabled.into(),
      should_log_client_event: should_log_client_event.into(),
      opt_out_machine_learning: opt_out_machine_learning.into(),
    }
  }
}

impl TSerializable for UserAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<OrderedFloat<f64>> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<Vec<String>> = None;
    let mut f_9: Option<String> = None;
    let mut f_11: Option<Timestamp> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<i32> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<Timestamp> = None;
    let mut f_16: Option<i32> = None;
    let mut f_17: Option<i32> = None;
    let mut f_18: Option<Timestamp> = None;
    let mut f_19: Option<Timestamp> = None;
    let mut f_20: Option<String> = None;
    let mut f_21: Option<String> = None;
    let mut f_22: Option<bool> = None;
    let mut f_23: Option<String> = None;
    let mut f_24: Option<String> = None;
    let mut f_25: Option<String> = None;
    let mut f_26: Option<String> = None;
    let mut f_28: Option<String> = None;
    let mut f_29: Option<bool> = None;
    let mut f_30: Option<String> = None;
    let mut f_31: Option<bool> = None;
    let mut f_33: Option<bool> = None;
    let mut f_34: Option<ReminderEmailConfig> = None;
    let mut f_35: Option<Timestamp> = None;
    let mut f_36: Option<Timestamp> = None;
    let mut f_37: Option<bool> = None;
    let mut f_38: Option<bool> = None;
    let mut f_39: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_string()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i32()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i32()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_i64()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i64()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_bool()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_string()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_string()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_string()?;
          f_25 = Some(val);
        },
        26 => {
          let val = i_prot.read_string()?;
          f_26 = Some(val);
        },
        28 => {
          let val = i_prot.read_string()?;
          f_28 = Some(val);
        },
        29 => {
          let val = i_prot.read_bool()?;
          f_29 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        33 => {
          let val = i_prot.read_bool()?;
          f_33 = Some(val);
        },
        34 => {
          let val = ReminderEmailConfig::read_from_in_protocol(i_prot)?;
          f_34 = Some(val);
        },
        35 => {
          let val = i_prot.read_i64()?;
          f_35 = Some(val);
        },
        36 => {
          let val = i_prot.read_i64()?;
          f_36 = Some(val);
        },
        37 => {
          let val = i_prot.read_bool()?;
          f_37 = Some(val);
        },
        38 => {
          let val = i_prot.read_bool()?;
          f_38 = Some(val);
        },
        39 => {
          let val = i_prot.read_bool()?;
          f_39 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserAttributes {
      default_location_name: f_1,
      default_latitude: f_2,
      default_longitude: f_3,
      preactivation: f_4,
      viewed_promotions: f_5,
      incoming_email_address: f_6,
      recent_mailed_addresses: f_7,
      comments: f_9,
      date_agreed_to_terms_of_service: f_11,
      max_referrals: f_12,
      referral_count: f_13,
      referer_code: f_14,
      sent_email_date: f_15,
      sent_email_count: f_16,
      daily_email_limit: f_17,
      email_opt_out_date: f_18,
      partner_email_opt_in_date: f_19,
      preferred_language: f_20,
      preferred_country: f_21,
      clip_full_page: f_22,
      twitter_user_name: f_23,
      twitter_id: f_24,
      group_name: f_25,
      recognition_language: f_26,
      referral_proof: f_28,
      educational_discount: f_29,
      business_address: f_30,
      hide_sponsor_billing: f_31,
      use_email_auto_filing: f_33,
      reminder_email_config: f_34,
      email_address_last_confirmed: f_35,
      password_updated: f_36,
      salesforce_push_enabled: f_37,
      should_log_client_event: f_38,
      opt_out_machine_learning: f_39,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.default_location_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("defaultLocationName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.default_latitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("defaultLatitude", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.default_longitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("defaultLongitude", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.preactivation {
      o_prot.write_field_begin(&TFieldIdentifier::new("preactivation", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.viewed_promotions {
      o_prot.write_field_begin(&TFieldIdentifier::new("viewedPromotions", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.incoming_email_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("incomingEmailAddress", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recent_mailed_addresses {
      o_prot.write_field_begin(&TFieldIdentifier::new("recentMailedAddresses", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.comments {
      o_prot.write_field_begin(&TFieldIdentifier::new("comments", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.date_agreed_to_terms_of_service {
      o_prot.write_field_begin(&TFieldIdentifier::new("dateAgreedToTermsOfService", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_referrals {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxReferrals", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.referral_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("referralCount", TType::I32, 13))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.referer_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("refererCode", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sent_email_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("sentEmailDate", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sent_email_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("sentEmailCount", TType::I32, 16))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.daily_email_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("dailyEmailLimit", TType::I32, 17))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.email_opt_out_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("emailOptOutDate", TType::I64, 18))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.partner_email_opt_in_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("partnerEmailOptInDate", TType::I64, 19))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.preferred_language {
      o_prot.write_field_begin(&TFieldIdentifier::new("preferredLanguage", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.preferred_country {
      o_prot.write_field_begin(&TFieldIdentifier::new("preferredCountry", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.clip_full_page {
      o_prot.write_field_begin(&TFieldIdentifier::new("clipFullPage", TType::Bool, 22))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.twitter_user_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("twitterUserName", TType::String, 23))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.twitter_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("twitterId", TType::String, 24))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.group_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("groupName", TType::String, 25))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recognition_language {
      o_prot.write_field_begin(&TFieldIdentifier::new("recognitionLanguage", TType::String, 26))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.referral_proof {
      o_prot.write_field_begin(&TFieldIdentifier::new("referralProof", TType::String, 28))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.educational_discount {
      o_prot.write_field_begin(&TFieldIdentifier::new("educationalDiscount", TType::Bool, 29))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.business_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessAddress", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.hide_sponsor_billing {
      o_prot.write_field_begin(&TFieldIdentifier::new("hideSponsorBilling", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_email_auto_filing {
      o_prot.write_field_begin(&TFieldIdentifier::new("useEmailAutoFiling", TType::Bool, 33))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reminder_email_config {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderEmailConfig", TType::I32, 34))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.email_address_last_confirmed {
      o_prot.write_field_begin(&TFieldIdentifier::new("emailAddressLastConfirmed", TType::I64, 35))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.password_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("passwordUpdated", TType::I64, 36))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.salesforce_push_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("salesforcePushEnabled", TType::Bool, 37))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.should_log_client_event {
      o_prot.write_field_begin(&TFieldIdentifier::new("shouldLogClientEvent", TType::Bool, 38))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.opt_out_machine_learning {
      o_prot.write_field_begin(&TFieldIdentifier::new("optOutMachineLearning", TType::Bool, 39))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BusinessUserAttributes
//

/// A structure holding the optional attributes associated with users
/// in a business.
/// 
/// <dl>
///  <dt>title</dt>
///  <dd>Free form text of this user's title in the business</dd>
/// 
///  <dt>location</dt>
///  <dd>City, State (for US) or City / Province for other countries</dd>
/// 
///  <dt>department</dt>
///  <dd>Free form text of the department this user belongs to.</dd>
/// 
///  <dt>mobilePhone</dt>
///  <dd>User's mobile phone number. Stored as plain text without any formatting.</dd>
/// 
///  <dt>linkedInProfileUrl</dt>
///  <dd>URL to user's public LinkedIn profile page. This should only contain
///  the portion relative to the base LinkedIn URL. For example: "/pub/john-smith/".
///  </dd>
/// 
///  <dt>workPhone</dt>
///  <dd>User's work phone number. Stored as plain text without any formatting.</dd>
/// 
///  <dt>companyStartDate</dt>
///  <dd>The date on which the user started working at their company.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BusinessUserAttributes {
  pub title: Option<String>,
  pub location: Option<String>,
  pub department: Option<String>,
  pub mobile_phone: Option<String>,
  pub linked_in_profile_url: Option<String>,
  pub work_phone: Option<String>,
  pub company_start_date: Option<Timestamp>,
}

impl BusinessUserAttributes {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(title: F1, location: F2, department: F3, mobile_phone: F4, linked_in_profile_url: F5, work_phone: F6, company_start_date: F7) -> BusinessUserAttributes where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<Timestamp>> {
    BusinessUserAttributes {
      title: title.into(),
      location: location.into(),
      department: department.into(),
      mobile_phone: mobile_phone.into(),
      linked_in_profile_url: linked_in_profile_url.into(),
      work_phone: work_phone.into(),
      company_start_date: company_start_date.into(),
    }
  }
}

impl TSerializable for BusinessUserAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BusinessUserAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<Timestamp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BusinessUserAttributes {
      title: f_1,
      location: f_2,
      department: f_3,
      mobile_phone: f_4,
      linked_in_profile_url: f_5,
      work_phone: f_6,
      company_start_date: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BusinessUserAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.location {
      o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.department {
      o_prot.write_field_begin(&TFieldIdentifier::new("department", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.mobile_phone {
      o_prot.write_field_begin(&TFieldIdentifier::new("mobilePhone", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.linked_in_profile_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("linkedInProfileUrl", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.work_phone {
      o_prot.write_field_begin(&TFieldIdentifier::new("workPhone", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.company_start_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("companyStartDate", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Accounting
//

///  This represents the bookkeeping information for the user's subscription.
/// 
/// <dl>
///  <dt>uploadLimitEnd</dt>
///    <dd>The date and time when the current upload limit
///    expires.  At this time, the monthly upload count reverts to 0 and a new
///    limit is imposed.  This date and time is exclusive, so this is effectively
///    the start of the new month.
///    </dd>
///  <dt>uploadLimitNextMonth</dt>
///    <dd> When uploadLimitEnd is reached, the service
///    will change uploadLimit to uploadLimitNextMonth. If a premium account is
///    canceled, this mechanism will reset the quota appropriately.
///    </dd>
///  <dt>premiumServiceStatus</dt>
///    <dd>Indicates the phases of a premium account
///    during the billing process.
///    </dd>
///  <dt>premiumOrderNumber</dt>
///    <dd>The order number used by the commerce system to
///    process recurring payments
///    </dd>
///  <dt>premiumServiceStart</dt>
///    <dd>The start date when this premium promotion
///    began (this number will get overwritten if a premium service is canceled
///    and then re-activated).
///    </dd>
///  <dt>premiumCommerceService</dt>
///    <dd>The commerce system used (paypal, Google
///    checkout, etc)
///    </dd>
///  <dt>premiumServiceSKU</dt>
///    <dd>The code associated with the purchase eg. monthly
///    or annual purchase. Clients should interpret this value and localize it.
///    </dd>
///  <dt>lastSuccessfulCharge</dt>
///    <dd>Date the last time the user was charged.
///    Null if never charged.
///    </dd>
///  <dt>lastFailedCharge</dt>
///    <dd>Date the last time a charge was attempted and
///    failed.
///    </dd>
///  <dt>lastFailedChargeReason</dt>
///    <dd>Reason provided for the charge failure
///    </dd>
///  <dt>nextPaymentDue</dt>
///    <dd>The end of the billing cycle. This could be in the
///    past if there are failed charges.
///    </dd>
///  <dt>premiumLockUntil</dt>
///    <dd>An internal variable to manage locking operations
///    on the commerce variables.
///    </dd>
///  <dt>updated</dt>
///    <dd>The date any modification where made to this record.
///    </dd>
///  <dt>premiumSubscriptionNumber</dt>
///    <dd>The number number identifying the
///    recurring subscription used to make the recurring charges.
///    </dd>
///  <dt>lastRequestedCharge</dt>
///    <dd>Date charge last attempted</dd>
///  <dt>currency</dt>
///    <dd>ISO 4217 currency code</dd>
///  <dt>unitPrice</dt>
///    <dd>charge in the smallest unit of the currency (e.g. cents for USD)</dd>
///  <dt>businessId</dt>
///    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
///  <dt>businessName</dt>
///    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
///  <dt>businessRole</dt>
///    <dd><i>DEPRECATED:</i>See BusinessUserInfo.</dd>
///  <dt>unitDiscount</dt>
///    <dd>discount per seat in negative amount and smallest unit of the currency (e.g.
///        cents for USD)</dd>
///  <dt>nextChargeDate</dt>
///    <dd>The next time the user will be charged, may or may not be the same as
///        nextPaymentDue</dd>
///  </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Accounting {
  pub upload_limit_end: Option<Timestamp>,
  pub upload_limit_next_month: Option<i64>,
  pub premium_service_status: Option<PremiumOrderStatus>,
  pub premium_order_number: Option<String>,
  pub premium_commerce_service: Option<String>,
  pub premium_service_start: Option<Timestamp>,
  pub premium_service_s_k_u: Option<String>,
  pub last_successful_charge: Option<Timestamp>,
  pub last_failed_charge: Option<Timestamp>,
  pub last_failed_charge_reason: Option<String>,
  pub next_payment_due: Option<Timestamp>,
  pub premium_lock_until: Option<Timestamp>,
  pub updated: Option<Timestamp>,
  pub premium_subscription_number: Option<String>,
  pub last_requested_charge: Option<Timestamp>,
  pub currency: Option<String>,
  pub unit_price: Option<i32>,
  pub business_id: Option<i32>,
  pub business_name: Option<String>,
  pub business_role: Option<BusinessUserRole>,
  pub unit_discount: Option<i32>,
  pub next_charge_date: Option<Timestamp>,
  pub available_points: Option<i32>,
}

impl Accounting {
  pub fn new<F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25>(upload_limit_end: F2, upload_limit_next_month: F3, premium_service_status: F4, premium_order_number: F5, premium_commerce_service: F6, premium_service_start: F7, premium_service_s_k_u: F8, last_successful_charge: F9, last_failed_charge: F10, last_failed_charge_reason: F11, next_payment_due: F12, premium_lock_until: F13, updated: F14, premium_subscription_number: F16, last_requested_charge: F17, currency: F18, unit_price: F19, business_id: F20, business_name: F21, business_role: F22, unit_discount: F23, next_charge_date: F24, available_points: F25) -> Accounting where F2: Into<Option<Timestamp>>, F3: Into<Option<i64>>, F4: Into<Option<PremiumOrderStatus>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<Timestamp>>, F8: Into<Option<String>>, F9: Into<Option<Timestamp>>, F10: Into<Option<Timestamp>>, F11: Into<Option<String>>, F12: Into<Option<Timestamp>>, F13: Into<Option<Timestamp>>, F14: Into<Option<Timestamp>>, F16: Into<Option<String>>, F17: Into<Option<Timestamp>>, F18: Into<Option<String>>, F19: Into<Option<i32>>, F20: Into<Option<i32>>, F21: Into<Option<String>>, F22: Into<Option<BusinessUserRole>>, F23: Into<Option<i32>>, F24: Into<Option<Timestamp>>, F25: Into<Option<i32>> {
    Accounting {
      upload_limit_end: upload_limit_end.into(),
      upload_limit_next_month: upload_limit_next_month.into(),
      premium_service_status: premium_service_status.into(),
      premium_order_number: premium_order_number.into(),
      premium_commerce_service: premium_commerce_service.into(),
      premium_service_start: premium_service_start.into(),
      premium_service_s_k_u: premium_service_s_k_u.into(),
      last_successful_charge: last_successful_charge.into(),
      last_failed_charge: last_failed_charge.into(),
      last_failed_charge_reason: last_failed_charge_reason.into(),
      next_payment_due: next_payment_due.into(),
      premium_lock_until: premium_lock_until.into(),
      updated: updated.into(),
      premium_subscription_number: premium_subscription_number.into(),
      last_requested_charge: last_requested_charge.into(),
      currency: currency.into(),
      unit_price: unit_price.into(),
      business_id: business_id.into(),
      business_name: business_name.into(),
      business_role: business_role.into(),
      unit_discount: unit_discount.into(),
      next_charge_date: next_charge_date.into(),
      available_points: available_points.into(),
    }
  }
}

impl TSerializable for Accounting {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Accounting> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<Timestamp> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<PremiumOrderStatus> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<Timestamp> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<Timestamp> = None;
    let mut f_10: Option<Timestamp> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<Timestamp> = None;
    let mut f_13: Option<Timestamp> = None;
    let mut f_14: Option<Timestamp> = None;
    let mut f_16: Option<String> = None;
    let mut f_17: Option<Timestamp> = None;
    let mut f_18: Option<String> = None;
    let mut f_19: Option<i32> = None;
    let mut f_20: Option<i32> = None;
    let mut f_21: Option<String> = None;
    let mut f_22: Option<BusinessUserRole> = None;
    let mut f_23: Option<i32> = None;
    let mut f_24: Option<Timestamp> = None;
    let mut f_25: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = PremiumOrderStatus::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i64()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_string()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i32()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let val = BusinessUserRole::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_i32()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_i64()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_i32()?;
          f_25 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Accounting {
      upload_limit_end: f_2,
      upload_limit_next_month: f_3,
      premium_service_status: f_4,
      premium_order_number: f_5,
      premium_commerce_service: f_6,
      premium_service_start: f_7,
      premium_service_s_k_u: f_8,
      last_successful_charge: f_9,
      last_failed_charge: f_10,
      last_failed_charge_reason: f_11,
      next_payment_due: f_12,
      premium_lock_until: f_13,
      updated: f_14,
      premium_subscription_number: f_16,
      last_requested_charge: f_17,
      currency: f_18,
      unit_price: f_19,
      business_id: f_20,
      business_name: f_21,
      business_role: f_22,
      unit_discount: f_23,
      next_charge_date: f_24,
      available_points: f_25,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Accounting");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.upload_limit_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("uploadLimitEnd", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.upload_limit_next_month {
      o_prot.write_field_begin(&TFieldIdentifier::new("uploadLimitNextMonth", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.premium_service_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("premiumServiceStatus", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.premium_order_number {
      o_prot.write_field_begin(&TFieldIdentifier::new("premiumOrderNumber", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.premium_commerce_service {
      o_prot.write_field_begin(&TFieldIdentifier::new("premiumCommerceService", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.premium_service_start {
      o_prot.write_field_begin(&TFieldIdentifier::new("premiumServiceStart", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.premium_service_s_k_u {
      o_prot.write_field_begin(&TFieldIdentifier::new("premiumServiceSKU", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_successful_charge {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastSuccessfulCharge", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_failed_charge {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailedCharge", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_failed_charge_reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailedChargeReason", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.next_payment_due {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPaymentDue", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.premium_lock_until {
      o_prot.write_field_begin(&TFieldIdentifier::new("premiumLockUntil", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("updated", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.premium_subscription_number {
      o_prot.write_field_begin(&TFieldIdentifier::new("premiumSubscriptionNumber", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_requested_charge {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastRequestedCharge", TType::I64, 17))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.currency {
      o_prot.write_field_begin(&TFieldIdentifier::new("currency", TType::String, 18))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.unit_price {
      o_prot.write_field_begin(&TFieldIdentifier::new("unitPrice", TType::I32, 19))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.business_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessId", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.business_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessName", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.business_role {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessRole", TType::I32, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.unit_discount {
      o_prot.write_field_begin(&TFieldIdentifier::new("unitDiscount", TType::I32, 23))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.next_charge_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextChargeDate", TType::I64, 24))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.available_points {
      o_prot.write_field_begin(&TFieldIdentifier::new("availablePoints", TType::I32, 25))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BusinessUserInfo
//

/// This structure is used to provide information about an Evernote Business
/// membership, for members who are part of a business.
/// 
/// <dl>
/// <dt>businessId</dt>
///   <dd>The ID of the Evernote Business account that the user is a member of.
/// <dt>businessName</dt>
///   <dd>The human-readable name of the Evernote Business account that the user
///       is a member of.</dd>
/// <dt>role</dt>
///   <dd>The role of the user within the Evernote Business account that
///       they are a member of.</dd>
/// <dt>email</dt>
///   <dd>An e-mail address that will be used by the service in the context of your
///       Evernote Business activities.  For example, this e-mail address will be used
///       when you e-mail a business note, when you update notes in the account of
///       your business, etc.  The business e-mail cannot be used for identification
///       purposes such as for logging into the service.
///   </dd>
/// <dt>updated</dt>
///   <dd>Last time the business user or business user attributes were updated.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BusinessUserInfo {
  pub business_id: Option<i32>,
  pub business_name: Option<String>,
  pub role: Option<BusinessUserRole>,
  pub email: Option<String>,
  pub updated: Option<Timestamp>,
}

impl BusinessUserInfo {
  pub fn new<F1, F2, F3, F4, F5>(business_id: F1, business_name: F2, role: F3, email: F4, updated: F5) -> BusinessUserInfo where F1: Into<Option<i32>>, F2: Into<Option<String>>, F3: Into<Option<BusinessUserRole>>, F4: Into<Option<String>>, F5: Into<Option<Timestamp>> {
    BusinessUserInfo {
      business_id: business_id.into(),
      business_name: business_name.into(),
      role: role.into(),
      email: email.into(),
      updated: updated.into(),
    }
  }
}

impl TSerializable for BusinessUserInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BusinessUserInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BusinessUserRole> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Timestamp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = BusinessUserRole::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BusinessUserInfo {
      business_id: f_1,
      business_name: f_2,
      role: f_3,
      email: f_4,
      updated: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BusinessUserInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.business_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessId", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.business_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.role {
      o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("updated", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AccountLimits
//

///  This structure is used to provide account limits that are in effect for this user.
/// <dl>
///  <dt>userMailLimitDaily</dt>
///    <dd>The number of emails of any type that can be sent by a user from the
///        service per day.  If an email is sent to two different recipients, this
///        counts as two emails.
///    </dd>
///  <dt>noteSizeMax</dt>
///    <dd>Maximum total size of a Note that can be added.  The size of a note is
///        calculated as:
///        ENML content length (in Unicode characters) plus the sum of all resource
///        sizes (in bytes).
///    </dd>
///  <dt>resourceSizeMax</dt>
///    <dd>Maximum size of a resource, in bytes
///    </dd>
///  <dt>userLinkedNotebookMax</dt>
///    <dd>Maximum number of linked notebooks per account.
///    </dd>
///  <dt>uploadLimit</dt>
///    <dd>The number of bytes that can be uploaded to the account
///    in the current month.  For new notes that are created, this is the length
///    of the note content (in Unicode characters) plus the size of each resource
///    (in bytes).  For edited notes, this is the the difference between the old
///    length and the new length (if this is greater than 0) plus the size of
///    each new resource.
///    </dd>
///  <dt>userNoteCountMax</dt>
///    <dd>Maximum number of Notes per user</dd>
///  <dt>userNotebookCountMax</dt>
///    <dd>Maximum number of Notebooks per user</dd>
///  <dt>userTagCountMax</dt>
///    <dd>Maximum number of Tags per account</dd>
///  <dt>noteTagCountMax</dt>
///    <dd>Maximum number of Tags per Note</dd>
///  <dt>userSavedSearchesMax</dt>
///    <dd>Maximum number of SavedSearches per account</dd>
///  <dt>noteResourceCountMax</dt>
///    <dd>The maximum number of Resources per Note</dd>
///  </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AccountLimits {
  pub user_mail_limit_daily: Option<i32>,
  pub note_size_max: Option<i64>,
  pub resource_size_max: Option<i64>,
  pub user_linked_notebook_max: Option<i32>,
  pub upload_limit: Option<i64>,
  pub user_note_count_max: Option<i32>,
  pub user_notebook_count_max: Option<i32>,
  pub user_tag_count_max: Option<i32>,
  pub note_tag_count_max: Option<i32>,
  pub user_saved_searches_max: Option<i32>,
  pub note_resource_count_max: Option<i32>,
}

impl AccountLimits {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(user_mail_limit_daily: F1, note_size_max: F2, resource_size_max: F3, user_linked_notebook_max: F4, upload_limit: F5, user_note_count_max: F6, user_notebook_count_max: F7, user_tag_count_max: F8, note_tag_count_max: F9, user_saved_searches_max: F10, note_resource_count_max: F11) -> AccountLimits where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i32>>, F5: Into<Option<i64>>, F6: Into<Option<i32>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<i32>>, F10: Into<Option<i32>>, F11: Into<Option<i32>> {
    AccountLimits {
      user_mail_limit_daily: user_mail_limit_daily.into(),
      note_size_max: note_size_max.into(),
      resource_size_max: resource_size_max.into(),
      user_linked_notebook_max: user_linked_notebook_max.into(),
      upload_limit: upload_limit.into(),
      user_note_count_max: user_note_count_max.into(),
      user_notebook_count_max: user_notebook_count_max.into(),
      user_tag_count_max: user_tag_count_max.into(),
      note_tag_count_max: note_tag_count_max.into(),
      user_saved_searches_max: user_saved_searches_max.into(),
      note_resource_count_max: note_resource_count_max.into(),
    }
  }
}

impl TSerializable for AccountLimits {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccountLimits> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AccountLimits {
      user_mail_limit_daily: f_1,
      note_size_max: f_2,
      resource_size_max: f_3,
      user_linked_notebook_max: f_4,
      upload_limit: f_5,
      user_note_count_max: f_6,
      user_notebook_count_max: f_7,
      user_tag_count_max: f_8,
      note_tag_count_max: f_9,
      user_saved_searches_max: f_10,
      note_resource_count_max: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccountLimits");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.user_mail_limit_daily {
      o_prot.write_field_begin(&TFieldIdentifier::new("userMailLimitDaily", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.note_size_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteSizeMax", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.resource_size_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourceSizeMax", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_linked_notebook_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("userLinkedNotebookMax", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.upload_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("uploadLimit", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_note_count_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("userNoteCountMax", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_notebook_count_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("userNotebookCountMax", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_tag_count_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("userTagCountMax", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.note_tag_count_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteTagCountMax", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_saved_searches_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("userSavedSearchesMax", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.note_resource_count_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteResourceCountMax", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// User
//

///  This represents the information about a single user account.
/// <dl>
///  <dt>id</dt>
///    <dd>The unique numeric identifier for the account, which will not
///    change for the lifetime of the account.
///    </dd>
/// 
///  <dt>username</dt>
///    <dd>The name that uniquely identifies a single user account. This name
///    may be presented by the user, along with their password, to log into
///    their account.
///    May only contain a-z, 0-9, or '-', and may not start or end with the '-'
///    <br/>
///    Length:  EDAM_USER_USERNAME_LEN_MIN - EDAM_USER_USERNAME_LEN_MAX
///    <br/>
///    Regex:  EDAM_USER_USERNAME_REGEX
///    </dd>
/// 
///  <dt>email</dt>
///    <dd>The email address registered for the user.  Must comply with
///    RFC 2821 and RFC 2822.<br/>
///    Third party applications that authenticate using OAuth do not have
///    access to this field.
///    Length:  EDAM_EMAIL_LEN_MIN - EDAM_EMAIL_LEN_MAX
///    <br/>
///    Regex:  EDAM_EMAIL_REGEX
///    </dd>
/// 
///  <dt>name</dt>
///    <dd>The printable name of the user, which may be a combination
///    of given and family names.  This is used instead of separate "first"
///    and "last" names due to variations in international name format/order.
///    May not start or end with a whitespace character.  May contain any
///    character but carriage return or newline (Unicode classes Zl and Zp).
///    <br/>
///    Length:  EDAM_USER_NAME_LEN_MIN - EDAM_USER_NAME_LEN_MAX
///    <br/>
///    Regex:  EDAM_USER_NAME_REGEX
///    </dd>
/// 
///  <dt>timezone</dt>
///    <dd>The zone ID for the user's default location.  If present,
///    this may be used to localize the display of any timestamp for which no
///    other timezone is available.
///    The format must be encoded as a standard zone ID such as
///    "America/Los_Angeles" or "GMT+08:00"
///    <br/>
///    Length:  EDAM_TIMEZONE_LEN_MIN - EDAM_TIMEZONE_LEN_MAX
///    <br/>
///    Regex:  EDAM_TIMEZONE_REGEX
///    </dd>
/// 
///  <dt>serviceLevel</dt>
///    <dd>The level of service the user currently receives. This will always be populated
///        for users retrieved from the Evernote service.
///    </dd>
/// 
///  <dt>created</dt>
///    <dd>The date and time when this user account was created in the
///    service.
///    </dd>
/// 
///  <dt>updated</dt>
///    <dd>The date and time when this user account was last modified
///    in the service.
///    </dd>
/// 
///  <dt>deleted</dt>
///    <dd>If the account has been deleted from the system (e.g. as
///    the result of a legal request by the user), the date and time of the
///    deletion will be represented here.  If not, this value will not be set.
///    </dd>
/// 
///  <dt>active</dt>
///    <dd>If the user account is available for login and
///    synchronization, this flag will be set to true.
///    </dd>
/// 
///  <dt>shardId</dt>
///    <dd>DEPRECATED - Client applications should have no need to use this field.
///    </dd>
/// 
///  <dt>attributes</dt>
///    <dd>If present, this will contain a list of the attributes
///    for this user account.
///    </dd>
/// 
///  <dt>accounting</dt>
///    <dd>Bookkeeping information for the user's subscription.
///    </dd>
/// 
///  <dt>businessUserInfo</dt>
///    <dd>If present, this will contain a set of business information
///    relating to the user's business membership.  If not present, the
///    user is not currently part of a business.
///    </dd>
/// 
///  <dt>photoUrl</dt>
///    <dd>The URL of the photo that represents this User. This field is filled in by the
///    service and is read-only to clients. If <code>photoLastUpdated</code> is
///    not set, this url will point to a placeholder user photo generated by the
///    service.</dd>
/// 
///  <dt>photoLastUpdated</dt>
///    <dd>The time at which the photo at 'photoUrl' was last updated by this User. This
///    field will be null if the User never set a profile photo. This field is filled in by
///    the service and is read-only to clients.</dd>
/// 
///  <dt>accountLimits</dt>
///    <dd>Account limits applicable for this user.</dd>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct User {
  pub id: Option<UserID>,
  pub username: Option<String>,
  pub email: Option<String>,
  pub name: Option<String>,
  pub timezone: Option<String>,
  pub privilege: Option<PrivilegeLevel>,
  pub created: Option<Timestamp>,
  pub updated: Option<Timestamp>,
  pub deleted: Option<Timestamp>,
  pub active: Option<bool>,
  pub shard_id: Option<String>,
  pub attributes: Option<UserAttributes>,
  pub accounting: Option<Accounting>,
  pub business_user_info: Option<BusinessUserInfo>,
  pub photo_url: Option<String>,
  pub photo_last_updated: Option<Timestamp>,
  pub service_level: Option<ServiceLevel>,
  pub account_limits: Option<AccountLimits>,
}

impl User {
  pub fn new<F1, F2, F3, F4, F6, F7, F9, F10, F11, F13, F14, F15, F16, F18, F19, F20, F21, F22>(id: F1, username: F2, email: F3, name: F4, timezone: F6, privilege: F7, created: F9, updated: F10, deleted: F11, active: F13, shard_id: F14, attributes: F15, accounting: F16, business_user_info: F18, photo_url: F19, photo_last_updated: F20, service_level: F21, account_limits: F22) -> User where F1: Into<Option<UserID>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<PrivilegeLevel>>, F9: Into<Option<Timestamp>>, F10: Into<Option<Timestamp>>, F11: Into<Option<Timestamp>>, F13: Into<Option<bool>>, F14: Into<Option<String>>, F15: Into<Option<UserAttributes>>, F16: Into<Option<Accounting>>, F18: Into<Option<BusinessUserInfo>>, F19: Into<Option<String>>, F20: Into<Option<Timestamp>>, F21: Into<Option<ServiceLevel>>, F22: Into<Option<AccountLimits>> {
    User {
      id: id.into(),
      username: username.into(),
      email: email.into(),
      name: name.into(),
      timezone: timezone.into(),
      privilege: privilege.into(),
      created: created.into(),
      updated: updated.into(),
      deleted: deleted.into(),
      active: active.into(),
      shard_id: shard_id.into(),
      attributes: attributes.into(),
      accounting: accounting.into(),
      business_user_info: business_user_info.into(),
      photo_url: photo_url.into(),
      photo_last_updated: photo_last_updated.into(),
      service_level: service_level.into(),
      account_limits: account_limits.into(),
    }
  }
}

impl TSerializable for User {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<User> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UserID> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<PrivilegeLevel> = None;
    let mut f_9: Option<Timestamp> = None;
    let mut f_10: Option<Timestamp> = None;
    let mut f_11: Option<Timestamp> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<UserAttributes> = None;
    let mut f_16: Option<Accounting> = None;
    let mut f_18: Option<BusinessUserInfo> = None;
    let mut f_19: Option<String> = None;
    let mut f_20: Option<Timestamp> = None;
    let mut f_21: Option<ServiceLevel> = None;
    let mut f_22: Option<AccountLimits> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = PrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = UserAttributes::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        16 => {
          let val = Accounting::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        18 => {
          let val = BusinessUserInfo::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_string()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        21 => {
          let val = ServiceLevel::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = AccountLimits::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = User {
      id: f_1,
      username: f_2,
      email: f_3,
      name: f_4,
      timezone: f_6,
      privilege: f_7,
      created: f_9,
      updated: f_10,
      deleted: f_11,
      active: f_13,
      shard_id: f_14,
      attributes: f_15,
      accounting: f_16,
      business_user_info: f_18,
      photo_url: f_19,
      photo_last_updated: f_20,
      service_level: f_21,
      account_limits: f_22,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("User");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timezone {
      o_prot.write_field_begin(&TFieldIdentifier::new("timezone", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created {
      o_prot.write_field_begin(&TFieldIdentifier::new("created", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("updated", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.deleted {
      o_prot.write_field_begin(&TFieldIdentifier::new("deleted", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.active {
      o_prot.write_field_begin(&TFieldIdentifier::new("active", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shard_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardId", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Struct, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.accounting {
      o_prot.write_field_begin(&TFieldIdentifier::new("accounting", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.business_user_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessUserInfo", TType::Struct, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.photo_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("photoUrl", TType::String, 19))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.photo_last_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("photoLastUpdated", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceLevel", TType::I32, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.account_limits {
      o_prot.write_field_begin(&TFieldIdentifier::new("accountLimits", TType::Struct, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Contact
//

/// A structure that represents contact information. Note this does not necessarily correspond to
/// an Evernote user.
/// 
/// <dl>
/// <dt>name</dt>
/// <dd>The displayable name of this contact. This field is filled in by the service and
///     is read-only to clients.
/// </dd>
/// <dt>id</dt>
/// <dd>A unique identifier for this ContactType.
/// </dd>
/// <dt>type</dt>
/// <dd>What service does this contact come from?
/// </dd>
/// <dt>photoUrl</dt>
/// <dd>A URL of a profile photo representing this Contact. This field is filled in by the
///     service and is read-only to clients.
/// </dd>
/// <dt>photoLastUpdated</dt>
/// <dd>timestamp when the profile photo at 'photoUrl' was last updated.
///     This field will be null if the user has never set a profile photo.
///     This field is filled in by the service and is read-only to clients.
/// </dd>
/// <dt>messagingPermit</dt>
/// <dd>This field will only be filled by the service when it is giving a Contact record
///     to a client, and that client does not normally have enough permission to send a
///     new message to the person represented through this Contact. In that case, this
///     whole Contact record could be used to send a new Message to the Contact, and the
///     service will inspect this permit to confirm that operation was allowed.
/// </dd>
/// <dt>messagingPermitExpires</dt>
/// <dd>If this field is set, then this (whole) Contact record may be used in calls to
///     sendMessage until this time. After that time, those calls may be rejected by the
///     service if the caller does not have direct permission to initiate a message with
///     the represented Evernote user.
/// </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Contact {
  pub name: Option<String>,
  pub id: Option<String>,
  pub type_: Option<ContactType>,
  pub photo_url: Option<String>,
  pub photo_last_updated: Option<Timestamp>,
  pub messaging_permit: Option<Vec<u8>>,
  pub messaging_permit_expires: Option<Timestamp>,
}

impl Contact {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(name: F1, id: F2, type_: F3, photo_url: F4, photo_last_updated: F5, messaging_permit: F6, messaging_permit_expires: F7) -> Contact where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<ContactType>>, F4: Into<Option<String>>, F5: Into<Option<Timestamp>>, F6: Into<Option<Vec<u8>>>, F7: Into<Option<Timestamp>> {
    Contact {
      name: name.into(),
      id: id.into(),
      type_: type_.into(),
      photo_url: photo_url.into(),
      photo_last_updated: photo_last_updated.into(),
      messaging_permit: messaging_permit.into(),
      messaging_permit_expires: messaging_permit_expires.into(),
    }
  }
}

impl TSerializable for Contact {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Contact> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<ContactType> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Timestamp> = None;
    let mut f_6: Option<Vec<u8>> = None;
    let mut f_7: Option<Timestamp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ContactType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bytes()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Contact {
      name: f_1,
      id: f_2,
      type_: f_3,
      photo_url: f_4,
      photo_last_updated: f_5,
      messaging_permit: f_6,
      messaging_permit_expires: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Contact");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.photo_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("photoUrl", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.photo_last_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("photoLastUpdated", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.messaging_permit {
      o_prot.write_field_begin(&TFieldIdentifier::new("messagingPermit", TType::String, 6))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.messaging_permit_expires {
      o_prot.write_field_begin(&TFieldIdentifier::new("messagingPermitExpires", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Identity
//

/// An object that represents the relationship between a Contact that possibly
/// belongs to an Evernote User.
/// 
/// <dl>
///  <dt>id</dt>
///  <dd>The unique identifier for this mapping.
///  </dd>
/// 
///  <dt>contact<dt>
///  <dd>The Contact that can be used to address this Identity. May be unset.
///  </dd>
/// 
///  <dt>userId</dt>
///  <dd>The Evernote User id that is connected to the Contact. May be unset
///      if this identity has not yet been claimed, or the caller is not
///      connected to this identity.
///  </dd>
/// 
///  <dt>deactivated</dt>
///  <dd>Indicates that the contact for this identity is no longer active and
///  should not be used when creating new threads using Destination.recipients,
///  unless you know of another Identity instance with the same contact information
///  that is active.  If you are connected to the user (see userConnected), you
///  can still create threads using their Evernote-type contact.</dd>
/// 
///  <dt>sameBusiness</dt>
///  <dd>Does this Identity belong to someone who is in the same business as the
///      caller?
///  </dd>
/// 
///  <dt>blocked</dt>
///  <dd>Has the caller blocked the Evernote user this Identity represents?
///  </dd>
/// 
///  <dt>userConnected</dt>
///  <dd>Indicates that the caller is "connected" to the user of this
///  identity via this identity.  When you have a connection via an
///  identity, you should always create new threads using the
///  Evernote-type contact (see ContactType) using the userId field
///  from a connected Identity.  On the Evernote service, the
///  Evernote-type contact is the most durable. Phone numbers and
///  e-mail addresses can get re-assigned but your Evernote account
///  user ID will remain the same.  A connection exists when both of
///  you are in the same business or the user has replied to a thread
///  that you are on.  When connected, you will also get to see more
///  information about the user who has claimed the identity.  Note
///  that you are never connected to yourself since you won't be
///  sending messages to yourself, but you will obviously see your own
///  profile information.
///  </dd>
/// 
///  <dt>eventId</dt>
///  <dd>A server-assigned sequence number for the events in the messages
///  subsystem.
///  </dd>
/// </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Identity {
  pub id: IdentityID,
  pub contact: Option<Contact>,
  pub user_id: Option<UserID>,
  pub deactivated: Option<bool>,
  pub same_business: Option<bool>,
  pub blocked: Option<bool>,
  pub user_connected: Option<bool>,
  pub event_id: Option<MessageEventID>,
}

impl Identity {
  pub fn new<F2, F3, F4, F5, F6, F7, F8>(id: IdentityID, contact: F2, user_id: F3, deactivated: F4, same_business: F5, blocked: F6, user_connected: F7, event_id: F8) -> Identity where F2: Into<Option<Contact>>, F3: Into<Option<UserID>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<MessageEventID>> {
    Identity {
      id,
      contact: contact.into(),
      user_id: user_id.into(),
      deactivated: deactivated.into(),
      same_business: same_business.into(),
      blocked: blocked.into(),
      user_connected: user_connected.into(),
      event_id: event_id.into(),
    }
  }
}

impl TSerializable for Identity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Identity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<IdentityID> = None;
    let mut f_2: Option<Contact> = None;
    let mut f_3: Option<UserID> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<MessageEventID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Identity.id", &f_1)?;
    let ret = Identity {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contact: f_2,
      user_id: f_3,
      deactivated: f_4,
      same_business: f_5,
      blocked: f_6,
      user_connected: f_7,
      event_id: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.contact {
      o_prot.write_field_begin(&TFieldIdentifier::new("contact", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.deactivated {
      o_prot.write_field_begin(&TFieldIdentifier::new("deactivated", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.same_business {
      o_prot.write_field_begin(&TFieldIdentifier::new("sameBusiness", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.blocked {
      o_prot.write_field_begin(&TFieldIdentifier::new("blocked", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_connected {
      o_prot.write_field_begin(&TFieldIdentifier::new("userConnected", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventId", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Tag
//

///  A tag within a user's account is a unique name which may be organized
///  a simple hierarchy.
/// <dl>
///  <dt>guid</dt>
///    <dd>The unique identifier of this tag. Will be set by the service,
///    so may be omitted by the client when creating the Tag.
///    <br/>
///    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///    <br/>
///    Regex:  EDAM_GUID_REGEX
///    </dd>
/// 
///  <dt>name</dt>
///    <dd>A sequence of characters representing the tag's identifier.
///    Case is preserved, but is ignored for comparisons.
///    This means that an account may only have one tag with a given name, via
///    case-insensitive comparison, so an account may not have both "food" and
///    "Food" tags.
///    May not contain a comma (','), and may not begin or end with a space.
///    <br/>
///    Length:  EDAM_TAG_NAME_LEN_MIN - EDAM_TAG_NAME_LEN_MAX
///    <br/>
///    Regex:  EDAM_TAG_NAME_REGEX
///    </dd>
/// 
///  <dt>parentGuid</dt>
///    <dd>If this is set, then this is the GUID of the tag that
///    holds this tag within the tag organizational hierarchy.  If this is
///    not set, then the tag has no parent and it is a "top level" tag.
///    Cycles are not allowed (e.g. a->parent->parent == a) and will be
///    rejected by the service.
///    <br/>
///    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///    <br/>
///    Regex:  EDAM_GUID_REGEX
///    </dd>
/// 
///  <dt>updateSequenceNum</dt>
///    <dd>A number identifying the last transaction to
///    modify the state of this object.  The USN values are sequential within an
///    account, and can be used to compare the order of modifications within the
///    service.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Tag {
  pub guid: Option<Guid>,
  pub name: Option<String>,
  pub parent_guid: Option<Guid>,
  pub update_sequence_num: Option<i32>,
}

impl Tag {
  pub fn new<F1, F2, F3, F4>(guid: F1, name: F2, parent_guid: F3, update_sequence_num: F4) -> Tag where F1: Into<Option<Guid>>, F2: Into<Option<String>>, F3: Into<Option<Guid>>, F4: Into<Option<i32>> {
    Tag {
      guid: guid.into(),
      name: name.into(),
      parent_guid: parent_guid.into(),
      update_sequence_num: update_sequence_num.into(),
    }
  }
}

impl TSerializable for Tag {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Tag> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Guid> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Guid> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Tag {
      guid: f_1,
      name: f_2,
      parent_guid: f_3,
      update_sequence_num: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tag");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentGuid", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LazyMap
//

/// A structure that wraps a map of name/value pairs whose values are not
/// always present in the structure in order to reduce space when obtaining
/// batches of entities that contain the map.
/// 
/// When the server provides the client with a LazyMap, it will fill in either
/// the keysOnly field or the fullMap field, but never both, based on the API
/// and parameters.
/// 
/// When a client provides a LazyMap to the server as part of an update to
/// an object, the server will only update the LazyMap if the fullMap field is
/// set. If the fullMap field is not set, the server will not make any changes
/// to the map.
/// 
/// Check the API documentation of the individual calls involving the LazyMap
/// for full details including the constraints of the names and values of the
/// map.
/// 
/// <dl>
/// <dt>keysOnly</dt>
///   <dd>The set of keys for the map.  This field is ignored by the
///       server when set.
///   </dd>
/// 
/// <dt>fullMap</dt>
///   <dd>The complete map, including all keys and values.
///   </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LazyMap {
  pub keys_only: Option<BTreeSet<String>>,
  pub full_map: Option<BTreeMap<String, String>>,
}

impl LazyMap {
  pub fn new<F1, F2>(keys_only: F1, full_map: F2) -> LazyMap where F1: Into<Option<BTreeSet<String>>>, F2: Into<Option<BTreeMap<String, String>>> {
    LazyMap {
      keys_only: keys_only.into(),
      full_map: full_map.into(),
    }
  }
}

impl TSerializable for LazyMap {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LazyMap> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeSet<String>> = None;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_2 = i_prot.read_string()?;
            val.insert(set_elem_2);
          }
          i_prot.read_set_end()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_3 = i_prot.read_string()?;
            let map_val_4 = i_prot.read_string()?;
            val.insert(map_key_3, map_val_4);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LazyMap {
      keys_only: f_1,
      full_map: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LazyMap");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.keys_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("keysOnly", TType::Set, 1))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.full_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("fullMap", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResourceAttributes
//

/// Structure holding the optional attributes of a Resource
/// <dl>
/// <dt>sourceURL</dt>
///   <dd>the original location where the resource was hosted
///   <br/>
///    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///   </dd>
/// 
/// <dt>timestamp</dt>
///   <dd>the date and time that is associated with this resource
///   (e.g. the time embedded in an image from a digital camera with a clock)
///   </dd>
/// 
/// <dt>latitude</dt>
///   <dd>the latitude where the resource was captured
///   </dd>
/// 
/// <dt>longitude</dt>
///   <dd>the longitude where the resource was captured
///   </dd>
/// 
/// <dt>altitude</dt>
///   <dd>the altitude where the resource was captured
///   </dd>
/// 
/// <dt>cameraMake</dt>
///   <dd>information about an image's camera, e.g. as embedded in
///   the image's EXIF data
///   <br/>
///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///   </dd>
/// 
/// <dt>cameraModel</dt>
///   <dd>information about an image's camera, e.g. as embedded
///   in the image's EXIF data
///   <br/>
///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///   </dd>
/// 
/// <dt>clientWillIndex</dt>
///   <dd>if true, then the original client that submitted
///   the resource plans to submit the recognition index for this resource at a
///   later time.
///   </dd>
/// 
/// <dt>recoType</dt>
///   <dd>DEPRECATED - this field is no longer set by the service, so should
///     be ignored.
///   </dd>
/// 
/// <dt>fileName</dt>
///   <dd>if the resource came from a source that provided an
///   explicit file name, the original name will be stored here.  Many resources
///   come from unnamed sources, so this will not always be set.
///   </dd>
/// 
/// <dt>attachment</dt>
///   <dd>this will be true if the resource should be displayed as an attachment,
///   or false if the resource should be displayed inline (if possible).
///   </dd>
/// 
/// <dt>applicationData</dt>
/// <dd>Provides a location for applications to store a relatively small
/// (4kb) blob of data associated with a Resource that is not visible to the user
/// and that is opaque to the Evernote service. A single application may use at most
/// one entry in this map, using its API consumer key as the map key. See the
/// documentation for LazyMap for a description of when the actual map values
/// are returned by the service.
/// <p>To safely add or modify your application's entry in the map, use
/// NoteStore.setResourceApplicationDataEntry. To safely remove your application's
/// entry from the map, use NoteStore.unsetResourceApplicationDataEntry.</p>
/// Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
/// <br/>
/// Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
/// <br/>
/// Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
/// </dd>
/// 
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResourceAttributes {
  pub source_u_r_l: Option<String>,
  pub timestamp: Option<Timestamp>,
  pub latitude: Option<OrderedFloat<f64>>,
  pub longitude: Option<OrderedFloat<f64>>,
  pub altitude: Option<OrderedFloat<f64>>,
  pub camera_make: Option<String>,
  pub camera_model: Option<String>,
  pub client_will_index: Option<bool>,
  pub reco_type: Option<String>,
  pub file_name: Option<String>,
  pub attachment: Option<bool>,
  pub application_data: Option<LazyMap>,
}

impl ResourceAttributes {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(source_u_r_l: F1, timestamp: F2, latitude: F3, longitude: F4, altitude: F5, camera_make: F6, camera_model: F7, client_will_index: F8, reco_type: F9, file_name: F10, attachment: F11, application_data: F12) -> ResourceAttributes where F1: Into<Option<String>>, F2: Into<Option<Timestamp>>, F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<OrderedFloat<f64>>>, F5: Into<Option<OrderedFloat<f64>>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<bool>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<bool>>, F12: Into<Option<LazyMap>> {
    ResourceAttributes {
      source_u_r_l: source_u_r_l.into(),
      timestamp: timestamp.into(),
      latitude: latitude.into(),
      longitude: longitude.into(),
      altitude: altitude.into(),
      camera_make: camera_make.into(),
      camera_model: camera_model.into(),
      client_will_index: client_will_index.into(),
      reco_type: reco_type.into(),
      file_name: file_name.into(),
      attachment: attachment.into(),
      application_data: application_data.into(),
    }
  }
}

impl TSerializable for ResourceAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResourceAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Timestamp> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<OrderedFloat<f64>> = None;
    let mut f_5: Option<OrderedFloat<f64>> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<LazyMap> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = LazyMap::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResourceAttributes {
      source_u_r_l: f_1,
      timestamp: f_2,
      latitude: f_3,
      longitude: f_4,
      altitude: f_5,
      camera_make: f_6,
      camera_model: f_7,
      client_will_index: f_8,
      reco_type: f_9,
      file_name: f_10,
      attachment: f_11,
      application_data: f_12,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResourceAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.source_u_r_l {
      o_prot.write_field_begin(&TFieldIdentifier::new("sourceURL", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.latitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("latitude", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.longitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("longitude", TType::Double, 4))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.altitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("altitude", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.camera_make {
      o_prot.write_field_begin(&TFieldIdentifier::new("cameraMake", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.camera_model {
      o_prot.write_field_begin(&TFieldIdentifier::new("cameraModel", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.client_will_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientWillIndex", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reco_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("recoType", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("fileName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attachment {
      o_prot.write_field_begin(&TFieldIdentifier::new("attachment", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.application_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationData", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Resource
//

/// Every media file that is embedded or attached to a note is represented
/// through a Resource entry.
/// <dl>
/// <dt>guid</dt>
///   <dd>The unique identifier of this resource.  Will be set whenever
///   a resource is retrieved from the service, but may be null when a client
///   is creating a resource.
///   <br/>
///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///   <br/>
///   Regex:  EDAM_GUID_REGEX
///   </dd>
/// 
/// <dt>noteGuid</dt>
///   <dd>The unique identifier of the Note that holds this
///   Resource. Will be set whenever the resource is retrieved from the service,
///   but may be null when a client is creating a resource.
///   <br/>
///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///   <br/>
///   Regex:  EDAM_GUID_REGEX
///   </dd>
/// 
/// <dt>data</dt>
///   <dd>The contents of the resource.
///   Maximum length:  The data.body is limited to EDAM_RESOURCE_SIZE_MAX_FREE
///   for free accounts and EDAM_RESOURCE_SIZE_MAX_PREMIUM for premium accounts.
///   </dd>
/// 
/// <dt>mime</dt>
///   <dd>The MIME type for the embedded resource.  E.g. "image/gif"
///   <br/>
///   Length:  EDAM_MIME_LEN_MIN - EDAM_MIME_LEN_MAX
///   <br/>
///   Regex:  EDAM_MIME_REGEX
///   </dd>
/// 
/// <dt>width</dt>
///   <dd>If set, this contains the display width of this resource, in
///   pixels.
///   </dd>
/// 
/// <dt>height</dt>
///   <dd>If set, this contains the display height of this resource,
///   in pixels.
///   </dd>
/// 
/// <dt>duration</dt>
///   <dd>DEPRECATED: ignored.
///   </dd>
/// 
/// <dt>active</dt>
///   <dd>If the resource is active or not.
///   </dd>
/// 
/// <dt>recognition</dt>
///   <dd>If set, this will hold the encoded data that provides
///   information on search and recognition within this resource.
///   </dd>
/// 
/// <dt>attributes</dt>
///   <dd>A list of the attributes for this resource.
///   </dd>
/// 
/// <dt>updateSequenceNum</dt>
///   <dd>A number identifying the last transaction to
///   modify the state of this object. The USN values are sequential within an
///   account, and can be used to compare the order of modifications within the
///   service.
///   </dd>
/// 
/// <dt>alternateData</dt>
///   <dd>Some Resources may be assigned an alternate data format by the service
///   which may be more appropriate for indexing or rendering than the original
///   data provided by the user.  In these cases, the alternate data form will
///   be available via this Data element.  If a Resource has no alternate form,
///   this field will be unset.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Resource {
  pub guid: Option<Guid>,
  pub note_guid: Option<Guid>,
  pub data: Option<Data>,
  pub mime: Option<String>,
  pub width: Option<i16>,
  pub height: Option<i16>,
  pub duration: Option<i16>,
  pub active: Option<bool>,
  pub recognition: Option<Data>,
  pub attributes: Option<ResourceAttributes>,
  pub update_sequence_num: Option<i32>,
  pub alternate_data: Option<Data>,
}

impl Resource {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F11, F12, F13>(guid: F1, note_guid: F2, data: F3, mime: F4, width: F5, height: F6, duration: F7, active: F8, recognition: F9, attributes: F11, update_sequence_num: F12, alternate_data: F13) -> Resource where F1: Into<Option<Guid>>, F2: Into<Option<Guid>>, F3: Into<Option<Data>>, F4: Into<Option<String>>, F5: Into<Option<i16>>, F6: Into<Option<i16>>, F7: Into<Option<i16>>, F8: Into<Option<bool>>, F9: Into<Option<Data>>, F11: Into<Option<ResourceAttributes>>, F12: Into<Option<i32>>, F13: Into<Option<Data>> {
    Resource {
      guid: guid.into(),
      note_guid: note_guid.into(),
      data: data.into(),
      mime: mime.into(),
      width: width.into(),
      height: height.into(),
      duration: duration.into(),
      active: active.into(),
      recognition: recognition.into(),
      attributes: attributes.into(),
      update_sequence_num: update_sequence_num.into(),
      alternate_data: alternate_data.into(),
    }
  }
}

impl TSerializable for Resource {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Resource> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Guid> = None;
    let mut f_2: Option<Guid> = None;
    let mut f_3: Option<Data> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i16> = None;
    let mut f_6: Option<i16> = None;
    let mut f_7: Option<i16> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<Data> = None;
    let mut f_11: Option<ResourceAttributes> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<Data> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Data::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i16()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i16()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i16()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = Data::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        11 => {
          let val = ResourceAttributes::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = Data::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Resource {
      guid: f_1,
      note_guid: f_2,
      data: f_3,
      mime: f_4,
      width: f_5,
      height: f_6,
      duration: f_7,
      active: f_8,
      recognition: f_9,
      attributes: f_11,
      update_sequence_num: f_12,
      alternate_data: f_13,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Resource");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.note_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteGuid", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.mime {
      o_prot.write_field_begin(&TFieldIdentifier::new("mime", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.width {
      o_prot.write_field_begin(&TFieldIdentifier::new("width", TType::I16, 5))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.height {
      o_prot.write_field_begin(&TFieldIdentifier::new("height", TType::I16, 6))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.duration {
      o_prot.write_field_begin(&TFieldIdentifier::new("duration", TType::I16, 7))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.active {
      o_prot.write_field_begin(&TFieldIdentifier::new("active", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recognition {
      o_prot.write_field_begin(&TFieldIdentifier::new("recognition", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.alternate_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("alternateData", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteAttributes
//

/// The list of optional attributes that can be stored on a note.
/// <dl>
/// <dt>subjectDate</dt>
///   <dd>time that the note refers to
///   </dd>
/// 
/// <dt>latitude</dt>
///   <dd>the latitude where the note was taken
///   </dd>
/// 
/// <dt>longitude</dt>
///   <dd>the longitude where the note was taken
///   </dd>
/// 
/// <dt>altitude</dt>
///   <dd>the altitude where the note was taken
///   </dd>
/// 
/// <dt>author</dt>
///   <dd>the author of the content of the note
///   <br/>
///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///   </dd>
/// 
/// <dt>source</dt>
///   <dd>the method that the note was added to the account, if the
///   note wasn't directly authored in an Evernote desktop client.
///   <br/>
///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///   </dd>
/// 
/// <dt>sourceURL</dt>
///   <dd>the original location where the resource was hosted. For web clips,
///   this will be the URL of the page that was clipped.
///   <br/>
///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///   </dd>
/// 
/// <dt>sourceApplication</dt>
///   <dd>an identifying string for the application that
///   created this note.  This string does not have a guaranteed syntax or
///   structure -- it is intended for human inspection and tracking.
///   <br/>
///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
///   </dd>
/// 
/// <dt>shareDate</dt>
///  <dd>The date and time when this note was directly shared via its own URL.
///  This is only set on notes that were individually shared - it is independent
///  of any notebook-level sharing of the containing notebook. This field
///  is treated as "read-only" for clients; the server will ignore changes
///  to this field from an external client.
///  </dd>
/// 
/// <dt>reminderOrder</dt>
/// <dd>The set of notes with this parameter set are considered
/// "reminders" and are to be treated specially by clients to give them
/// higher UI prominence within a notebook.  The value is used to sort
/// the reminder notes within the notebook with higher values
/// representing greater prominence.  Outside of the context of a
/// notebook, the value of this parameter is undefined.  The value is
/// not intended to be compared to the values of reminder notes in
/// other notebooks.  In order to allow clients to place a note at a
/// higher precedence than other notes, you should never set a value
/// greater than the current time (as defined for a Timetstamp). To
/// place a note at higher precedence than existing notes, set the
/// value to the current time as defined for a timestamp (milliseconds
/// since the epoch).  Synchronizing clients must remember the time when
/// the update was performed, using the local clock on the client,
/// and use that value when they later upload the note to the service.
/// Clients must not set the reminderOrder to the reminderTime as the
/// reminderTime could be in the future.  Those two fields are never
/// intended to be related.  The correct value for reminderOrder field
/// for new notes is the "current" time when the user indicated that
/// the note is a reminder.  Clients may implement a separate
/// "sort by date" feature to show notes ordered by reminderTime.
/// Whenever a reminderDoneTime or reminderTime is set but a
/// reminderOrder is not set, the server will fill in the current
/// server time for the reminderOrder field.</dd>
/// 
/// <dt>reminderDoneTime</dt>
/// <dd>The date and time when a user dismissed/"marked done" the reminder
/// on the note.  Users typically do not manually set this value directly
/// as it is set to the time when the user dismissed/"marked done" the
/// reminder.</dd>
/// 
/// <dt>reminderTime</dt>
/// <dd>The date and time a user has selected to be reminded of the note.
/// A note with this value set is known as a "reminder" and the user can
/// be reminded, via e-mail or client-specific notifications, of the note
/// when the time is reached or about to be reached.  When a user sets
/// a reminder time on a note that has a reminder done time, and that
/// reminder time is in the future, then the reminder done time should be
/// cleared.  This should happen regardless of any existing reminder time
/// that may have previously existed on the note.</dd>
/// 
/// <dt>placeName</dt>
/// <dd>Allows the user to assign a human-readable location name associated
/// with a note. Users may assign values like 'Home' and 'Work'. Place
/// names may also be populated with values from geonames database
/// (e.g., a restaurant name). Applications are encouraged to normalize values
/// so that grouping values by place name provides a useful result. Applications
/// MUST NOT automatically add place name values based on geolocation without
/// confirmation from the user; that is, the value in this field should be
/// more useful than a simple automated lookup based on the note's latitude
/// and longitude.</dd>
/// 
/// <dt>contentClass</dt>
/// <dd>The class (or type) of note. This field is used to indicate to
/// clients that special structured information is represented within
/// the note such that special rules apply when making
/// modifications. If contentClass is set and the client
/// application does not specifically support the specified class,
/// the client MUST treat the note as read-only. In this case, the
/// client MAY modify the note's notebook and tags via the
/// Note.notebookGuid and Note.tagGuids fields.  The client MAY also
/// modify the reminderOrder field as well as the reminderTime and
/// reminderDoneTime fields.
/// <p>Applications should set contentClass only when they are creating notes
/// that contain structured information that needs to be maintained in order
/// for the user to be able to use the note within that application.
/// Setting contentClass makes a note read-only in other applications, so
/// there is a trade-off when an application chooses to use contentClass.
/// Applications that set contentClass when creating notes must use a contentClass
/// string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
/// Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
/// <br/>
/// Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
/// </dd>
/// 
/// <dt>applicationData</dt>
/// <dd>Provides a location for applications to store a relatively small
/// (4kb) blob of data that is not meant to be visible to the user and
/// that is opaque to the Evernote service. A single application may use at most
/// one entry in this map, using its API consumer key as the map key. See the
/// documentation for LazyMap for a description of when the actual map values
/// are returned by the service.
/// <p>To safely add or modify your application's entry in the map, use
/// NoteStore.setNoteApplicationDataEntry. To safely remove your application's
/// entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
/// Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
/// <br/>
/// Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
/// <br/>
/// Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
/// </dd>
/// 
/// <dt>creatorId</dt>
/// <dd>The numeric user ID of the user who originally created the note.</dd>
/// 
/// <dt>lastEditedBy</dt>
/// <dd>An indication of who made the last change to the note.  If you are
/// accessing the note via a shared notebook to which you have modification
/// rights, or if you are the owner of the notebook to which the note belongs,
/// then you have access to the value.  In this case, the value will be
/// unset if the owner of the notebook containing the note was the last to
/// make the modification, else it will be a string describing the
/// guest who made the last edit.  If you do not have access to this value,
/// it will be left unset.  This field is read-only by clients.  The server
/// will ignore all values set by clients into this field.</dd>
/// 
/// <dt>lastEditorId</dt>
/// <dd>The numeric user ID of the user described in lastEditedBy.</dd>
/// 
/// <dt>classifications</dt>
/// <dd>A map of classifications applied to the note by clients or by the
/// Evernote service. The key is the string name of the classification type,
/// and the value is a constant that begins with CLASSIFICATION_.</dd>
/// 
/// <dt>sharedWithBusiness</dt>
/// <dd>When this flag is set on a business note, any user in that business
/// may view the note if they request it by GUID. This field is read-only by
/// clients. The server will ignore all values set by clients into this field.
/// 
/// To share a note with the business, use NoteStore.shareNoteWithBusiness and
/// to stop sharing a note with the business, use NoteStore.stopSharingNoteWithBusiness.
/// </dd>
/// 
/// <dt>conflictSourceNoteGuid</dt>
/// <dd>If set, this specifies the GUID of a note that caused a sync conflict
/// resulting in the creation of a duplicate note. The duplicated note contains
/// the user's changes that could not be applied as a result of the sync conflict,
/// and uses the conflictSourceNoteGuid field to specify the note that caused the
/// conflict. This allows clients to provide a customized user experience for note
/// conflicts.
/// </dd>
/// 
/// <dt>noteTitleQuality</dt>
/// <dd>If set, this specifies that the note's title was automatically generated
/// and indicates the likelihood that the generated title is useful for display to
/// the user. If not set, the note's title was manually entered by the user.
/// 
/// Clients MUST set this attribute to one of the following values when the
/// corresponding note's title was not manually entered by the user:
/// EDAM_NOTE_TITLE_QUALITY_UNTITLED, EDAM_NOTE_TITLE_QUALITY_LOW,
/// EDAM_NOTE_TITLE_QUALITY_MEDIUM or EDAM_NOTE_TITLE_QUALITY_HIGH.
/// 
/// When a user edits a note's title, clients MUST unset this value.
/// </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteAttributes {
  pub subject_date: Option<Timestamp>,
  pub latitude: Option<OrderedFloat<f64>>,
  pub longitude: Option<OrderedFloat<f64>>,
  pub altitude: Option<OrderedFloat<f64>>,
  pub author: Option<String>,
  pub source: Option<String>,
  pub source_u_r_l: Option<String>,
  pub source_application: Option<String>,
  pub share_date: Option<Timestamp>,
  pub reminder_order: Option<i64>,
  pub reminder_done_time: Option<Timestamp>,
  pub reminder_time: Option<Timestamp>,
  pub place_name: Option<String>,
  pub content_class: Option<String>,
  pub application_data: Option<LazyMap>,
  pub last_edited_by: Option<String>,
  pub classifications: Option<BTreeMap<String, String>>,
  pub creator_id: Option<UserID>,
  pub last_editor_id: Option<UserID>,
  pub shared_with_business: Option<bool>,
  pub conflict_source_note_guid: Option<Guid>,
  pub note_title_quality: Option<i32>,
}

impl NoteAttributes {
  pub fn new<F1, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F26, F27, F28, F29, F30, F31>(subject_date: F1, latitude: F10, longitude: F11, altitude: F12, author: F13, source: F14, source_u_r_l: F15, source_application: F16, share_date: F17, reminder_order: F18, reminder_done_time: F19, reminder_time: F20, place_name: F21, content_class: F22, application_data: F23, last_edited_by: F24, classifications: F26, creator_id: F27, last_editor_id: F28, shared_with_business: F29, conflict_source_note_guid: F30, note_title_quality: F31) -> NoteAttributes where F1: Into<Option<Timestamp>>, F10: Into<Option<OrderedFloat<f64>>>, F11: Into<Option<OrderedFloat<f64>>>, F12: Into<Option<OrderedFloat<f64>>>, F13: Into<Option<String>>, F14: Into<Option<String>>, F15: Into<Option<String>>, F16: Into<Option<String>>, F17: Into<Option<Timestamp>>, F18: Into<Option<i64>>, F19: Into<Option<Timestamp>>, F20: Into<Option<Timestamp>>, F21: Into<Option<String>>, F22: Into<Option<String>>, F23: Into<Option<LazyMap>>, F24: Into<Option<String>>, F26: Into<Option<BTreeMap<String, String>>>, F27: Into<Option<UserID>>, F28: Into<Option<UserID>>, F29: Into<Option<bool>>, F30: Into<Option<Guid>>, F31: Into<Option<i32>> {
    NoteAttributes {
      subject_date: subject_date.into(),
      latitude: latitude.into(),
      longitude: longitude.into(),
      altitude: altitude.into(),
      author: author.into(),
      source: source.into(),
      source_u_r_l: source_u_r_l.into(),
      source_application: source_application.into(),
      share_date: share_date.into(),
      reminder_order: reminder_order.into(),
      reminder_done_time: reminder_done_time.into(),
      reminder_time: reminder_time.into(),
      place_name: place_name.into(),
      content_class: content_class.into(),
      application_data: application_data.into(),
      last_edited_by: last_edited_by.into(),
      classifications: classifications.into(),
      creator_id: creator_id.into(),
      last_editor_id: last_editor_id.into(),
      shared_with_business: shared_with_business.into(),
      conflict_source_note_guid: conflict_source_note_guid.into(),
      note_title_quality: note_title_quality.into(),
    }
  }
}

impl TSerializable for NoteAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Timestamp> = None;
    let mut f_10: Option<OrderedFloat<f64>> = None;
    let mut f_11: Option<OrderedFloat<f64>> = None;
    let mut f_12: Option<OrderedFloat<f64>> = None;
    let mut f_13: Option<String> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<String> = None;
    let mut f_16: Option<String> = None;
    let mut f_17: Option<Timestamp> = None;
    let mut f_18: Option<i64> = None;
    let mut f_19: Option<Timestamp> = None;
    let mut f_20: Option<Timestamp> = None;
    let mut f_21: Option<String> = None;
    let mut f_22: Option<String> = None;
    let mut f_23: Option<LazyMap> = None;
    let mut f_24: Option<String> = None;
    let mut f_26: Option<BTreeMap<String, String>> = None;
    let mut f_27: Option<UserID> = None;
    let mut f_28: Option<UserID> = None;
    let mut f_29: Option<bool> = None;
    let mut f_30: Option<Guid> = None;
    let mut f_31: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        10 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_10 = Some(val);
        },
        11 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_11 = Some(val);
        },
        12 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i64()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_i64()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i64()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_string()?;
          f_22 = Some(val);
        },
        23 => {
          let val = LazyMap::read_from_in_protocol(i_prot)?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_string()?;
          f_24 = Some(val);
        },
        26 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_string()?;
            let map_val_6 = i_prot.read_string()?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_26 = Some(val);
        },
        27 => {
          let val = i_prot.read_i32()?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_i32()?;
          f_28 = Some(val);
        },
        29 => {
          let val = i_prot.read_bool()?;
          f_29 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        31 => {
          let val = i_prot.read_i32()?;
          f_31 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteAttributes {
      subject_date: f_1,
      latitude: f_10,
      longitude: f_11,
      altitude: f_12,
      author: f_13,
      source: f_14,
      source_u_r_l: f_15,
      source_application: f_16,
      share_date: f_17,
      reminder_order: f_18,
      reminder_done_time: f_19,
      reminder_time: f_20,
      place_name: f_21,
      content_class: f_22,
      application_data: f_23,
      last_edited_by: f_24,
      classifications: f_26,
      creator_id: f_27,
      last_editor_id: f_28,
      shared_with_business: f_29,
      conflict_source_note_guid: f_30,
      note_title_quality: f_31,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.subject_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("subjectDate", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.latitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("latitude", TType::Double, 10))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.longitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("longitude", TType::Double, 11))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.altitude {
      o_prot.write_field_begin(&TFieldIdentifier::new("altitude", TType::Double, 12))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.author {
      o_prot.write_field_begin(&TFieldIdentifier::new("author", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source {
      o_prot.write_field_begin(&TFieldIdentifier::new("source", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source_u_r_l {
      o_prot.write_field_begin(&TFieldIdentifier::new("sourceURL", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source_application {
      o_prot.write_field_begin(&TFieldIdentifier::new("sourceApplication", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.share_date {
      o_prot.write_field_begin(&TFieldIdentifier::new("shareDate", TType::I64, 17))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.reminder_order {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderOrder", TType::I64, 18))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.reminder_done_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderDoneTime", TType::I64, 19))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.reminder_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderTime", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.place_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("placeName", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.content_class {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentClass", TType::String, 22))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.application_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("applicationData", TType::Struct, 23))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_edited_by {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastEditedBy", TType::String, 24))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.classifications {
      o_prot.write_field_begin(&TFieldIdentifier::new("classifications", TType::Map, 26))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.creator_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("creatorId", TType::I32, 27))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_editor_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastEditorId", TType::I32, 28))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.shared_with_business {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharedWithBusiness", TType::Bool, 29))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.conflict_source_note_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("conflictSourceNoteGuid", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.note_title_quality {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteTitleQuality", TType::I32, 31))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SharedNote
//

/// Represents a relationship between a note and a single share invitation recipient. The recipient
/// is identified via an Identity, and has a given privilege that specifies what actions they may
/// take on the note.
/// 
/// <dl>
///   <dt>sharerUserID</dt>
///   <dd>The user ID of the user who shared the note with the recipient.</dd>
/// 
///   <dt>recipientIdentity</dt>
///   <dd>The identity of the recipient of the share. For a given note, there may be only one
///     SharedNote per recipient identity. Only recipientIdentity.id is guaranteed to be set.
///     Other fields on the Identity may or my not be set based on the requesting user's
///     relationship with the recipient.</dd>
/// 
///   <dt>privilege</dt>
///   <dd>The privilege level that the share grants to the recipient.</dd>
/// 
///   <dt>serviceCreated</dt>
///   <dd>The time at which the share was created.</dd>
/// 
///   <dt>serviceUpdated</dt>
///   <dd>The time at which the share was last updated.</dd>
/// 
///   <dt>serviceAssigned</dt>
///   <dd>The time at which the share was assigned to a specific recipient user ID.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SharedNote {
  pub sharer_user_i_d: Option<UserID>,
  pub recipient_identity: Option<Identity>,
  pub privilege: Option<SharedNotePrivilegeLevel>,
  pub service_created: Option<Timestamp>,
  pub service_updated: Option<Timestamp>,
  pub service_assigned: Option<Timestamp>,
}

impl SharedNote {
  pub fn new<F1, F2, F3, F4, F5, F6>(sharer_user_i_d: F1, recipient_identity: F2, privilege: F3, service_created: F4, service_updated: F5, service_assigned: F6) -> SharedNote where F1: Into<Option<UserID>>, F2: Into<Option<Identity>>, F3: Into<Option<SharedNotePrivilegeLevel>>, F4: Into<Option<Timestamp>>, F5: Into<Option<Timestamp>>, F6: Into<Option<Timestamp>> {
    SharedNote {
      sharer_user_i_d: sharer_user_i_d.into(),
      recipient_identity: recipient_identity.into(),
      privilege: privilege.into(),
      service_created: service_created.into(),
      service_updated: service_updated.into(),
      service_assigned: service_assigned.into(),
    }
  }
}

impl TSerializable for SharedNote {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SharedNote> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UserID> = None;
    let mut f_2: Option<Identity> = None;
    let mut f_3: Option<SharedNotePrivilegeLevel> = None;
    let mut f_4: Option<Timestamp> = None;
    let mut f_5: Option<Timestamp> = None;
    let mut f_6: Option<Timestamp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Identity::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = SharedNotePrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SharedNote {
      sharer_user_i_d: f_1,
      recipient_identity: f_2,
      privilege: f_3,
      service_created: f_4,
      service_updated: f_5,
      service_assigned: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SharedNote");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.sharer_user_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharerUserID", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientIdentity", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_created {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceCreated", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceUpdated", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_assigned {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceAssigned", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteRestrictions
//

/// This structure captures information about the operations that cannot be performed on a given
/// note that has been shared with a recipient via a SharedNote. The following operations are
/// <b>never</b> allowed based on SharedNotes, and as such are left out of the NoteRestrictions
/// structure for brevity:
/// 
/// <ul>
///   <li>Expunging a note (NoteStore.expungeNote)</li>
///   <li>Moving a note to the trash (Note.active)</li>
///   <li>Updating a note's notebook (Note.notebookGuid)</li>
///   <li>Updating a note's tags (Note.tagGuids, Note.tagNames)</li>
///   <li>Updating a note's attributes (Note.attributes)</li>
///   <li>Sharing a note with the business (NoteStore.shareNoteWithBusiness</li>
///   <li>Getting a note's version history (NoteStore.listNoteVersions,
///     NoteStore.getNoteVersion)</li>
/// </ul>
/// 
/// When a client has permission to update a note's title or content, it may also update the
/// Note.updated timestamp.
/// 
/// <b>This structure reflects only the privileges / restrictions conveyed by the SharedNote.</b>
/// It does not incorporate privileges conveyed by a potential SharedNotebook to the same
/// recipient. As such, the actual permissions that the recipient has on the note may differ from
/// the permissions expressed in this structure.
/// 
/// For example, consider a user with read-only access to a shared notebook, and a read-write share
/// of a specific note in the notebook. The note restrictions would contain noUpdateTitle = false,
/// while the notebook restrictions would contain noUpdateNotes = true. In this case, the user is
/// allowed to update the note title based on the note restrictions.
/// 
/// Alternatively, consider a user with read-write access to a shared notebook, and a read-only
/// share of a specific note in that notebook. The note restrictions would contain
/// noUpdateTitle = true, while the notebook restrictions would contain noUpdateNotes = false. In
/// this case, the user would have full edit permissions on the note based on the notebook
/// restrictions.
/// 
/// <dl>
///   <dt>noUpdateTitle</dt>
///   <dd>The client may not update the note's title (Note.title).</dd>
/// 
///   <dt>noUpdateContent<dt>
///   <dd>The client may not update the note's content. Content includes Note.content
///     and Note.resources, as well as the related fields Note.contentHash and
///     Note.contentLength.</dd>
/// 
///   <dt>noEmail</dt>
///   <dd>The client may not email the note (NoteStore.emailNote).</dd>
/// 
///   <dt>noShare</dt>
///   <dd>The client may not share the note with specific recipients
///     (NoteStore.createOrUpdateSharedNotes).</dd>
/// 
///   <dt>noSharePublicly</dt>
///   <dd>The client may not make the note public (NoteStore.shareNote).</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteRestrictions {
  pub no_update_title: Option<bool>,
  pub no_update_content: Option<bool>,
  pub no_email: Option<bool>,
  pub no_share: Option<bool>,
  pub no_share_publicly: Option<bool>,
}

impl NoteRestrictions {
  pub fn new<F1, F2, F3, F4, F5>(no_update_title: F1, no_update_content: F2, no_email: F3, no_share: F4, no_share_publicly: F5) -> NoteRestrictions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>> {
    NoteRestrictions {
      no_update_title: no_update_title.into(),
      no_update_content: no_update_content.into(),
      no_email: no_email.into(),
      no_share: no_share.into(),
      no_share_publicly: no_share_publicly.into(),
    }
  }
}

impl TSerializable for NoteRestrictions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteRestrictions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteRestrictions {
      no_update_title: f_1,
      no_update_content: f_2,
      no_email: f_3,
      no_share: f_4,
      no_share_publicly: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteRestrictions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.no_update_title {
      o_prot.write_field_begin(&TFieldIdentifier::new("noUpdateTitle", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_update_content {
      o_prot.write_field_begin(&TFieldIdentifier::new("noUpdateContent", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("noEmail", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_share {
      o_prot.write_field_begin(&TFieldIdentifier::new("noShare", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_share_publicly {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSharePublicly", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NoteLimits
//

/// Represents the owner's account related limits on a Note.
/// The field uploaded represents the total number of bytes that have been uploaded
/// to this account and is taken from the SyncState struct. All other fields
/// represent account related limits and are taken from the AccountLimits struct.
/// <p />
/// See SyncState and AccountLimits struct field definitions for more details.
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoteLimits {
  pub note_resource_count_max: Option<i32>,
  pub upload_limit: Option<i64>,
  pub resource_size_max: Option<i64>,
  pub note_size_max: Option<i64>,
  pub uploaded: Option<i64>,
}

impl NoteLimits {
  pub fn new<F1, F2, F3, F4, F5>(note_resource_count_max: F1, upload_limit: F2, resource_size_max: F3, note_size_max: F4, uploaded: F5) -> NoteLimits where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    NoteLimits {
      note_resource_count_max: note_resource_count_max.into(),
      upload_limit: upload_limit.into(),
      resource_size_max: resource_size_max.into(),
      note_size_max: note_size_max.into(),
      uploaded: uploaded.into(),
    }
  }
}

impl TSerializable for NoteLimits {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoteLimits> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoteLimits {
      note_resource_count_max: f_1,
      upload_limit: f_2,
      resource_size_max: f_3,
      note_size_max: f_4,
      uploaded: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoteLimits");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.note_resource_count_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteResourceCountMax", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.upload_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("uploadLimit", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.resource_size_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourceSizeMax", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.note_size_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteSizeMax", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.uploaded {
      o_prot.write_field_begin(&TFieldIdentifier::new("uploaded", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Note
//

/// Represents a single note in the user's account.
/// 
/// <dl>
/// <dt>guid</dt>
///   <dd>The unique identifier of this note.  Will be set by the
///   server, but will be omitted by clients calling NoteStore.createNote()
///   <br/>
///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///   <br/>
///   Regex:  EDAM_GUID_REGEX
///   </dd>
/// 
/// <dt>title</dt>
///   <dd>The subject of the note.  Can't begin or end with a space.
///   <br/>
///   Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
///   <br/>
///   Regex:  EDAM_NOTE_TITLE_REGEX
///   </dd>
/// 
/// <dt>content</dt>
///   <dd>The XHTML block that makes up the note.  This is
///   the canonical form of the note's contents, so will include abstract
///   Evernote tags for internal resource references.  A client may create
///   a separate transformed version of this content for internal presentation,
///   but the same canonical bytes should be used for transmission and
///   comparison unless the user chooses to modify their content.
///   <br/>
///   Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
///   </dd>
/// 
/// <dt>contentHash</dt>
///   <dd>The binary MD5 checksum of the UTF-8 encoded content
///   body. This will always be set by the server, but clients may choose to omit
///   this when they submit a note with content.
///   <br/>
///   Length:  EDAM_HASH_LEN (exactly)
///   </dd>
/// 
/// <dt>contentLength</dt>
///   <dd>The number of Unicode characters in the content of
///   the note.  This will always be set by the service, but clients may choose
///   to omit this value when they submit a Note.
///   </dd>
/// 
/// <dt>created</dt>
///   <dd>The date and time when the note was created in one of the
///   clients.  In most cases, this will match the user's sense of when
///   the note was created, and ordering between notes will be based on
///   ordering of this field.  However, this is not a "reliable" timestamp
///   if a client has an incorrect clock, so it cannot provide a true absolute
///   ordering between notes.  Notes created directly through the service
///   (e.g. via the web GUI) will have an absolutely ordered "created" value.
///   </dd>
/// 
/// <dt>updated</dt>
///   <dd>The date and time when the note was last modified in one of
///   the clients.  In most cases, this will match the user's sense of when
///   the note was modified, but this field may not be absolutely reliable
///   due to the possibility of client clock errors.
///   </dd>
/// 
/// <dt>deleted</dt>
///   <dd>If present, the note is considered "deleted", and this
///   stores the date and time when the note was deleted by one of the clients.
///   In most cases, this will match the user's sense of when the note was
///   deleted, but this field may be unreliable due to the possibility of
///   client clock errors.
///   </dd>
/// 
/// <dt>active</dt>
///   <dd>If the note is available for normal actions and viewing,
///   this flag will be set to true.
///   </dd>
/// 
/// <dt>updateSequenceNum</dt>
///   <dd>A number identifying the last transaction to
///   modify the state of this note (including changes to the note's attributes
///   or resources).  The USN values are sequential within an account,
///   and can be used to compare the order of modifications within the service.
///   </dd>
/// 
/// <dt>notebookGuid</dt>
///   <dd>The unique identifier of the notebook that contains
///   this note.  If no notebookGuid is provided on a call to createNote(), the
///   default notebook will be used instead.
///   <br/>
///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///   <br/>
///   Regex:  EDAM_GUID_REGEX
///   </dd>
/// 
/// <dt>tagGuids</dt>
///   <dd>A list of the GUID identifiers for tags that are applied to this note.
///   This may be provided in a call to createNote() to unambiguously declare
///   the tags that should be assigned to the new note.  Alternately, clients
///   may pass the names of desired tags via the 'tagNames' field during
///   note creation.
///   If the list of tags are omitted on a call to createNote(), then
///   the server will assume that no changes have been made to the resources.
///   Maximum:  EDAM_NOTE_TAGS_MAX tags per note
///   </dd>
/// 
/// <dt>resources</dt>
///   <dd>The list of resources that are embedded within this note.
///   If the list of resources are omitted on a call to updateNote(), then
///   the server will assume that no changes have been made to the resources.
///   The binary contents of the resources must be provided when the resource
///   is first sent to the service, but it will be omitted by the service when
///   the Note is returned in the future.
///   Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
///   </dd>
/// 
/// <dt>attributes</dt>
///   <dd>A list of the attributes for this note.
///   If the list of attributes are omitted on a call to updateNote(), then
///   the server will assume that no changes have been made to the resources.
///   </dd>
/// 
/// <dt>tagNames</dt>
///   <dd>May be provided by clients during calls to createNote() as an
///   alternative to providing the tagGuids of existing tags.  If any tagNames
///   are provided during createNote(), these will be found, or created if they
///   don't already exist.  Created tags will have no parent (they will be at
///   the top level of the tag panel).
///   </dd>
/// 
/// <dt>sharedNotes</dt>
///   <dd>The list of recipients with whom this note has been shared. This field will be unset if
///     the caller has access to the note via the containing notebook, but does not have activity
///     feed permission for that notebook. This field is read-only. Clients may not make changes to
///     a note's sharing state via this field.
///   </dd>
/// 
///   <dt>restrictions</dt>
///   <dd>If this field is set, the user has note-level permissions that may differ from their
///     notebook-level permissions. In this case, the restrictions structure specifies
///     a set of restrictions limiting the actions that a user may take on the note based
///     on their note-level permissions. If this field is unset, then there are no
///     note-specific restrictions. However, a client may still be limited based on the user's
///     notebook permissions.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Note {
  pub guid: Option<Guid>,
  pub title: Option<String>,
  pub content: Option<String>,
  pub content_hash: Option<Vec<u8>>,
  pub content_length: Option<i32>,
  pub created: Option<Timestamp>,
  pub updated: Option<Timestamp>,
  pub deleted: Option<Timestamp>,
  pub active: Option<bool>,
  pub update_sequence_num: Option<i32>,
  pub notebook_guid: Option<String>,
  pub tag_guids: Option<Vec<Guid>>,
  pub resources: Option<Vec<Resource>>,
  pub attributes: Option<NoteAttributes>,
  pub tag_names: Option<Vec<String>>,
  pub shared_notes: Option<Vec<SharedNote>>,
  pub restrictions: Option<NoteRestrictions>,
  pub limits: Option<NoteLimits>,
}

impl Note {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18>(guid: F1, title: F2, content: F3, content_hash: F4, content_length: F5, created: F6, updated: F7, deleted: F8, active: F9, update_sequence_num: F10, notebook_guid: F11, tag_guids: F12, resources: F13, attributes: F14, tag_names: F15, shared_notes: F16, restrictions: F17, limits: F18) -> Note where F1: Into<Option<Guid>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<i32>>, F6: Into<Option<Timestamp>>, F7: Into<Option<Timestamp>>, F8: Into<Option<Timestamp>>, F9: Into<Option<bool>>, F10: Into<Option<i32>>, F11: Into<Option<String>>, F12: Into<Option<Vec<Guid>>>, F13: Into<Option<Vec<Resource>>>, F14: Into<Option<NoteAttributes>>, F15: Into<Option<Vec<String>>>, F16: Into<Option<Vec<SharedNote>>>, F17: Into<Option<NoteRestrictions>>, F18: Into<Option<NoteLimits>> {
    Note {
      guid: guid.into(),
      title: title.into(),
      content: content.into(),
      content_hash: content_hash.into(),
      content_length: content_length.into(),
      created: created.into(),
      updated: updated.into(),
      deleted: deleted.into(),
      active: active.into(),
      update_sequence_num: update_sequence_num.into(),
      notebook_guid: notebook_guid.into(),
      tag_guids: tag_guids.into(),
      resources: resources.into(),
      attributes: attributes.into(),
      tag_names: tag_names.into(),
      shared_notes: shared_notes.into(),
      restrictions: restrictions.into(),
      limits: limits.into(),
    }
  }
}

impl TSerializable for Note {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Note> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Guid> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<Timestamp> = None;
    let mut f_7: Option<Timestamp> = None;
    let mut f_8: Option<Timestamp> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<Vec<Guid>> = None;
    let mut f_13: Option<Vec<Resource>> = None;
    let mut f_14: Option<NoteAttributes> = None;
    let mut f_15: Option<Vec<String>> = None;
    let mut f_16: Option<Vec<SharedNote>> = None;
    let mut f_17: Option<NoteRestrictions> = None;
    let mut f_18: Option<NoteLimits> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Guid> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        13 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Resource> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = Resource::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_13 = Some(val);
        },
        14 => {
          let val = NoteAttributes::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        15 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = i_prot.read_string()?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_15 = Some(val);
        },
        16 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SharedNote> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = SharedNote::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_16 = Some(val);
        },
        17 => {
          let val = NoteRestrictions::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let val = NoteLimits::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Note {
      guid: f_1,
      title: f_2,
      content: f_3,
      content_hash: f_4,
      content_length: f_5,
      created: f_6,
      updated: f_7,
      deleted: f_8,
      active: f_9,
      update_sequence_num: f_10,
      notebook_guid: f_11,
      tag_guids: f_12,
      resources: f_13,
      attributes: f_14,
      tag_names: f_15,
      shared_notes: f_16,
      restrictions: f_17,
      limits: f_18,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Note");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.content {
      o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.content_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentHash", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.content_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentLength", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created {
      o_prot.write_field_begin(&TFieldIdentifier::new("created", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("updated", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.deleted {
      o_prot.write_field_begin(&TFieldIdentifier::new("deleted", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.active {
      o_prot.write_field_begin(&TFieldIdentifier::new("active", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebook_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tag_guids {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagGuids", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resources {
      o_prot.write_field_begin(&TFieldIdentifier::new("resources", TType::List, 13))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tag_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagNames", TType::List, 15))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shared_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharedNotes", TType::List, 16))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("restrictions", TType::Struct, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limits {
      o_prot.write_field_begin(&TFieldIdentifier::new("limits", TType::Struct, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Publishing
//

/// If a Notebook has been opened to the public, the Notebook will have a
/// reference to one of these structures, which gives the location and optional
/// description of the externally-visible public Notebook.
/// <dl>
/// <dt>uri</dt>
///   <dd>If this field is present, then the notebook is published for
///   mass consumption on the Internet under the provided URI, which is
///   relative to a defined base publishing URI defined by the service.
///   This field can only be modified via the web service GUI ... publishing
///   cannot be modified via an offline client.
///   <br/>
///   Length:  EDAM_PUBLISHING_URI_LEN_MIN - EDAM_PUBLISHING_URI_LEN_MAX
///   <br/>
///   Regex:  EDAM_PUBLISHING_URI_REGEX
///   </dd>
/// 
/// <dt>order</dt>
///   <dd>When the notes are publicly displayed, they will be sorted
///   based on the requested criteria.
///   </dd>
/// 
/// <dt>ascending</dt>
///   <dd>If this is set to true, then the public notes will be
///   displayed in ascending order (e.g. from oldest to newest).  Otherwise,
///   the notes will be displayed in descending order (e.g. newest to oldest).
///   </dd>
/// 
/// <dt>publicDescription</dt>
///   <dd>This field may be used to provide a short
///   description of the notebook, which may be displayed when (e.g.) the
///   notebook is shown in a public view.  Can't begin or end with a space.
///   <br/>
///   Length:  EDAM_PUBLISHING_DESCRIPTION_LEN_MIN -
///            EDAM_PUBLISHING_DESCRIPTION_LEN_MAX
///   <br/>
///   Regex:  EDAM_PUBLISHING_DESCRIPTION_REGEX
///   </dd>
/// 
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Publishing {
  pub uri: Option<String>,
  pub order: Option<NoteSortOrder>,
  pub ascending: Option<bool>,
  pub public_description: Option<String>,
}

impl Publishing {
  pub fn new<F1, F2, F3, F4>(uri: F1, order: F2, ascending: F3, public_description: F4) -> Publishing where F1: Into<Option<String>>, F2: Into<Option<NoteSortOrder>>, F3: Into<Option<bool>>, F4: Into<Option<String>> {
    Publishing {
      uri: uri.into(),
      order: order.into(),
      ascending: ascending.into(),
      public_description: public_description.into(),
    }
  }
}

impl TSerializable for Publishing {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Publishing> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<NoteSortOrder> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoteSortOrder::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Publishing {
      uri: f_1,
      order: f_2,
      ascending: f_3,
      public_description: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Publishing");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.uri {
      o_prot.write_field_begin(&TFieldIdentifier::new("uri", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.order {
      o_prot.write_field_begin(&TFieldIdentifier::new("order", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ascending {
      o_prot.write_field_begin(&TFieldIdentifier::new("ascending", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.public_description {
      o_prot.write_field_begin(&TFieldIdentifier::new("publicDescription", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BusinessNotebook
//

/// If a Notebook contained in an Evernote Business account has been published
/// the to business library, the Notebook will have a reference to one of these
/// structures, which specifies how the Notebook will be represented in the
/// library.
/// 
/// <dl>
/// <dt>notebookDescription</dt>
///   <dd>A short description of the notebook's content that will be displayed
///       in the business library user interface. The description may not begin
///       or end with whitespace.
///   <br/>
///   Length: EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MIN -
///           EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_LEN_MAX
///   <br/>
///   Regex:  EDAM_BUSINESS_NOTEBOOK_DESCRIPTION_REGEX
///   </dd>
/// 
/// <dt>privilege</dt>
///   <dd>The privileges that will be granted to users who join the notebook through
///       the business library.
///   </dd>
/// 
/// <dt>recommended</dt>
///   <dd>Whether the notebook should be "recommended" when displayed in the business
///       library user interface.
///   </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BusinessNotebook {
  pub notebook_description: Option<String>,
  pub privilege: Option<SharedNotebookPrivilegeLevel>,
  pub recommended: Option<bool>,
}

impl BusinessNotebook {
  pub fn new<F1, F2, F3>(notebook_description: F1, privilege: F2, recommended: F3) -> BusinessNotebook where F1: Into<Option<String>>, F2: Into<Option<SharedNotebookPrivilegeLevel>>, F3: Into<Option<bool>> {
    BusinessNotebook {
      notebook_description: notebook_description.into(),
      privilege: privilege.into(),
      recommended: recommended.into(),
    }
  }
}

impl TSerializable for BusinessNotebook {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BusinessNotebook> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<SharedNotebookPrivilegeLevel> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = SharedNotebookPrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BusinessNotebook {
      notebook_description: f_1,
      privilege: f_2,
      recommended: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BusinessNotebook");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.notebook_description {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookDescription", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recommended {
      o_prot.write_field_begin(&TFieldIdentifier::new("recommended", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SavedSearchScope
//

/// A structure defining the scope of a SavedSearch.
/// 
/// <dl>
///   <dt>includeAccount</dt>
///   <dd>The search should include notes from the account that contains the SavedSearch.</dd>
/// 
///   <dt>includePersonalLinkedNotebooks</dt>
///   <dd>The search should include notes within those shared notebooks
///   that the user has joined that are NOT business notebooks.</dd>
/// 
///   <dt>includeBusinessLinkedNotebooks</dt>
///   <dd>The search should include notes within those shared notebooks
///   that the user has joined that are business notebooks in the business that
///   the user is currently a member of.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SavedSearchScope {
  pub include_account: Option<bool>,
  pub include_personal_linked_notebooks: Option<bool>,
  pub include_business_linked_notebooks: Option<bool>,
}

impl SavedSearchScope {
  pub fn new<F1, F2, F3>(include_account: F1, include_personal_linked_notebooks: F2, include_business_linked_notebooks: F3) -> SavedSearchScope where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>> {
    SavedSearchScope {
      include_account: include_account.into(),
      include_personal_linked_notebooks: include_personal_linked_notebooks.into(),
      include_business_linked_notebooks: include_business_linked_notebooks.into(),
    }
  }
}

impl TSerializable for SavedSearchScope {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SavedSearchScope> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SavedSearchScope {
      include_account: f_1,
      include_personal_linked_notebooks: f_2,
      include_business_linked_notebooks: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SavedSearchScope");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.include_account {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeAccount", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_personal_linked_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("includePersonalLinkedNotebooks", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_business_linked_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeBusinessLinkedNotebooks", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SavedSearch
//

/// A named search associated with the account that can be quickly re-used.
/// <dl>
/// <dt>guid</dt>
///   <dd>The unique identifier of this search.  Will be set by the
///   service, so may be omitted by the client when creating.
///   <br/>
///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///   <br/>
///   Regex:  EDAM_GUID_REGEX
///   </dd>
/// 
/// <dt>name</dt>
///   <dd>The name of the saved search to display in the GUI.  The
///   account may only contain one search with a given name (case-insensitive
///   compare). Can't begin or end with a space.
///   <br/>
///   Length:  EDAM_SAVED_SEARCH_NAME_LEN_MIN - EDAM_SAVED_SEARCH_NAME_LEN_MAX
///   <br/>
///   Regex:  EDAM_SAVED_SEARCH_NAME_REGEX
///   </dd>
/// 
/// <dt>query</dt>
///   <dd>A string expressing the search to be performed.
///   <br/>
///   Length:  EDAM_SAVED_SEARCH_QUERY_LEN_MIN - EDAM_SAVED_SEARCH_QUERY_LEN_MAX
///   </dd>
/// 
/// <dt>format</dt>
///   <dd>The format of the query string, to determine how to parse
///   and process it.
///   </dd>
/// 
/// <dt>updateSequenceNum</dt>
///   <dd>A number identifying the last transaction to
///   modify the state of this object.  The USN values are sequential within an
///   account, and can be used to compare the order of modifications within the
///   service.
///   </dd>
/// 
/// <dt>scope</dt>
///   <dd><p>Specifies the set of notes that should be included in the search, if
///    possible.</p>
///    <p>Clients are expected to search as much of the desired scope as possible,
///    with the understanding that a given client may not be able to cover the full
///    specified scope. For example, when executing a search that includes notes in both
///    the owner's account and business notebooks, a mobile client may choose to only
///    search within the user's account because it is not capable of searching both
///    scopes simultaneously. When a search across multiple scopes is not possible,
///    a client may choose which scope to search based on the current application
///    context. If a client cannot search any of the desired scopes, it should refuse
///    to execute the search.</p>
///    </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SavedSearch {
  pub guid: Option<Guid>,
  pub name: Option<String>,
  pub query: Option<String>,
  pub format: Option<QueryFormat>,
  pub update_sequence_num: Option<i32>,
  pub scope: Option<SavedSearchScope>,
}

impl SavedSearch {
  pub fn new<F1, F2, F3, F4, F5, F6>(guid: F1, name: F2, query: F3, format: F4, update_sequence_num: F5, scope: F6) -> SavedSearch where F1: Into<Option<Guid>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<QueryFormat>>, F5: Into<Option<i32>>, F6: Into<Option<SavedSearchScope>> {
    SavedSearch {
      guid: guid.into(),
      name: name.into(),
      query: query.into(),
      format: format.into(),
      update_sequence_num: update_sequence_num.into(),
      scope: scope.into(),
    }
  }
}

impl TSerializable for SavedSearch {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SavedSearch> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Guid> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<QueryFormat> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<SavedSearchScope> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = QueryFormat::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = SavedSearchScope::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SavedSearch {
      guid: f_1,
      name: f_2,
      query: f_3,
      format: f_4,
      update_sequence_num: f_5,
      scope: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SavedSearch");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query {
      o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.format {
      o_prot.write_field_begin(&TFieldIdentifier::new("format", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.scope {
      o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SharedNotebookRecipientSettings
//

/// Settings meant for the recipient of a shared notebook, such as
/// for indicating which types of notifications the recipient wishes
/// for reminders, etc.
/// 
/// The reminderNotifyEmail and reminderNotifyInApp fields have a
/// 3-state read value but a 2-state write value.  On read, it is
/// possible to observe "unset", true, or false.  The initial state is
/// "unset".  When you choose to set a value, you may set it to either
/// true or false, but you cannot unset the value.  Once one of these
/// members has a true/false value, it will always have a true/false
/// value.
/// 
/// <dl>
/// <dt>reminderNotifyEmail</dt>
/// <dd>Indicates that the user wishes to receive daily e-mail notifications
///     for reminders associated with the notebook. This may be true only for
///     business notebooks that belong to the business of which the user is a
///     member. You may only set this value on a notebook in your business.</dd>
/// <dt>reminderNotifyInApp</dt>
/// <dd>Indicates that the user wishes to receive notifications for
///     reminders by applications that support providing such
///     notifications.  The exact nature of the notification is defined
///     by the individual applications.</dd>
/// </dl>
/// 
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SharedNotebookRecipientSettings {
  pub reminder_notify_email: Option<bool>,
  pub reminder_notify_in_app: Option<bool>,
}

impl SharedNotebookRecipientSettings {
  pub fn new<F1, F2>(reminder_notify_email: F1, reminder_notify_in_app: F2) -> SharedNotebookRecipientSettings where F1: Into<Option<bool>>, F2: Into<Option<bool>> {
    SharedNotebookRecipientSettings {
      reminder_notify_email: reminder_notify_email.into(),
      reminder_notify_in_app: reminder_notify_in_app.into(),
    }
  }
}

impl TSerializable for SharedNotebookRecipientSettings {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SharedNotebookRecipientSettings> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SharedNotebookRecipientSettings {
      reminder_notify_email: f_1,
      reminder_notify_in_app: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SharedNotebookRecipientSettings");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.reminder_notify_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderNotifyEmail", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.reminder_notify_in_app {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderNotifyInApp", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotebookRecipientSettings
//

/// Settings meant for the recipient of a notebook share.
/// 
/// Some of these fields have a 3-state read value but a 2-state write value.
/// On read, it is possible to observe "unset", true, or false. The initial
/// state is "unset". When you choose to set a value, you may set it to either
/// true or false, but you cannot unset the value. Once one of these members
/// has a true/false value, it will always have a true/false value.
/// 
/// <dl>
/// <dt>reminderNotifyEmail</dt>
/// <dd>Indicates that the user wishes to receive daily e-mail notifications
///     for reminders associated with the notebook. This may be
///     true only for business notebooks that belong to the business of
///     which the user is a member. You may only set this value on a
///     notebook in your business. This value will initially be unset.</dd>
/// <dt>reminderNotifyInApp</dt>
/// <dd>Indicates that the user wishes to receive notifications for
///     reminders by applications that support providing such
///     notifications.  The exact nature of the notification is defined
///     by the individual applications. This value will initially be unset.</dd>
/// </dl>
/// <dt>inMyList</dt>
/// <dd>DEPRECATED: Use recipientStatus instead.
///     The notebook is on the recipient's notebook list (formerly, we would say
///     that the recipient has "joined" the notebook)</dd>
/// <dt>recipientStatus</dt>
/// <dd>The notebook is on/off the recipient's notebook list (formerly, we would say
///     that the recipient has "joined" the notebook) and perhaps also their
///     default notebook</dd>
/// <dt>stack</dt>
/// <dd>The stack the recipient has put this notebook into. See Notebook.stack
/// for a definition. Every recipient can have their own stack value for the same
/// notebook.</dd>
/// </dl>
/// 
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotebookRecipientSettings {
  pub reminder_notify_email: Option<bool>,
  pub reminder_notify_in_app: Option<bool>,
  pub in_my_list: Option<bool>,
  pub stack: Option<String>,
  pub recipient_status: Option<RecipientStatus>,
}

impl NotebookRecipientSettings {
  pub fn new<F1, F2, F3, F4, F5>(reminder_notify_email: F1, reminder_notify_in_app: F2, in_my_list: F3, stack: F4, recipient_status: F5) -> NotebookRecipientSettings where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<String>>, F5: Into<Option<RecipientStatus>> {
    NotebookRecipientSettings {
      reminder_notify_email: reminder_notify_email.into(),
      reminder_notify_in_app: reminder_notify_in_app.into(),
      in_my_list: in_my_list.into(),
      stack: stack.into(),
      recipient_status: recipient_status.into(),
    }
  }
}

impl TSerializable for NotebookRecipientSettings {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotebookRecipientSettings> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<RecipientStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = RecipientStatus::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotebookRecipientSettings {
      reminder_notify_email: f_1,
      reminder_notify_in_app: f_2,
      in_my_list: f_3,
      stack: f_4,
      recipient_status: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotebookRecipientSettings");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.reminder_notify_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderNotifyEmail", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.reminder_notify_in_app {
      o_prot.write_field_begin(&TFieldIdentifier::new("reminderNotifyInApp", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.in_my_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("inMyList", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.stack {
      o_prot.write_field_begin(&TFieldIdentifier::new("stack", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientStatus", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SharedNotebook
//

/// Shared notebooks represent a relationship between a notebook and a single
/// share invitation recipient.
/// <dl>
/// <dt>id</dt>
/// <dd>The primary identifier of the share, which is not globally unique.</dd>
/// 
/// <dt>userId</dt>
/// <dd>The user id of the owner of the notebook.</dd>
/// 
/// <dt>notebookGuid</dt>
/// <dd>The GUID of the notebook that has been shared.</dd>
/// 
/// <dt>email</dt>
/// <dd>A string containing a display name for the recipient of the share. This may
///     be an email address, a phone number, a full name, or some other descriptive
///     string This field is read-only to clients. It will be filled in by the service
///     when returning shared notebooks.
/// </dd>
/// 
/// <dt>recipientIdentityId</dt>
/// <dd>The IdentityID of the share recipient. If present, only the user who has
///     claimed that identity may access this share.
/// </dd>
/// 
/// <dt>notebookModifiable</dt>
/// <dd>DEPRECATED</dd>
/// 
/// <dt>serviceCreated</dt>
/// <dd>The date that the owner first created the share with the specific email
///   address.</dd>
/// 
/// <dt>serviceUpdated</dt>
/// <dd>The date the shared notebook was last updated on the service.  This
///     will be updated when authenticateToSharedNotebook is called the first
///     time with a shared notebook (i.e. when the username is bound to that
///     shared notebook), and also when the SharedNotebook privilege is updated
///     as part of a shareNotebook(...) call, as well as on any calls to
///     updateSharedNotebook(...).
/// </dd>
/// 
/// <dt>username</dt>
/// <dd>DEPRECATED. The username of the user who can access this share. This
///     value is read-only to clients. It will be filled in by the service when
///     returning shared notebooks.
/// </dd>
/// 
/// <dt>privilege</dt>
/// <dd>The privilege level granted to the notebook, activity stream, and
///     invitations.  See the corresponding enumeration for details.
/// </dd>
/// 
/// <dt>recipientSettings</dt>
/// <dd>Settings intended for use only by the recipient of this shared
///     notebook.  You should skip setting this value unless you want
///     to change the value contained inside the structure, and only if
///     you are the recipient.</dd>
/// 
/// <dt>globalId</dt>
/// <dd>An immutable, opaque string that acts as a globally unique
///     identifier for this shared notebook record.  You can use this field to
///     match linked notebook and shared notebook records as well as to
///     create new LinkedNotebook records.  This field replaces the deprecated
///     shareKey field.
/// </dd>
/// 
/// <dt>sharerUserId</dt>
/// <dd>The user id of the user who shared a notebook via this shared notebook
///     instance. This may not be the same as userId, since a user with full
///     access to a notebook may have created a new share for that notebook. For
///     Business, this represents the user who shared the business notebook. This
///     field is currently unset for a SharedNotebook created by joining a
///     notebook that has been published to the business.
/// </dd>
/// 
/// <dt>recipientUsername</dt>
/// <dd>The username of the user who can access this share. This is the username
///     for the user with the id in recipientUserId. This value can be set
///     by clients when calling shareNotebook(...), and that will result in the
///     created SharedNotebook being assigned to a user. This value is always set
///     if serviceAssigned is set.
/// </dd>
/// 
/// <dt>recipientUserId</dt>
/// <dd>The id of the user who can access this share. This is the id for the user
///     with the username in recipientUsername. This value is read-only and set
///     by the service. Value set by clients will be ignored. This field may be unset
///     for unjoined notebooks and is always set if serviceAssigned is set. Clients should
///     prefer this field over recipientUsername unless they need to use usernames
///     directly.
/// </dd>
/// 
/// <dt>serviceAssigned</dt>
/// <dd>The date this SharedNotebook was assigned (i.e. has been associated with an
///     Evernote user whose user ID is set in recipientUserId). Unset if the SharedNotebook
///     is not assigned. This field is a read-only value that is set by the service.
/// </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SharedNotebook {
  pub id: Option<i64>,
  pub user_id: Option<UserID>,
  pub notebook_guid: Option<Guid>,
  pub email: Option<String>,
  pub notebook_modifiable: Option<bool>,
  pub service_created: Option<Timestamp>,
  pub global_id: Option<String>,
  pub username: Option<String>,
  pub service_updated: Option<Timestamp>,
  pub privilege: Option<SharedNotebookPrivilegeLevel>,
  pub recipient_settings: Option<SharedNotebookRecipientSettings>,
  pub sharer_user_id: Option<UserID>,
  pub recipient_username: Option<String>,
  pub service_assigned: Option<Timestamp>,
  pub recipient_user_id: Option<UserID>,
  pub recipient_identity_id: Option<IdentityID>,
}

impl SharedNotebook {
  pub fn new<F1, F2, F3, F4, F5, F7, F8, F9, F10, F11, F13, F14, F15, F16, F17, F18>(id: F1, user_id: F2, notebook_guid: F3, email: F4, notebook_modifiable: F5, service_created: F7, global_id: F8, username: F9, service_updated: F10, privilege: F11, recipient_settings: F13, sharer_user_id: F14, recipient_username: F15, service_assigned: F16, recipient_user_id: F17, recipient_identity_id: F18) -> SharedNotebook where F1: Into<Option<i64>>, F2: Into<Option<UserID>>, F3: Into<Option<Guid>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F7: Into<Option<Timestamp>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<Timestamp>>, F11: Into<Option<SharedNotebookPrivilegeLevel>>, F13: Into<Option<SharedNotebookRecipientSettings>>, F14: Into<Option<UserID>>, F15: Into<Option<String>>, F16: Into<Option<Timestamp>>, F17: Into<Option<UserID>>, F18: Into<Option<IdentityID>> {
    SharedNotebook {
      id: id.into(),
      user_id: user_id.into(),
      notebook_guid: notebook_guid.into(),
      email: email.into(),
      notebook_modifiable: notebook_modifiable.into(),
      service_created: service_created.into(),
      global_id: global_id.into(),
      username: username.into(),
      service_updated: service_updated.into(),
      privilege: privilege.into(),
      recipient_settings: recipient_settings.into(),
      sharer_user_id: sharer_user_id.into(),
      recipient_username: recipient_username.into(),
      service_assigned: service_assigned.into(),
      recipient_user_id: recipient_user_id.into(),
      recipient_identity_id: recipient_identity_id.into(),
    }
  }
}

impl TSerializable for SharedNotebook {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SharedNotebook> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<UserID> = None;
    let mut f_3: Option<Guid> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_7: Option<Timestamp> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<Timestamp> = None;
    let mut f_11: Option<SharedNotebookPrivilegeLevel> = None;
    let mut f_13: Option<SharedNotebookRecipientSettings> = None;
    let mut f_14: Option<UserID> = None;
    let mut f_15: Option<String> = None;
    let mut f_16: Option<Timestamp> = None;
    let mut f_17: Option<UserID> = None;
    let mut f_18: Option<IdentityID> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        11 => {
          let val = SharedNotebookPrivilegeLevel::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        13 => {
          let val = SharedNotebookRecipientSettings::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i32()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_i64()?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SharedNotebook {
      id: f_1,
      user_id: f_2,
      notebook_guid: f_3,
      email: f_4,
      notebook_modifiable: f_5,
      service_created: f_7,
      global_id: f_8,
      username: f_9,
      service_updated: f_10,
      privilege: f_11,
      recipient_settings: f_13,
      sharer_user_id: f_14,
      recipient_username: f_15,
      service_assigned: f_16,
      recipient_user_id: f_17,
      recipient_identity_id: f_18,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SharedNotebook");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebook_guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookGuid", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.notebook_modifiable {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookModifiable", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_created {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceCreated", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.global_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("globalId", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceUpdated", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::I32, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_settings {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientSettings", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sharer_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharerUserId", TType::I32, 14))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_username {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientUsername", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_assigned {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceAssigned", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recipient_user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientUserId", TType::I32, 17))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.recipient_identity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientIdentityId", TType::I64, 18))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CanMoveToContainerRestrictions
//

/// Specifies if the client can move a Notebook to a Workspace.
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CanMoveToContainerRestrictions {
  pub can_move_to_container: Option<CanMoveToContainerStatus>,
}

impl CanMoveToContainerRestrictions {
  pub fn new<F1>(can_move_to_container: F1) -> CanMoveToContainerRestrictions where F1: Into<Option<CanMoveToContainerStatus>> {
    CanMoveToContainerRestrictions {
      can_move_to_container: can_move_to_container.into(),
    }
  }
}

impl TSerializable for CanMoveToContainerRestrictions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CanMoveToContainerRestrictions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CanMoveToContainerStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CanMoveToContainerStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CanMoveToContainerRestrictions {
      can_move_to_container: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CanMoveToContainerRestrictions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.can_move_to_container {
      o_prot.write_field_begin(&TFieldIdentifier::new("canMoveToContainer", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotebookRestrictions
//

/// This structure captures information about the types of operations
/// that cannot be performed on a given notebook with a type of
/// authenticated access and credentials.  The values filled into this
/// structure are based on then-current values in the server database
/// for shared notebooks and notebook publishing records, as well as
/// information related to the authentication token.  Information from
/// the authentication token includes the application that is accessing
/// the server, as defined by the permissions granted by consumer (api)
/// key, and the method used to obtain the token, for example via
/// authenticateToSharedNotebook, authenticateToBusiness, etc.  Note
/// that changes to values in this structure that are the result of
/// shared notebook or publishing record changes are communicated to
/// the client via a change in the notebook USN during sync.  It is
/// important to use the same access method, parameters, and consumer
/// key in order obtain correct results from the sync engine.
/// 
/// The server has the final say on what is allowed as values may
/// change between calls to obtain NotebookRestrictions instances
/// and to operate on data on the service.
/// 
/// If the following are set and true, then the given restriction is
/// in effect, as accessed by the same authentication token from which
/// the values were obtained.
/// 
/// <dl>
/// <dt>noReadNotes</dt>
///   <dd>The client is not able to read notes from the service and
///   the notebook is write-only.
///   </dd>
/// <dt>noCreateNotes</dt>
///   <dd>The client may not create new notes in the notebook.
///   </dd>
/// <dt>noUpdateNotes</dt>
///   <dd>The client may not update notes currently in the notebook.
///   </dd>
/// <dt>noExpungeNotes</dt>
///   <dd>The client may not expunge notes currently in the notebook.
///   </dd>
/// <dt>noShareNotes</dt>
///   <dd>The client may not share notes in the notebook via the
///   shareNote or createOrUpdateSharedNotes methods.
///   </dd>
/// <dt>noEmailNotes</dt>
///   <dd>The client may not e-mail notes by guid via the Evernote
///   service by using the emailNote method.  Email notes by value
///   by populating the note parameter instead.
///   </dd>
/// <dt>noSendMessageToRecipients</dt>
///   <dd>The client may not send messages to the share recipients of
///   the notebook.
///   </dd>
/// <dt>noUpdateNotebook</dt>
///   <dd>The client may not update the Notebook object itself, for
///   example, via the updateNotebook method.
///   </dd>
/// <dt>noExpungeNotebook</dt>
///   <dd>The client may not expunge the Notebook object itself, for
///   example, via the expungeNotebook method.
///   </dd>
/// <dt>noSetDefaultNotebook</dt>
///   <dd>The client may not set this notebook to be the default notebook.
///   The caller should leave Notebook.defaultNotebook unset.
///   </dd>
/// <dt>noSetNotebookStack</dt>
///   <dd>If the client is able to update the Notebook, the Notebook.stack
///   value may not be set.
///   </dd>
/// <dt>noPublishToPublic</dt>
///   <dd>The client may not publish the notebook to the public.
///   For example, business notebooks may not be shared publicly.
///   </dd>
/// <dt>noPublishToBusinessLibrary</dt>
///   <dd>The client may not publish the notebook to the business library.
///   </dd>
/// <dt>noCreateTags</dt>
///   <dd>The client may not complete an operation that results in a new tag
///   being created in the owner's account.
///   </dd>
/// <dt>noUpdateTags</dt>
///   <dd>The client may not update tags in the owner's account.
///   </dd>
/// <dt>noExpungeTags</dt>
///   <dd>The client may not expunge tags in the owner's account.
///   </dd>
/// <dt>noSetParentTag</dt>
///   <dd>If the client is able to create or update tags in the owner's account,
///   then they will not be able to set the parent tag.  Leave the value unset.
///   </dd>
/// <dt>noCreateSharedNotebooks</dt>
///   <dd>The client is unable to create shared notebooks for the notebook.
///   </dd>
/// <dt>updateWhichSharedNotebookRestrictions</dt>
///   <dd>Restrictions on which shared notebook instances can be updated.  If the
///   value is not set or null, then the client can update any of the shared notebooks
///   associated with the notebook on which the NotebookRestrictions are defined.
///   See the enumeration for further details.
///   </dd>
/// <dt>expungeWhichSharedNotebookRestrictions</dt>
///   <dd>Restrictions on which shared notebook instances can be expunged.  If the
///   value is not set or null, then the client can expunge any of the shared notebooks
///   associated with the notebook on which the NotebookRestrictions are defined.
///   See the enumeration for further details.
///   </dd>
/// <dt>noShareNotesWithBusiness</dt>
///   <dd>The client may not share notes in the notebook via the shareNoteWithBusiness
///   method.
///   </dd>
/// <dt>noRenameNotebook</dt>
///   <dd>The client may not rename this notebook.</dd>
/// <dt>noSetInMyList</dt>
///   <dd>clients may not change the NotebookRecipientSettings.inMyList settings for
///   this notebook.</dd>
/// <dt>noSetContact</dt>
///   <dd>The contact for this notebook may not be changed.</dd>
/// </dl>
/// <dt>canMoveToContainerRestrictions</dt>
///   <dd>Specifies if the client can move this notebook to a container and if not,
///   the reason why.</dd>
/// <dt>noCanMoveNote</dt>
///   <dd>If set, the client cannot move a Note into or out of the Notebook.</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotebookRestrictions {
  pub no_read_notes: Option<bool>,
  pub no_create_notes: Option<bool>,
  pub no_update_notes: Option<bool>,
  pub no_expunge_notes: Option<bool>,
  pub no_share_notes: Option<bool>,
  pub no_email_notes: Option<bool>,
  pub no_send_message_to_recipients: Option<bool>,
  pub no_update_notebook: Option<bool>,
  pub no_expunge_notebook: Option<bool>,
  pub no_set_default_notebook: Option<bool>,
  pub no_set_notebook_stack: Option<bool>,
  pub no_publish_to_public: Option<bool>,
  pub no_publish_to_business_library: Option<bool>,
  pub no_create_tags: Option<bool>,
  pub no_update_tags: Option<bool>,
  pub no_expunge_tags: Option<bool>,
  pub no_set_parent_tag: Option<bool>,
  pub no_create_shared_notebooks: Option<bool>,
  pub update_which_shared_notebook_restrictions: Option<SharedNotebookInstanceRestrictions>,
  pub expunge_which_shared_notebook_restrictions: Option<SharedNotebookInstanceRestrictions>,
  pub no_share_notes_with_business: Option<bool>,
  pub no_rename_notebook: Option<bool>,
  pub no_set_in_my_list: Option<bool>,
  pub no_change_contact: Option<bool>,
  pub can_move_to_container_restrictions: Option<CanMoveToContainerRestrictions>,
  pub no_set_reminder_notify_email: Option<bool>,
  pub no_set_reminder_notify_in_app: Option<bool>,
  pub no_set_recipient_settings_stack: Option<bool>,
  pub no_can_move_note: Option<bool>,
}

impl NotebookRestrictions {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F26, F27, F28, F29, F30>(no_read_notes: F1, no_create_notes: F2, no_update_notes: F3, no_expunge_notes: F4, no_share_notes: F5, no_email_notes: F6, no_send_message_to_recipients: F7, no_update_notebook: F8, no_expunge_notebook: F9, no_set_default_notebook: F10, no_set_notebook_stack: F11, no_publish_to_public: F12, no_publish_to_business_library: F13, no_create_tags: F14, no_update_tags: F15, no_expunge_tags: F16, no_set_parent_tag: F17, no_create_shared_notebooks: F18, update_which_shared_notebook_restrictions: F19, expunge_which_shared_notebook_restrictions: F20, no_share_notes_with_business: F21, no_rename_notebook: F22, no_set_in_my_list: F23, no_change_contact: F24, can_move_to_container_restrictions: F26, no_set_reminder_notify_email: F27, no_set_reminder_notify_in_app: F28, no_set_recipient_settings_stack: F29, no_can_move_note: F30) -> NotebookRestrictions where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<bool>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<bool>>, F17: Into<Option<bool>>, F18: Into<Option<bool>>, F19: Into<Option<SharedNotebookInstanceRestrictions>>, F20: Into<Option<SharedNotebookInstanceRestrictions>>, F21: Into<Option<bool>>, F22: Into<Option<bool>>, F23: Into<Option<bool>>, F24: Into<Option<bool>>, F26: Into<Option<CanMoveToContainerRestrictions>>, F27: Into<Option<bool>>, F28: Into<Option<bool>>, F29: Into<Option<bool>>, F30: Into<Option<bool>> {
    NotebookRestrictions {
      no_read_notes: no_read_notes.into(),
      no_create_notes: no_create_notes.into(),
      no_update_notes: no_update_notes.into(),
      no_expunge_notes: no_expunge_notes.into(),
      no_share_notes: no_share_notes.into(),
      no_email_notes: no_email_notes.into(),
      no_send_message_to_recipients: no_send_message_to_recipients.into(),
      no_update_notebook: no_update_notebook.into(),
      no_expunge_notebook: no_expunge_notebook.into(),
      no_set_default_notebook: no_set_default_notebook.into(),
      no_set_notebook_stack: no_set_notebook_stack.into(),
      no_publish_to_public: no_publish_to_public.into(),
      no_publish_to_business_library: no_publish_to_business_library.into(),
      no_create_tags: no_create_tags.into(),
      no_update_tags: no_update_tags.into(),
      no_expunge_tags: no_expunge_tags.into(),
      no_set_parent_tag: no_set_parent_tag.into(),
      no_create_shared_notebooks: no_create_shared_notebooks.into(),
      update_which_shared_notebook_restrictions: update_which_shared_notebook_restrictions.into(),
      expunge_which_shared_notebook_restrictions: expunge_which_shared_notebook_restrictions.into(),
      no_share_notes_with_business: no_share_notes_with_business.into(),
      no_rename_notebook: no_rename_notebook.into(),
      no_set_in_my_list: no_set_in_my_list.into(),
      no_change_contact: no_change_contact.into(),
      can_move_to_container_restrictions: can_move_to_container_restrictions.into(),
      no_set_reminder_notify_email: no_set_reminder_notify_email.into(),
      no_set_reminder_notify_in_app: no_set_reminder_notify_in_app.into(),
      no_set_recipient_settings_stack: no_set_recipient_settings_stack.into(),
      no_can_move_note: no_can_move_note.into(),
    }
  }
}

impl TSerializable for NotebookRestrictions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotebookRestrictions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<bool> = None;
    let mut f_15: Option<bool> = None;
    let mut f_16: Option<bool> = None;
    let mut f_17: Option<bool> = None;
    let mut f_18: Option<bool> = None;
    let mut f_19: Option<SharedNotebookInstanceRestrictions> = None;
    let mut f_20: Option<SharedNotebookInstanceRestrictions> = None;
    let mut f_21: Option<bool> = None;
    let mut f_22: Option<bool> = None;
    let mut f_23: Option<bool> = None;
    let mut f_24: Option<bool> = None;
    let mut f_26: Option<CanMoveToContainerRestrictions> = None;
    let mut f_27: Option<bool> = None;
    let mut f_28: Option<bool> = None;
    let mut f_29: Option<bool> = None;
    let mut f_30: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_bool()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_bool()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_bool()?;
          f_18 = Some(val);
        },
        19 => {
          let val = SharedNotebookInstanceRestrictions::read_from_in_protocol(i_prot)?;
          f_19 = Some(val);
        },
        20 => {
          let val = SharedNotebookInstanceRestrictions::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_bool()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_bool()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_bool()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_bool()?;
          f_24 = Some(val);
        },
        26 => {
          let val = CanMoveToContainerRestrictions::read_from_in_protocol(i_prot)?;
          f_26 = Some(val);
        },
        27 => {
          let val = i_prot.read_bool()?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_bool()?;
          f_28 = Some(val);
        },
        29 => {
          let val = i_prot.read_bool()?;
          f_29 = Some(val);
        },
        30 => {
          let val = i_prot.read_bool()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotebookRestrictions {
      no_read_notes: f_1,
      no_create_notes: f_2,
      no_update_notes: f_3,
      no_expunge_notes: f_4,
      no_share_notes: f_5,
      no_email_notes: f_6,
      no_send_message_to_recipients: f_7,
      no_update_notebook: f_8,
      no_expunge_notebook: f_9,
      no_set_default_notebook: f_10,
      no_set_notebook_stack: f_11,
      no_publish_to_public: f_12,
      no_publish_to_business_library: f_13,
      no_create_tags: f_14,
      no_update_tags: f_15,
      no_expunge_tags: f_16,
      no_set_parent_tag: f_17,
      no_create_shared_notebooks: f_18,
      update_which_shared_notebook_restrictions: f_19,
      expunge_which_shared_notebook_restrictions: f_20,
      no_share_notes_with_business: f_21,
      no_rename_notebook: f_22,
      no_set_in_my_list: f_23,
      no_change_contact: f_24,
      can_move_to_container_restrictions: f_26,
      no_set_reminder_notify_email: f_27,
      no_set_reminder_notify_in_app: f_28,
      no_set_recipient_settings_stack: f_29,
      no_can_move_note: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotebookRestrictions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.no_read_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("noReadNotes", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_create_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("noCreateNotes", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_update_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("noUpdateNotes", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_expunge_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("noExpungeNotes", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_share_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("noShareNotes", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_email_notes {
      o_prot.write_field_begin(&TFieldIdentifier::new("noEmailNotes", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_send_message_to_recipients {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSendMessageToRecipients", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_update_notebook {
      o_prot.write_field_begin(&TFieldIdentifier::new("noUpdateNotebook", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_expunge_notebook {
      o_prot.write_field_begin(&TFieldIdentifier::new("noExpungeNotebook", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_default_notebook {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetDefaultNotebook", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_notebook_stack {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetNotebookStack", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_publish_to_public {
      o_prot.write_field_begin(&TFieldIdentifier::new("noPublishToPublic", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_publish_to_business_library {
      o_prot.write_field_begin(&TFieldIdentifier::new("noPublishToBusinessLibrary", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_create_tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("noCreateTags", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_update_tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("noUpdateTags", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_expunge_tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("noExpungeTags", TType::Bool, 16))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_parent_tag {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetParentTag", TType::Bool, 17))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_create_shared_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("noCreateSharedNotebooks", TType::Bool, 18))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.update_which_shared_notebook_restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateWhichSharedNotebookRestrictions", TType::I32, 19))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expunge_which_shared_notebook_restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("expungeWhichSharedNotebookRestrictions", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_share_notes_with_business {
      o_prot.write_field_begin(&TFieldIdentifier::new("noShareNotesWithBusiness", TType::Bool, 21))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_rename_notebook {
      o_prot.write_field_begin(&TFieldIdentifier::new("noRenameNotebook", TType::Bool, 22))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_in_my_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetInMyList", TType::Bool, 23))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_change_contact {
      o_prot.write_field_begin(&TFieldIdentifier::new("noChangeContact", TType::Bool, 24))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.can_move_to_container_restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("canMoveToContainerRestrictions", TType::Struct, 26))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_reminder_notify_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetReminderNotifyEmail", TType::Bool, 27))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_reminder_notify_in_app {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetReminderNotifyInApp", TType::Bool, 28))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_set_recipient_settings_stack {
      o_prot.write_field_begin(&TFieldIdentifier::new("noSetRecipientSettingsStack", TType::Bool, 29))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.no_can_move_note {
      o_prot.write_field_begin(&TFieldIdentifier::new("noCanMoveNote", TType::Bool, 30))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Notebook
//

/// A unique container for a set of notes.
/// <dl>
/// <dt>guid</dt>
///   <dd>The unique identifier of this notebook.
///   <br/>
///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///   <br/>
///   Regex:  EDAM_GUID_REGEX
///   </dd>
/// 
/// <dt>name</dt>
///   <dd>A sequence of characters representing the name of the
///   notebook.  May be changed by clients, but the account may not contain two
///   notebooks with names that are equal via a case-insensitive comparison.
///   Can't begin or end with a space.
///   <br/>
///   Length:  EDAM_NOTEBOOK_NAME_LEN_MIN - EDAM_NOTEBOOK_NAME_LEN_MAX
///   <br/>
///   Regex:  EDAM_NOTEBOOK_NAME_REGEX
///   </dd>
/// 
/// <dt>updateSequenceNum</dt>
///   <dd>A number identifying the last transaction to
///   modify the state of this object.  The USN values are sequential within an
///   account, and can be used to compare the order of modifications within the
///   service.
///   </dd>
/// 
/// <dt>defaultNotebook</dt>
///   <dd>If true, this notebook should be used for new notes
///   whenever the user has not (or cannot) specify a desired target notebook.
///   For example, if a note is submitted via SMTP email.
///   The service will maintain at most one defaultNotebook per account.
///   If a second notebook is created or updated with defaultNotebook set to
///   true, the service will automatically update the prior notebook's
///   defaultNotebook field to false.  If the default notebook is deleted
///   (i.e. "active" set to false), the "defaultNotebook" field will be
///   set to false by the service.  If the account has no default notebook
///   set, the service will use the most recent notebook as the default.
///   </dd>
/// 
/// <dt>serviceCreated</dt>
///   <dd>The time when this notebook was created on the
///   service. This will be set on the service during creation, and the service
///   will provide this value when it returns a Notebook to a client.
///   The service will ignore this value if it is sent by clients.
///   </dd>
/// 
/// <dt>serviceUpdated</dt>
///   <dd>The time when this notebook was last modified on the
///   service.  This will be set on the service during creation, and the service
///   will provide this value when it returns a Notebook to a client.
///   The service will ignore this value if it is sent by clients.
///   </dd>
/// 
/// <dt>publishing</dt>
///   <dd>If the Notebook has been opened for public access, then this will point to the set of
///   publishing information for the Notebook (URI, description, etc.). A Notebook cannot be
///   published without providing this information, but it will persist for later use if publishing
///   is ever disabled on the Notebook. Clients that do not wish to change the publishing behavior
///   of a Notebook should not set this value when calling NoteStore.updateNotebook().
///   Note that this structure is never populated for business notebooks, see the businessNotebook
///   field.
///   </dd>
/// 
/// <dt>published</dt>
///   <dd>If this is set to true, then the Notebook will be
///   accessible either to the public, or for business users to their business,
///   via the 'publishing' or 'businessNotebook' specifications, which must also be set. If this is
///   set to false, the Notebook will not be available to the public (or business).
///   Clients that do not wish to change the publishing behavior of a Notebook
///   should not set this value when calling NoteStore.updateNotebook().
///   </dd>
/// 
/// <dt>stack</dt>
///   <dd>If this is set, then the notebook is visually contained within a stack
///   of notebooks with this name.  All notebooks in the same account with the
///   same 'stack' field are considered to be in the same stack.
///   Notebooks with no stack set are "top level" and not contained within a
///   stack.
///   </dd>
/// 
/// <dt>sharedNotebookIds</dt>
///   <dd><i>DEPRECATED</i> - replaced by sharedNotebooks.</dd>
/// 
/// <dt>sharedNotebooks</dt>
///   <dd>The list of recipients to whom this notebook has been shared
///   (one SharedNotebook object per recipient email address). This field will
///   be unset if you do not have permission to access this data. If you are
///   accessing the notebook as the owner or via a shared notebook that is
///   modifiable, then you have access to this data and the value will be set.
///   This field is read-only. Clients may not make changes to shared notebooks
///   via this field.
///   </dd>
/// 
/// <dt>businessNotebook</dt>
///   <dd>If the notebook is part of a business account and has been shared with the entire
///   business, this will contain sharing information. The presence or absence of this field
///   is not a reliable test of whether a given notebook is in fact a business notebook - the
///   field is only used when a notebook is or has been shared with the entire business.
///   </dd>
/// 
/// <dt>contact</dt>
///   <dd>Intended for use with Business accounts, this field identifies the user who
///   has been designated as the "contact".  For notebooks created in business
///   accounts, the server will automatically set this value to the user who created
///   the notebook unless Notebook.contact.username has been set, in which that value
///   will be used.  When updating a notebook, it is common to leave Notebook.contact
///   field unset, indicating that no change to the value is being requested and that
///   the existing value, if any, should be preserved.
///   </dd>
/// 
/// <dt>recipientSettings</dt>
///   <dd>This represents the preferences/settings that a recipient has set for this
///   notebook. These are intended to be changed only by the recipient, and each
///   recipient has their own recipient settings.
///   </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Notebook {
  pub guid: Option<Guid>,
  pub name: Option<String>,
  pub update_sequence_num: Option<i32>,
  pub default_notebook: Option<bool>,
  pub service_created: Option<Timestamp>,
  pub service_updated: Option<Timestamp>,
  pub publishing: Option<Publishing>,
  pub published: Option<bool>,
  pub stack: Option<String>,
  pub shared_notebook_ids: Option<Vec<i64>>,
  pub shared_notebooks: Option<Vec<SharedNotebook>>,
  pub business_notebook: Option<BusinessNotebook>,
  pub contact: Option<User>,
  pub restrictions: Option<NotebookRestrictions>,
  pub recipient_settings: Option<NotebookRecipientSettings>,
}

impl Notebook {
  pub fn new<F1, F2, F5, F6, F7, F8, F10, F11, F12, F13, F14, F15, F16, F17, F18>(guid: F1, name: F2, update_sequence_num: F5, default_notebook: F6, service_created: F7, service_updated: F8, publishing: F10, published: F11, stack: F12, shared_notebook_ids: F13, shared_notebooks: F14, business_notebook: F15, contact: F16, restrictions: F17, recipient_settings: F18) -> Notebook where F1: Into<Option<Guid>>, F2: Into<Option<String>>, F5: Into<Option<i32>>, F6: Into<Option<bool>>, F7: Into<Option<Timestamp>>, F8: Into<Option<Timestamp>>, F10: Into<Option<Publishing>>, F11: Into<Option<bool>>, F12: Into<Option<String>>, F13: Into<Option<Vec<i64>>>, F14: Into<Option<Vec<SharedNotebook>>>, F15: Into<Option<BusinessNotebook>>, F16: Into<Option<User>>, F17: Into<Option<NotebookRestrictions>>, F18: Into<Option<NotebookRecipientSettings>> {
    Notebook {
      guid: guid.into(),
      name: name.into(),
      update_sequence_num: update_sequence_num.into(),
      default_notebook: default_notebook.into(),
      service_created: service_created.into(),
      service_updated: service_updated.into(),
      publishing: publishing.into(),
      published: published.into(),
      stack: stack.into(),
      shared_notebook_ids: shared_notebook_ids.into(),
      shared_notebooks: shared_notebooks.into(),
      business_notebook: business_notebook.into(),
      contact: contact.into(),
      restrictions: restrictions.into(),
      recipient_settings: recipient_settings.into(),
    }
  }
}

impl TSerializable for Notebook {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Notebook> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Guid> = None;
    let mut f_2: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<Timestamp> = None;
    let mut f_8: Option<Timestamp> = None;
    let mut f_10: Option<Publishing> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<String> = None;
    let mut f_13: Option<Vec<i64>> = None;
    let mut f_14: Option<Vec<SharedNotebook>> = None;
    let mut f_15: Option<BusinessNotebook> = None;
    let mut f_16: Option<User> = None;
    let mut f_17: Option<NotebookRestrictions> = None;
    let mut f_18: Option<NotebookRecipientSettings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        10 => {
          let val = Publishing::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = i_prot.read_i64()?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_13 = Some(val);
        },
        14 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SharedNotebook> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = SharedNotebook::read_from_in_protocol(i_prot)?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_14 = Some(val);
        },
        15 => {
          let val = BusinessNotebook::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        16 => {
          let val = User::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = NotebookRestrictions::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let val = NotebookRecipientSettings::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Notebook {
      guid: f_1,
      name: f_2,
      update_sequence_num: f_5,
      default_notebook: f_6,
      service_created: f_7,
      service_updated: f_8,
      publishing: f_10,
      published: f_11,
      stack: f_12,
      shared_notebook_ids: f_13,
      shared_notebooks: f_14,
      business_notebook: f_15,
      contact: f_16,
      restrictions: f_17,
      recipient_settings: f_18,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Notebook");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.default_notebook {
      o_prot.write_field_begin(&TFieldIdentifier::new("defaultNotebook", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_created {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceCreated", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.service_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceUpdated", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.publishing {
      o_prot.write_field_begin(&TFieldIdentifier::new("publishing", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.published {
      o_prot.write_field_begin(&TFieldIdentifier::new("published", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.stack {
      o_prot.write_field_begin(&TFieldIdentifier::new("stack", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shared_notebook_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharedNotebookIds", TType::List, 13))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shared_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharedNotebooks", TType::List, 14))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.business_notebook {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessNotebook", TType::Struct, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.contact {
      o_prot.write_field_begin(&TFieldIdentifier::new("contact", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.restrictions {
      o_prot.write_field_begin(&TFieldIdentifier::new("restrictions", TType::Struct, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.recipient_settings {
      o_prot.write_field_begin(&TFieldIdentifier::new("recipientSettings", TType::Struct, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LinkedNotebook
//

/// A link in a user's account that refers them to a public or
/// individual shared notebook in another user's account.
/// 
/// <dl>
/// <dt>shareName</dt>
/// <dd>The display name of the shared notebook. The link owner can change this.</dd>
/// 
/// <dt>username</dt>
/// <dd>The username of the user who owns the shared or public notebook.</dd>
/// 
/// <dt>shardId</dt>
/// <dd>The shard ID of the notebook if the notebook is not public.</dt>
/// 
/// <dt>uri</dt>
/// <dd>The identifier of the public notebook.</dd>
/// 
/// <dt>guid</dt>
///   <dd>The unique identifier of this linked notebook.  Will be set whenever
///   a linked notebook is retrieved from the service, but may be null when a client
///   is creating a linked notebook.
///   <br/>
///   Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
///   <br/>
///   Regex:  EDAM_GUID_REGEX
///   </dd>
/// 
/// <dt>updateSequenceNum</dt>
///   <dd>A number identifying the last transaction to
///   modify the state of this object.  The USN values are sequential within an
///   account, and can be used to compare the order of modifications within the
///   service.
///   </dd>
/// 
/// <dt>noteStoreUrl</dt>
///   <dd>
///   This field will contain the full URL that clients should use to make
///   NoteStore requests to the server shard that contains that notebook's data.
///   I.e. this is the URL that should be used to create the Thrift HTTP client
///   transport to send messages to the NoteStore service for the account.
///   </dd>
/// 
/// <dt>webApiUrlPrefix:</dt>
///   <dd>
///   This field will contain the initial part of the URLs that should be used
///   to make requests to Evernote's thin client "web API", which provide
///   optimized operations for clients that aren't capable of manipulating
///   the full contents of accounts via the full Thrift data model. Clients
///   should concatenate the relative path for the various servlets onto the
///   end of this string to construct the full URL, as documented on our
///   developer web site.
///   </dd>
/// 
/// <dt>stack</dt>
///   <dd>If this is set, then the notebook is visually contained within a stack
///   of notebooks with this name.  All notebooks in the same account with the
///   same 'stack' field are considered to be in the same stack.
///   Notebooks with no stack set are "top level" and not contained within a
///   stack.  The link owner can change this and this field is for the benefit
///   of the link owner.
///   </dd>
/// 
/// <dt>businessId</dt>
///   <dd>If set, this will be the unique identifier for the business that owns
///   the notebook to which the linked notebook refers.</dd>
/// 
/// <dt>sharedNotebookGlobalId</dt>
///   <dd>The globally unique identifier (globalId) of the shared notebook that
///   corresponds to the share key, or the GUID of the Notebook that the linked notebook
///   refers to. This field must be filled in with the SharedNotebook.globalId or
///   Notebook.GUID value when creating new LinkedNotebooks. This field replaces the
///   deprecated "shareKey" field.
///   </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LinkedNotebook {
  pub share_name: Option<String>,
  pub username: Option<String>,
  pub shard_id: Option<String>,
  pub shared_notebook_global_id: Option<String>,
  pub uri: Option<String>,
  pub guid: Option<Guid>,
  pub update_sequence_num: Option<i32>,
  pub note_store_url: Option<String>,
  pub web_api_url_prefix: Option<String>,
  pub stack: Option<String>,
  pub business_id: Option<i32>,
}

impl LinkedNotebook {
  pub fn new<F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(share_name: F2, username: F3, shard_id: F4, shared_notebook_global_id: F5, uri: F6, guid: F7, update_sequence_num: F8, note_store_url: F9, web_api_url_prefix: F10, stack: F11, business_id: F12) -> LinkedNotebook where F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<Guid>>, F8: Into<Option<i32>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<i32>> {
    LinkedNotebook {
      share_name: share_name.into(),
      username: username.into(),
      shard_id: shard_id.into(),
      shared_notebook_global_id: shared_notebook_global_id.into(),
      uri: uri.into(),
      guid: guid.into(),
      update_sequence_num: update_sequence_num.into(),
      note_store_url: note_store_url.into(),
      web_api_url_prefix: web_api_url_prefix.into(),
      stack: stack.into(),
      business_id: business_id.into(),
    }
  }
}

impl TSerializable for LinkedNotebook {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LinkedNotebook> {
    i_prot.read_struct_begin()?;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<Guid> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LinkedNotebook {
      share_name: f_2,
      username: f_3,
      shard_id: f_4,
      shared_notebook_global_id: f_5,
      uri: f_6,
      guid: f_7,
      update_sequence_num: f_8,
      note_store_url: f_9,
      web_api_url_prefix: f_10,
      stack: f_11,
      business_id: f_12,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LinkedNotebook");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.share_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("shareName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shard_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardId", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shared_notebook_global_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharedNotebookGlobalId", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.uri {
      o_prot.write_field_begin(&TFieldIdentifier::new("uri", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_sequence_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateSequenceNum", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.note_store_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteStoreUrl", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.web_api_url_prefix {
      o_prot.write_field_begin(&TFieldIdentifier::new("webApiUrlPrefix", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.stack {
      o_prot.write_field_begin(&TFieldIdentifier::new("stack", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.business_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessId", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotebookDescriptor
//

/// A structure that describes a notebook or a user's relationship with
/// a notebook. NotebookDescriptor is expected to remain a lighter-weight
/// structure when compared to Notebook.
/// <dl>
/// <dt>guid</dt>
///   <dd>The unique identifier of the notebook.
///   </dd>
/// 
/// <dt>notebookDisplayName</dt>
///   <dd>A sequence of characters representing the name of the
///   notebook.
///   </dd>
/// 
/// <dt>contactName</dt>
///   <dd>The User.name value of the notebook's "contact".
///   </dd>
/// 
/// <dt>hasSharedNotebook</dt>
///   <dd>Whether a SharedNotebook record exists between the calling user and this
///   notebook.
///   </dd>
/// 
/// <dt>joinedUserCount</dt>
///   <dd>The number of users who have joined this notebook.
///   </dd>
/// 
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotebookDescriptor {
  pub guid: Option<Guid>,
  pub notebook_display_name: Option<String>,
  pub contact_name: Option<String>,
  pub has_shared_notebook: Option<bool>,
  pub joined_user_count: Option<i32>,
}

impl NotebookDescriptor {
  pub fn new<F1, F2, F3, F4, F5>(guid: F1, notebook_display_name: F2, contact_name: F3, has_shared_notebook: F4, joined_user_count: F5) -> NotebookDescriptor where F1: Into<Option<Guid>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<bool>>, F5: Into<Option<i32>> {
    NotebookDescriptor {
      guid: guid.into(),
      notebook_display_name: notebook_display_name.into(),
      contact_name: contact_name.into(),
      has_shared_notebook: has_shared_notebook.into(),
      joined_user_count: joined_user_count.into(),
    }
  }
}

impl TSerializable for NotebookDescriptor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotebookDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Guid> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NotebookDescriptor {
      guid: f_1,
      notebook_display_name: f_2,
      contact_name: f_3,
      has_shared_notebook: f_4,
      joined_user_count: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotebookDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.guid {
      o_prot.write_field_begin(&TFieldIdentifier::new("guid", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.notebook_display_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("notebookDisplayName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.contact_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("contactName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.has_shared_notebook {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasSharedNotebook", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.joined_user_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("joinedUserCount", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserProfile
//

/// This structure represents profile information for a user in a business.
/// 
/// <dl>
/// <dt>id</dt>
/// <dd>The numeric identifier that uniquely identifies a user.</dd>
/// 
/// <dt>name</dt>
/// <dd>The full name of the user.</dd>
/// 
/// <dt>email</dt>
/// <dd>The user's business email address. If the user has not registered their business
///   email address, this field will be empty.
/// </dd>
/// 
/// <dt>username</dt>
/// <dd>The user's Evernote username.</dd>
/// 
/// <dt>attributes</dt>
/// <dd>The user's business specific attributes.</dd>
/// 
/// <dt>joined</dt>
/// <dd>The time when the user joined the business</dd>
/// 
/// <dt>photoLastUpdated</dt>
/// <dd>The time when the user's profile photo was most recently updated</dd>
/// 
/// <dt>photoUrl</dt>
/// <dd>A URL identifying a copy of the user's current profile photo</dd>
/// 
/// <dt>role</dt>
/// <dd>The BusinessUserRole for the user</dd>
/// 
/// <dt>status</dt>
/// <dd>The BusinessUserStatus for the user</dd>
/// 
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserProfile {
  pub id: Option<UserID>,
  pub name: Option<String>,
  pub email: Option<String>,
  pub username: Option<String>,
  pub attributes: Option<BusinessUserAttributes>,
  pub joined: Option<Timestamp>,
  pub photo_last_updated: Option<Timestamp>,
  pub photo_url: Option<String>,
  pub role: Option<BusinessUserRole>,
  pub status: Option<BusinessUserStatus>,
}

impl UserProfile {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(id: F1, name: F2, email: F3, username: F4, attributes: F5, joined: F6, photo_last_updated: F7, photo_url: F8, role: F9, status: F10) -> UserProfile where F1: Into<Option<UserID>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<BusinessUserAttributes>>, F6: Into<Option<Timestamp>>, F7: Into<Option<Timestamp>>, F8: Into<Option<String>>, F9: Into<Option<BusinessUserRole>>, F10: Into<Option<BusinessUserStatus>> {
    UserProfile {
      id: id.into(),
      name: name.into(),
      email: email.into(),
      username: username.into(),
      attributes: attributes.into(),
      joined: joined.into(),
      photo_last_updated: photo_last_updated.into(),
      photo_url: photo_url.into(),
      role: role.into(),
      status: status.into(),
    }
  }
}

impl TSerializable for UserProfile {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserProfile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UserID> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<BusinessUserAttributes> = None;
    let mut f_6: Option<Timestamp> = None;
    let mut f_7: Option<Timestamp> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<BusinessUserRole> = None;
    let mut f_10: Option<BusinessUserStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = BusinessUserAttributes::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = BusinessUserRole::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = BusinessUserStatus::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserProfile {
      id: f_1,
      name: f_2,
      email: f_3,
      username: f_4,
      attributes: f_5,
      joined: f_6,
      photo_last_updated: f_7,
      photo_url: f_8,
      role: f_9,
      status: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserProfile");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.joined {
      o_prot.write_field_begin(&TFieldIdentifier::new("joined", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.photo_last_updated {
      o_prot.write_field_begin(&TFieldIdentifier::new("photoLastUpdated", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.photo_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("photoUrl", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.role {
      o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RelatedContentImage
//

/// An external image that can be shown with a related content snippet,
/// usually either a JPEG or PNG image. It is up to the client which image(s) are shown,
/// depending on available screen real estate, resolution and aspect ratio.
/// 
/// <dl>
///  <dt>url</dt>
///    <dd>The external URL of the image</dd>
///  <dt>width</dt>
///    <dd>The width of the image, in pixels.</dd>
///  <dt>height</dt>
///    <dd>The height of the image, in pixels.</dd>
///  <dt>pixelRatio</dt>
///    <dd>the pixel ratio (usually either 1.0, 1.5 or 2.0)</dd>
///  <dt>fileSize</dt>
///    <dd>the size of the image file, in bytes</dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RelatedContentImage {
  pub url: Option<String>,
  pub width: Option<i32>,
  pub height: Option<i32>,
  pub pixel_ratio: Option<OrderedFloat<f64>>,
  pub file_size: Option<i32>,
}

impl RelatedContentImage {
  pub fn new<F1, F2, F3, F4, F5>(url: F1, width: F2, height: F3, pixel_ratio: F4, file_size: F5) -> RelatedContentImage where F1: Into<Option<String>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<OrderedFloat<f64>>>, F5: Into<Option<i32>> {
    RelatedContentImage {
      url: url.into(),
      width: width.into(),
      height: height.into(),
      pixel_ratio: pixel_ratio.into(),
      file_size: file_size.into(),
    }
  }
}

impl TSerializable for RelatedContentImage {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RelatedContentImage> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<OrderedFloat<f64>> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RelatedContentImage {
      url: f_1,
      width: f_2,
      height: f_3,
      pixel_ratio: f_4,
      file_size: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RelatedContentImage");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.url {
      o_prot.write_field_begin(&TFieldIdentifier::new("url", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.width {
      o_prot.write_field_begin(&TFieldIdentifier::new("width", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.height {
      o_prot.write_field_begin(&TFieldIdentifier::new("height", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pixel_ratio {
      o_prot.write_field_begin(&TFieldIdentifier::new("pixelRatio", TType::Double, 4))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.file_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fileSize", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RelatedContent
//

/// A structure identifying one snippet of related content (some information that is not
/// part of an Evernote account but might still be relevant to the user).
/// 
/// <dl>
/// 
/// <dt>contentId</dt>
/// <dd>An identifier that uniquely identifies the content.</dd>
/// 
/// <dt>title</dt>
/// <dd>The main title to show.</dd>
/// 
/// <dt>url</dt>
/// <dd>The URL the client can use to retrieve the content.</dd>
/// 
/// <dt>sourceId</dt>
/// <dd>An identifier that uniquely identifies the source.</dd>
/// 
/// <dt>sourceUrl</dt>
/// <dd>A URL the client can access to know more about the source.</dd>
/// 
/// <dt>sourceFaviconUrl</dt>
/// <dd>The favicon URL of the source which the content belongs to.</dd>
/// </dl>
/// 
/// <dt>sourceName</dt>
/// <dd>A human-readable name of the source that provided this content.</dd>
/// 
/// <dt>date</dt>
/// <dd>A timestamp telling the user about the recency of the content.</dd>
/// 
/// <dt>teaser</dt>
/// <dd>A teaser text to show to the user; usually the first few sentences of the content,
///     excluding the title.</dd>
/// 
/// <dt>thumbnails</dt>
/// <dd>A list of thumbnails the client can show in the snippet.</dd>
/// 
/// <dt>contentType</dt>
/// <dd>The type of this related content.</dd>
/// 
/// <dt>accessType</dt>
/// <dd>An indication of how this content can be accessed. This type influences the
///     semantics of the <code>url</code> parameter.</dd>
/// 
/// <dt>visibleUrl</dt>
/// <dd>If set, the client should show this URL to the user, instead of the URL that was
///     used to retrieve the content. This URL should be used when opening the content
///     in an external browser window, or when sharing with another person.</dd>
/// 
/// <dt>clipUrl</dt>
/// <dd>If set, the client should use this URL for clipping purposes, instead of the URL
///     that was used to retrieve the content. The clipUrl may directly point to an .enex
///     file, for example.</dd>
/// 
/// <dt>contact</dt>
/// <dd>If set, the client may use this Contact for messaging purposes. This will typically
///     only be set for user profiles.</dd>
/// 
/// <dt>authors</dt>
/// <dd>For News articles only. A list of names of the article authors, if available.</dd>
/// 
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RelatedContent {
  pub content_id: Option<String>,
  pub title: Option<String>,
  pub url: Option<String>,
  pub source_id: Option<String>,
  pub source_url: Option<String>,
  pub source_favicon_url: Option<String>,
  pub source_name: Option<String>,
  pub date: Option<Timestamp>,
  pub teaser: Option<String>,
  pub thumbnails: Option<Vec<RelatedContentImage>>,
  pub content_type: Option<RelatedContentType>,
  pub access_type: Option<RelatedContentAccess>,
  pub visible_url: Option<String>,
  pub clip_url: Option<String>,
  pub contact: Option<Contact>,
  pub authors: Option<Vec<String>>,
}

impl RelatedContent {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16>(content_id: F1, title: F2, url: F3, source_id: F4, source_url: F5, source_favicon_url: F6, source_name: F7, date: F8, teaser: F9, thumbnails: F10, content_type: F11, access_type: F12, visible_url: F13, clip_url: F14, contact: F15, authors: F16) -> RelatedContent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<Timestamp>>, F9: Into<Option<String>>, F10: Into<Option<Vec<RelatedContentImage>>>, F11: Into<Option<RelatedContentType>>, F12: Into<Option<RelatedContentAccess>>, F13: Into<Option<String>>, F14: Into<Option<String>>, F15: Into<Option<Contact>>, F16: Into<Option<Vec<String>>> {
    RelatedContent {
      content_id: content_id.into(),
      title: title.into(),
      url: url.into(),
      source_id: source_id.into(),
      source_url: source_url.into(),
      source_favicon_url: source_favicon_url.into(),
      source_name: source_name.into(),
      date: date.into(),
      teaser: teaser.into(),
      thumbnails: thumbnails.into(),
      content_type: content_type.into(),
      access_type: access_type.into(),
      visible_url: visible_url.into(),
      clip_url: clip_url.into(),
      contact: contact.into(),
      authors: authors.into(),
    }
  }
}

impl TSerializable for RelatedContent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RelatedContent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<Timestamp> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<Vec<RelatedContentImage>> = None;
    let mut f_11: Option<RelatedContentType> = None;
    let mut f_12: Option<RelatedContentAccess> = None;
    let mut f_13: Option<String> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<Contact> = None;
    let mut f_16: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<RelatedContentImage> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = RelatedContentImage::read_from_in_protocol(i_prot)?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let val = RelatedContentType::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = RelatedContentAccess::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = Contact::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        16 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = i_prot.read_string()?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RelatedContent {
      content_id: f_1,
      title: f_2,
      url: f_3,
      source_id: f_4,
      source_url: f_5,
      source_favicon_url: f_6,
      source_name: f_7,
      date: f_8,
      teaser: f_9,
      thumbnails: f_10,
      content_type: f_11,
      access_type: f_12,
      visible_url: f_13,
      clip_url: f_14,
      contact: f_15,
      authors: f_16,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RelatedContent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.content_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.url {
      o_prot.write_field_begin(&TFieldIdentifier::new("url", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sourceId", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("sourceUrl", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source_favicon_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("sourceFaviconUrl", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.source_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("sourceName", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.date {
      o_prot.write_field_begin(&TFieldIdentifier::new("date", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.teaser {
      o_prot.write_field_begin(&TFieldIdentifier::new("teaser", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.thumbnails {
      o_prot.write_field_begin(&TFieldIdentifier::new("thumbnails", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.content_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("contentType", TType::I32, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessType", TType::I32, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.visible_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("visibleUrl", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.clip_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("clipUrl", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.contact {
      o_prot.write_field_begin(&TFieldIdentifier::new("contact", TType::Struct, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.authors {
      o_prot.write_field_begin(&TFieldIdentifier::new("authors", TType::List, 16))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BusinessInvitation
//

/// A structure describing an invitation to join a business account.
/// 
/// <dl>
///   <dt>businessId</dt>
///     <dd>
///       The ID of the business to which the invitation grants access.
///     </dd>
/// 
///   <dt>email</dt>
///     <dd>
///       The email address that was invited to join the business.
///     </dd>
/// 
///   <dt>role</dt>
///     <dd>
///       The role to grant the user after the invitation is accepted.
///     </dd>
/// 
///   <dt>status</dt>
///     <dd>
///       The status of the invitation.
///     </dd>
/// 
///   <dt>requesterId</dt>
///     <dd>
///       For invitations that were initially requested by a non-admin member of the business,
///       this field specifies the user ID of the requestor. For all other invitations, this field
///       will be unset.
///     </dd>
///   <dt>fromWorkChat</dt>
///     <dd>
///       If this invitation was created implicitly via a WorkChat, this field
///       will be true.
///     </dd>
///   <dt>created</dt>
///     <dd>
///       The timestamp at which this invitation was created.
///     </dd>
///   <dt>mostRecentReminder</dt>
///     <dd>
///       The timestamp at which the most recent reminder was sent.
///     </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BusinessInvitation {
  pub business_id: Option<i32>,
  pub email: Option<String>,
  pub role: Option<BusinessUserRole>,
  pub status: Option<BusinessInvitationStatus>,
  pub requester_id: Option<UserID>,
  pub from_work_chat: Option<bool>,
  pub created: Option<Timestamp>,
  pub most_recent_reminder: Option<Timestamp>,
}

impl BusinessInvitation {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(business_id: F1, email: F2, role: F3, status: F4, requester_id: F5, from_work_chat: F6, created: F7, most_recent_reminder: F8) -> BusinessInvitation where F1: Into<Option<i32>>, F2: Into<Option<String>>, F3: Into<Option<BusinessUserRole>>, F4: Into<Option<BusinessInvitationStatus>>, F5: Into<Option<UserID>>, F6: Into<Option<bool>>, F7: Into<Option<Timestamp>>, F8: Into<Option<Timestamp>> {
    BusinessInvitation {
      business_id: business_id.into(),
      email: email.into(),
      role: role.into(),
      status: status.into(),
      requester_id: requester_id.into(),
      from_work_chat: from_work_chat.into(),
      created: created.into(),
      most_recent_reminder: most_recent_reminder.into(),
    }
  }
}

impl TSerializable for BusinessInvitation {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BusinessInvitation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BusinessUserRole> = None;
    let mut f_4: Option<BusinessInvitationStatus> = None;
    let mut f_5: Option<UserID> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<Timestamp> = None;
    let mut f_8: Option<Timestamp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = BusinessUserRole::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = BusinessInvitationStatus::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BusinessInvitation {
      business_id: f_1,
      email: f_2,
      role: f_3,
      status: f_4,
      requester_id: f_5,
      from_work_chat: f_6,
      created: f_7,
      most_recent_reminder: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BusinessInvitation");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.business_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("businessId", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.email {
      o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.role {
      o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.requester_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requesterId", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.from_work_chat {
      o_prot.write_field_begin(&TFieldIdentifier::new("fromWorkChat", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created {
      o_prot.write_field_begin(&TFieldIdentifier::new("created", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.most_recent_reminder {
      o_prot.write_field_begin(&TFieldIdentifier::new("mostRecentReminder", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserIdentity
//

/// A structure that holds user identifying information such as an
/// email address, Evernote user ID, or an identifier from a 3rd party
/// service.  An instance consists of a type and a value, where the
/// value will be stored in one of the value fields depending upon the
/// data type required for the identity type.
/// 
/// When used with shared notebook invitations, a UserIdentity
/// identifies a particular person who may not (yet) have an Evernote
/// UserID UserIdentity but who has (almost) unique access to the
/// service endpoint described by the UserIdentity.  For example, an
/// e-mail UserIdentity can identify the person who receives e-mail at
/// the given address, and who can therefore read the share key that
/// has a cryptographic signature from the Evernote service. With the
/// share key, this person can supply their Evernote UserID via an
/// authentication token to join the notebook
/// (authenticateToSharedNotebook), at which time we have associated
/// the e-mail UserIdentity with an Evernote UserID UserIdentity. Note
/// that using shared notebook records, the relationship between
/// Evernote UserIDs and e-mail addresses is many to many.
/// 
/// Note that the identifier may not directly identify a
/// particular Evernote UserID UserIdentity without further
/// verification.  For example, an e-mail UserIdentity may be
/// associated with an invitation to join a notebook (via a shared
/// notebook record), but until a user uses a share key, that was sent
/// to that e-mail address, to join the notebook, we do not know an
/// Evernote UserID UserIdentity ID to match the e-mail address.
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserIdentity {
  pub type_: Option<UserIdentityType>,
  pub string_identifier: Option<String>,
  pub long_identifier: Option<i64>,
}

impl UserIdentity {
  pub fn new<F1, F2, F3>(type_: F1, string_identifier: F2, long_identifier: F3) -> UserIdentity where F1: Into<Option<UserIdentityType>>, F2: Into<Option<String>>, F3: Into<Option<i64>> {
    UserIdentity {
      type_: type_.into(),
      string_identifier: string_identifier.into(),
      long_identifier: long_identifier.into(),
    }
  }
}

impl TSerializable for UserIdentity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserIdentity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UserIdentityType> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = UserIdentityType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserIdentity {
      type_: f_1,
      string_identifier: f_2,
      long_identifier: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserIdentity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.string_identifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("stringIdentifier", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.long_identifier {
      o_prot.write_field_begin(&TFieldIdentifier::new("longIdentifier", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub const CLASSIFICATION_RECIPE_USER_NON_RECIPE: &str = "000";

pub const CLASSIFICATION_RECIPE_USER_RECIPE: &str = "001";

pub const CLASSIFICATION_RECIPE_SERVICE_RECIPE: &str = "002";

pub const EDAM_NOTE_SOURCE_WEB_CLIP: &str = "web.clip";

pub const EDAM_NOTE_SOURCE_WEB_CLIP_SIMPLIFIED: &str = "Clearly";

pub const EDAM_NOTE_SOURCE_MAIL_CLIP: &str = "mail.clip";

pub const EDAM_NOTE_SOURCE_MAIL_SMTP_GATEWAY: &str = "mail.smtp";

