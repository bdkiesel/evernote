// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::errors;
use crate::types;

//
// PublicUserInfo
//

///  This structure is used to provide publicly-available user information
///  about a particular account.
/// <dl>
///  <dt>userId:</dt>
///    <dd>
///    The unique numeric user identifier for the user account.
///    </dd>
///  <dt>serviceLevel:</dt>
///    <dd>
///    The service level of the account.
///    </dd>
///  <dt>noteStoreUrl:</dt>
///    <dd>
///    This field will contain the full URL that clients should use to make
///    NoteStore requests to the server shard that contains that user's data.
///    I.e. this is the URL that should be used to create the Thrift HTTP client
///    transport to send messages to the NoteStore service for the account.
///    </dd>
///  <dt>webApiUrlPrefix:</dt>
///    <dd>
///    This field will contain the initial part of the URLs that should be used
///    to make requests to Evernote's thin client "web API", which provide
///    optimized operations for clients that aren't capable of manipulating
///    the full contents of accounts via the full Thrift data model. Clients
///    should concatenate the relative path for the various servlets onto the
///    end of this string to construct the full URL, as documented on our
///    developer web site.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PublicUserInfo {
  pub user_id: types::UserID,
  pub username: Option<String>,
  pub note_store_url: Option<String>,
  pub web_api_url_prefix: Option<String>,
  pub service_level: Option<types::ServiceLevel>,
}

impl PublicUserInfo {
  pub fn new<F4, F5, F6, F7>(user_id: types::UserID, username: F4, note_store_url: F5, web_api_url_prefix: F6, service_level: F7) -> PublicUserInfo where F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<types::ServiceLevel>> {
    PublicUserInfo {
      user_id,
      username: username.into(),
      note_store_url: note_store_url.into(),
      web_api_url_prefix: web_api_url_prefix.into(),
      service_level: service_level.into(),
    }
  }
}

impl TSerializable for PublicUserInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PublicUserInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::UserID> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<types::ServiceLevel> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = types::ServiceLevel::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PublicUserInfo.user_id", &f_1)?;
    let ret = PublicUserInfo {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      username: f_4,
      note_store_url: f_5,
      web_api_url_prefix: f_6,
      service_level: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PublicUserInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::I32, 1))?;
    o_prot.write_i32(self.user_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.note_store_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteStoreUrl", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.web_api_url_prefix {
      o_prot.write_field_begin(&TFieldIdentifier::new("webApiUrlPrefix", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceLevel", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserUrls
//

/// <dl>
/// <dt>noteStoreUrl:</dt>
///   <dd>
///   This field will contain the full URL that clients should use to make
///   NoteStore requests to the server shard that contains that user's data.
///   I.e. this is the URL that should be used to create the Thrift HTTP client
///   transport to send messages to the NoteStore service for the account.
///   </dd>
/// <dt>webApiUrlPrefix:</dt>
///   <dd>
///   This field will contain the initial part of the URLs that should be used
///   to make requests to Evernote's thin client "web API", which provide
///   optimized operations for clients that aren't capable of manipulating
///   the full contents of accounts via the full Thrift data model. Clients
///   should concatenate the relative path for the various servlets onto the
///   end of this string to construct the full URL, as documented on our
///   developer web site.
///   </dd>
/// <dt>userStoreUrl:</dt>
///   <dd>
///   This field will contain the full URL that clients should use to make UserStore
///   requests after successfully authenticating. I.e. this is the URL that should be used
///   to create the Thrift HTTP client transport to send messages to the UserStore service
///   for this account.
///   </dd>
/// <dt>utilityUrl:</dt>
///   <dd>
///   This field will contain the full URL that clients should use to make Utility requests
///   to the server shard that contains that user's data. I.e. this is the URL that should
///   be used to create the Thrift HTTP client transport to send messages to the Utility
///   service for the account.
///   </dd>
/// <dt>messageStoreUrl:</dt>
///   <dd>
///   This field will contain the full URL that clients should use to make MessageStore
///   requests to the server. I.e. this is the URL that should be used to create the
///   Thrift HTTP client transport to send messages to the MessageStore service for the
///   account.
///   </dd>
/// <dt>userWebSocketUrl:</dt>
///   <dd>
///   This field will contain the full URL that clients should use when opening a
///   persistent web socket to recieve notification of events for the authenticated user.
///   </dd>
/// </dl>
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserUrls {
  pub note_store_url: Option<String>,
  pub web_api_url_prefix: Option<String>,
  pub user_store_url: Option<String>,
  pub utility_url: Option<String>,
  pub message_store_url: Option<String>,
  pub user_web_socket_url: Option<String>,
}

impl UserUrls {
  pub fn new<F1, F2, F3, F4, F5, F6>(note_store_url: F1, web_api_url_prefix: F2, user_store_url: F3, utility_url: F4, message_store_url: F5, user_web_socket_url: F6) -> UserUrls where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>> {
    UserUrls {
      note_store_url: note_store_url.into(),
      web_api_url_prefix: web_api_url_prefix.into(),
      user_store_url: user_store_url.into(),
      utility_url: utility_url.into(),
      message_store_url: message_store_url.into(),
      user_web_socket_url: user_web_socket_url.into(),
    }
  }
}

impl TSerializable for UserUrls {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserUrls> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserUrls {
      note_store_url: f_1,
      web_api_url_prefix: f_2,
      user_store_url: f_3,
      utility_url: f_4,
      message_store_url: f_5,
      user_web_socket_url: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserUrls");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.note_store_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteStoreUrl", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.web_api_url_prefix {
      o_prot.write_field_begin(&TFieldIdentifier::new("webApiUrlPrefix", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_store_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("userStoreUrl", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.utility_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("utilityUrl", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message_store_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageStoreUrl", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_web_socket_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("userWebSocketUrl", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AuthenticationResult
//

///  When an authentication (or re-authentication) is performed, this structure
///  provides the result to the client.
/// <dl>
///  <dt>currentTime:</dt>
///    <dd>
///    The server-side date and time when this result was
///    generated.
///    </dd>
///  <dt>authenticationToken:</dt>
///    <dd>
///    Holds an opaque, ASCII-encoded token that can be
///    used by the client to perform actions on a NoteStore.
///    </dd>
///  <dt>expiration:</dt>
///    <dd>
///    Holds the server-side date and time when the
///    authentication token will expire.
///    This time can be compared to "currentTime" to produce an expiration
///    time that can be reconciled with the client's local clock.
///    </dd>
///  <dt>user:</dt>
///    <dd>
///    Holds the information about the account which was
///    authenticated if this was a full authentication.  May be absent if this
///    particular authentication did not require user information.
///    </dd>
///  <dt>publicUserInfo:</dt>
///    <dd>
///    If this authentication result was achieved without full permissions to
///    access the full User structure, this field may be set to give back
///    a more limited public set of data.
///    </dd>
///  <dt>noteStoreUrl:</dt>
///    <dd>
///    DEPRECATED - Client applications should use urls.noteStoreUrl.
///    </dd>
///  <dt>webApiUrlPrefix:</dt>
///    <dd>
///    DEPRECATED - Client applications should use urls.webApiUrlPrefix.
///    </dd>
///  <dt>secondFactorRequired:</dt>
///    <dd>
///    If set to true, this field indicates that the user has enabled two-factor
///    authentication and must enter their second factor in order to complete
///    authentication. In this case the value of authenticationResult will be
///    a short-lived authentication token that may only be used to make a
///    subsequent call to completeTwoFactorAuthentication.
///    </dd>
///  <dt>secondFactorDeliveryHint:</dt>
///    <dd>
///    When secondFactorRequired is set to true, this field may contain a string
///    describing the second factor delivery method that the user has configured.
///    This will typically be an obfuscated mobile device number, such as
///    "(xxx) xxx-x095". This string can be displayed to the user to remind them
///    how to obtain the required second factor.
///    </dd>
///  <dt>urls</dt>
///    <dd>
///    This structure will contain all of the URLs that clients need to make requests to the
///    Evernote service on behalf of the authenticated User.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AuthenticationResult {
  pub current_time: types::Timestamp,
  pub authentication_token: String,
  pub expiration: types::Timestamp,
  pub user: Option<types::User>,
  pub public_user_info: Option<PublicUserInfo>,
  pub note_store_url: Option<String>,
  pub web_api_url_prefix: Option<String>,
  pub second_factor_required: Option<bool>,
  pub second_factor_delivery_hint: Option<String>,
  pub urls: Option<UserUrls>,
}

impl AuthenticationResult {
  pub fn new<F4, F5, F6, F7, F8, F9, F10>(current_time: types::Timestamp, authentication_token: String, expiration: types::Timestamp, user: F4, public_user_info: F5, note_store_url: F6, web_api_url_prefix: F7, second_factor_required: F8, second_factor_delivery_hint: F9, urls: F10) -> AuthenticationResult where F4: Into<Option<types::User>>, F5: Into<Option<PublicUserInfo>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<bool>>, F9: Into<Option<String>>, F10: Into<Option<UserUrls>> {
    AuthenticationResult {
      current_time,
      authentication_token,
      expiration,
      user: user.into(),
      public_user_info: public_user_info.into(),
      note_store_url: note_store_url.into(),
      web_api_url_prefix: web_api_url_prefix.into(),
      second_factor_required: second_factor_required.into(),
      second_factor_delivery_hint: second_factor_delivery_hint.into(),
      urls: urls.into(),
    }
  }
}

impl TSerializable for AuthenticationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AuthenticationResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::Timestamp> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<types::Timestamp> = None;
    let mut f_4: Option<types::User> = None;
    let mut f_5: Option<PublicUserInfo> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<UserUrls> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = types::User::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = PublicUserInfo::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = UserUrls::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AuthenticationResult.current_time", &f_1)?;
    verify_required_field_exists("AuthenticationResult.authentication_token", &f_2)?;
    verify_required_field_exists("AuthenticationResult.expiration", &f_3)?;
    let ret = AuthenticationResult {
      current_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      authentication_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      expiration: f_3.expect("auto-generated code should have checked for presence of required fields"),
      user: f_4,
      public_user_info: f_5,
      note_store_url: f_6,
      web_api_url_prefix: f_7,
      second_factor_required: f_8,
      second_factor_delivery_hint: f_9,
      urls: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AuthenticationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("currentTime", TType::I64, 1))?;
    o_prot.write_i64(self.current_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 2))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expiration", TType::I64, 3))?;
    o_prot.write_i64(self.expiration)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.public_user_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("publicUserInfo", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.note_store_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("noteStoreUrl", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.web_api_url_prefix {
      o_prot.write_field_begin(&TFieldIdentifier::new("webApiUrlPrefix", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.second_factor_required {
      o_prot.write_field_begin(&TFieldIdentifier::new("secondFactorRequired", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.second_factor_delivery_hint {
      o_prot.write_field_begin(&TFieldIdentifier::new("secondFactorDeliveryHint", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.urls {
      o_prot.write_field_begin(&TFieldIdentifier::new("urls", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BootstrapSettings
//

///  This structure describes a collection of bootstrap settings.
/// <dl>
///  <dt>serviceHost:</dt>
///    <dd>
///    The hostname and optional port for composing Evernote web service URLs.
///    This URL can be used to access the UserStore and related services,
///    but must not be used to compose the NoteStore URL. Client applications
///    must handle serviceHost values that include only the hostname
///    (e.g. www.evernote.com) or both the hostname and port (e.g. www.evernote.com:8080).
///    If no port is specified, or if port 443 is specified, client applications must
///    use the scheme "https" when composing URLs. Otherwise, a client must use the
///    scheme "http".
///  </dd>
///  <dt>marketingUrl:</dt>
///    <dd>
///    The URL stem for the Evernote corporate marketing website, e.g. http://www.evernote.com.
///    This stem can be used to compose website URLs. For example, the URL of the Evernote
///    Trunk is composed by appending "/about/trunk/" to the value of marketingUrl.
///    </dd>
///  <dt>supportUrl:</dt>
///    <dd>
///    The full URL for the Evernote customer support website, e.g. https://support.evernote.com.
///    </dd>
///  <dt>accountEmailDomain:</dt>
///    <dd>
///    The domain used for an Evernote user's incoming email address, which allows notes to
///    be emailed into an account. E.g. m.evernote.com.
///    </dd>
///  <dt>enableFacebookSharing:</dt>
///    <dd>
///    Whether the client application should enable sharing of notes on Facebook.
///    </dd>
///  <dt>enableGiftSubscriptions:</dt>
///    <dd>
///    Whether the client application should enable gift subscriptions.
///    </dd>
///  <dt>enableSupportTickets:</dt>
///    <dd>
///    Whether the client application should enable in-client creation of support tickets.
///    </dd>
///  <dt>enableSharedNotebooks:</dt>
///    <dd>
///    Whether the client application should enable shared notebooks.
///    </dd>
///  <dt>enableSingleNoteSharing:</dt>
///    <dd>
///    Whether the client application should enable single note sharing.
///    </dd>
///  <dt>enableSponsoredAccounts:</dt>
///    <dd>
///    Whether the client application should enable sponsored accounts.
///    </dd>
///  <dt>enableTwitterSharing:</dt>
///    <dd>
///    Whether the client application should enable sharing of notes on Twitter.
///    </dd>
///  <dt>enableGoogle:</dt>
///    <dd>
///    Whether the client application should enable authentication with Google,
///    for example to allow integration with a user's Gmail contacts.
///  </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BootstrapSettings {
  pub service_host: String,
  pub marketing_url: String,
  pub support_url: String,
  pub account_email_domain: String,
  pub enable_facebook_sharing: Option<bool>,
  pub enable_gift_subscriptions: Option<bool>,
  pub enable_support_tickets: Option<bool>,
  pub enable_shared_notebooks: Option<bool>,
  pub enable_single_note_sharing: Option<bool>,
  pub enable_sponsored_accounts: Option<bool>,
  pub enable_twitter_sharing: Option<bool>,
  pub enable_linked_in_sharing: Option<bool>,
  pub enable_public_notebooks: Option<bool>,
  pub enable_google: Option<bool>,
}

impl BootstrapSettings {
  pub fn new<F5, F6, F7, F8, F9, F10, F11, F12, F13, F16>(service_host: String, marketing_url: String, support_url: String, account_email_domain: String, enable_facebook_sharing: F5, enable_gift_subscriptions: F6, enable_support_tickets: F7, enable_shared_notebooks: F8, enable_single_note_sharing: F9, enable_sponsored_accounts: F10, enable_twitter_sharing: F11, enable_linked_in_sharing: F12, enable_public_notebooks: F13, enable_google: F16) -> BootstrapSettings where F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<bool>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F16: Into<Option<bool>> {
    BootstrapSettings {
      service_host,
      marketing_url,
      support_url,
      account_email_domain,
      enable_facebook_sharing: enable_facebook_sharing.into(),
      enable_gift_subscriptions: enable_gift_subscriptions.into(),
      enable_support_tickets: enable_support_tickets.into(),
      enable_shared_notebooks: enable_shared_notebooks.into(),
      enable_single_note_sharing: enable_single_note_sharing.into(),
      enable_sponsored_accounts: enable_sponsored_accounts.into(),
      enable_twitter_sharing: enable_twitter_sharing.into(),
      enable_linked_in_sharing: enable_linked_in_sharing.into(),
      enable_public_notebooks: enable_public_notebooks.into(),
      enable_google: enable_google.into(),
    }
  }
}

impl TSerializable for BootstrapSettings {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BootstrapSettings> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = None;
    let mut f_16: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        16 => {
          let val = i_prot.read_bool()?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BootstrapSettings.service_host", &f_1)?;
    verify_required_field_exists("BootstrapSettings.marketing_url", &f_2)?;
    verify_required_field_exists("BootstrapSettings.support_url", &f_3)?;
    verify_required_field_exists("BootstrapSettings.account_email_domain", &f_4)?;
    let ret = BootstrapSettings {
      service_host: f_1.expect("auto-generated code should have checked for presence of required fields"),
      marketing_url: f_2.expect("auto-generated code should have checked for presence of required fields"),
      support_url: f_3.expect("auto-generated code should have checked for presence of required fields"),
      account_email_domain: f_4.expect("auto-generated code should have checked for presence of required fields"),
      enable_facebook_sharing: f_5,
      enable_gift_subscriptions: f_6,
      enable_support_tickets: f_7,
      enable_shared_notebooks: f_8,
      enable_single_note_sharing: f_9,
      enable_sponsored_accounts: f_10,
      enable_twitter_sharing: f_11,
      enable_linked_in_sharing: f_12,
      enable_public_notebooks: f_13,
      enable_google: f_16,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BootstrapSettings");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serviceHost", TType::String, 1))?;
    o_prot.write_string(&self.service_host)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("marketingUrl", TType::String, 2))?;
    o_prot.write_string(&self.marketing_url)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("supportUrl", TType::String, 3))?;
    o_prot.write_string(&self.support_url)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("accountEmailDomain", TType::String, 4))?;
    o_prot.write_string(&self.account_email_domain)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.enable_facebook_sharing {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableFacebookSharing", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_gift_subscriptions {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableGiftSubscriptions", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_support_tickets {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableSupportTickets", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_shared_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableSharedNotebooks", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_single_note_sharing {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableSingleNoteSharing", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_sponsored_accounts {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableSponsoredAccounts", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_twitter_sharing {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableTwitterSharing", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_linked_in_sharing {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableLinkedInSharing", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_public_notebooks {
      o_prot.write_field_begin(&TFieldIdentifier::new("enablePublicNotebooks", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_google {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableGoogle", TType::Bool, 16))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BootstrapProfile
//

///  This structure describes a collection of bootstrap settings.
/// <dl>
///  <dt>name:</dt>
///    <dd>
///    The unique name of the profile, which is guaranteed to remain consistent across
///    calls to getBootstrapInfo.
///    </dd>
///  <dt>settings:</dt>
///    <dd>
///    The settings for this profile.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BootstrapProfile {
  pub name: String,
  pub settings: BootstrapSettings,
}

impl BootstrapProfile {
  pub fn new(name: String, settings: BootstrapSettings) -> BootstrapProfile {
    BootstrapProfile {
      name,
      settings,
    }
  }
}

impl TSerializable for BootstrapProfile {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BootstrapProfile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<BootstrapSettings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = BootstrapSettings::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BootstrapProfile.name", &f_1)?;
    verify_required_field_exists("BootstrapProfile.settings", &f_2)?;
    let ret = BootstrapProfile {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      settings: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BootstrapProfile");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::Struct, 2))?;
    self.settings.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BootstrapInfo
//

///  This structure describes a collection of bootstrap profiles.
/// <dl>
///  <dt>profiles:</dt>
///    <dd>
///    List of one or more bootstrap profiles, in descending
///    preference order.
///    </dd>
///  </dl>
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BootstrapInfo {
  pub profiles: Vec<BootstrapProfile>,
}

impl BootstrapInfo {
  pub fn new(profiles: Vec<BootstrapProfile>) -> BootstrapInfo {
    BootstrapInfo {
      profiles,
    }
  }
}

impl TSerializable for BootstrapInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BootstrapInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<BootstrapProfile>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BootstrapProfile> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = BootstrapProfile::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BootstrapInfo.profiles", &f_1)?;
    let ret = BootstrapInfo {
      profiles: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BootstrapInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profiles", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.profiles.len() as i32))?;
    for e in &self.profiles {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub const EDAM_VERSION_MAJOR: i16 = 1;

pub const EDAM_VERSION_MINOR: i16 = 28;

//
// UserStore service client
//

/// Service:  UserStore
/// <p>
/// The UserStore service is primarily used by EDAM clients to establish
/// authentication via username and password over a trusted connection (e.g.
/// SSL).  A client's first call to this interface should be checkVersion() to
/// ensure that the client's software is up to date.
/// </p>
/// All calls which require an authenticationToken may throw an
/// EDAMUserException for the following reasons:
///  <ul>
///   <li> AUTH_EXPIRED "authenticationToken" - token has expired
///   <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
///   <li> DATA_REQUIRED "authenticationToken" - token is empty
///   <li> INVALID_AUTH "authenticationToken" - token signature is invalid
///   <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
///     privileges
/// </ul>
pub trait TUserStoreSyncClient {
  /// This should be the first call made by a client to the EDAM service.  It
  /// tells the service what protocol version is used by the client.  The
  /// service will then return true if the client is capable of talking to
  /// the service, and false if the client's protocol version is incompatible
  /// with the service, so the client must upgrade.  If a client receives a
  /// false value, it should report the incompatibility to the user and not
  /// continue with any more EDAM requests (UserStore or NoteStore).
  /// 
  /// @param clientName
  ///   This string provides some information about the client for
  ///   tracking/logging on the service.  It should provide information about
  ///   the client's software and platform. The structure should be:
  ///   application/version; platform/version; [ device/version ]
  ///   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
  /// 
  /// @param edamVersionMajor
  ///   This should be the major protocol version that was compiled by the
  ///   client.  This should be the current value of the EDAM_VERSION_MAJOR
  ///   constant for the client.
  /// 
  /// @param edamVersionMinor
  ///   This should be the major protocol version that was compiled by the
  ///   client.  This should be the current value of the EDAM_VERSION_MINOR
  ///   constant for the client.
  fn check_version(&mut self, client_name: String, edam_version_major: i16, edam_version_minor: i16) -> thrift::Result<bool>;
  /// This provides bootstrap information to the client. Various bootstrap
  /// profiles and settings may be used by the client to configure itself.
  /// 
  /// @param locale
  ///   The client's current locale, expressed in language[_country]
  ///   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
  ///   language and country codes.
  /// 
  /// @return
  ///   The bootstrap information suitable for this client.
  fn get_bootstrap_info(&mut self, locale: String) -> thrift::Result<BootstrapInfo>;
  /// This is used to check a username and password in order to create a
  /// long-lived authentication token that can be used for further actions.
  /// 
  /// This function is not available to most third party applications,
  /// which typically authenticate using OAuth as
  /// described at
  /// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
  /// If you believe that your application requires permission to authenticate
  /// using username and password instead of OAuth, please contact Evernote
  /// developer support by visiting
  /// <a href="http://dev.evernote.com">dev.evernote.com</a>.
  /// 
  /// @param username
  ///   The username or registered email address of the account to
  ///   authenticate against.
  /// 
  /// @param password
  ///   The plaintext password to check against the account.  Since
  ///   this is not protected by the EDAM protocol, this information must be
  ///   provided over a protected transport (i.e. SSL).
  /// 
  /// @param consumerKey
  ///   The "consumer key" portion of the API key issued to the client application
  ///   by Evernote.
  /// 
  /// @param consumerSecret
  ///   The "consumer secret" portion of the API key issued to the client application
  ///   by Evernote.
  /// 
  /// @param deviceIdentifier
  ///   An optional string that uniquely identifies the device from which the
  ///   authentication is being performed. This string allows the service to return the
  ///   same authentication token when a given application requests authentication
  ///   repeatedly from the same device. This may happen when the user logs out of an
  ///   application and then logs back in, or when the application is uninstalled
  ///   and later reinstalled. If no reliable device identifier can be created,
  ///   this value should be omitted. If set, the device identifier must be between
  ///   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
  ///   EDAM_DEVICE_ID_REGEX.
  /// 
  /// @param deviceDescription
  ///   A description of the device from which the authentication is being performed.
  ///   This field is displayed to the user in a list of authorized applications to
  ///   allow them to distinguish between multiple tokens issued to the same client
  ///   application on different devices. For example, the Evernote iOS client on
  ///   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
  ///   "Bob's iPad". The device description must be between 1 and
  ///   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
  ///   expression EDAM_DEVICE_DESCRIPTION_REGEX.
  /// 
  /// @param supportsTwoFactor
  ///   Whether the calling application supports two-factor authentication. If this
  ///   parameter is false, this method will fail with the error code INVALID_AUTH and the
  ///   parameter "password" when called for a user who has enabled two-factor
  ///   authentication.
  /// 
  /// @return
  ///   <p>The result of the authentication. The level of detail provided in the returned
  ///   AuthenticationResult.User structure depends on the access level granted by
  ///   calling application's API key.</p>
  ///   <p>If the user has two-factor authentication enabled,
  ///   AuthenticationResult.secondFactorRequired will be set and
  ///   AuthenticationResult.authenticationToken will contain a short-lived token
  ///   that may only be used to complete the two-factor authentication process by calling
  ///   UserStore.completeTwoFactorAuthentication.</p>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "username" - username is empty
  ///   <li> DATA_REQUIRED "password" - password is empty
  ///   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
  ///   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
  ///   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
  ///   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
  ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
  ///   <li> INVALID_AUTH "username" - username not found
  ///   <li> INVALID_AUTH "password" - password did not match
  ///   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
  ///   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
  ///   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
  ///   <li> PERMISSION_DENIED "User.active" - user account is closed
  ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
  ///     failed authentication too often
  ///   <li> AUTH_EXPIRED "password" - user password is expired
  /// </ul>
  fn authenticate_long_session(&mut self, username: String, password: String, consumer_key: String, consumer_secret: String, device_identifier: String, device_description: String, supports_two_factor: bool) -> thrift::Result<AuthenticationResult>;
  /// Complete the authentication process when a second factor is required. This
  /// call is made after a successful call to authenticate or authenticateLongSession
  /// when the authenticating user has enabled two-factor authentication.
  /// 
  /// @param authenticationToken An authentication token returned by a previous
  ///   call to UserStore.authenticate or UserStore.authenticateLongSession that
  ///   could not be completed in a single call because a second factor was required.
  /// 
  /// @param oneTimeCode The one time code entered by the user. This value is delivered
  ///   out-of-band, typically via SMS or an authenticator application.
  /// 
  /// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
  /// 
  /// @param deviceDescription See the corresponding parameter in authenticateLongSession.
  /// 
  /// @return
  ///   The result of the authentication. The level of detail provided in the returned
  ///   AuthenticationResult.User structure depends on the access level granted by the
  ///   calling application's API key. If the initial authentication call was made to
  ///   authenticateLongSession, the AuthenticationResult will contain a long-lived
  ///   authentication token.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
  ///   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
  ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
  ///   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
  ///   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
  ///   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
  ///   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
  ///   <li> PERMISSION_DENIED "User.active" - user account is closed
  ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
  ///     failed authentication too often
  ///   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
  ///      two-factor authentication.</li>
  /// </ul>
  fn complete_two_factor_authentication(&mut self, authentication_token: String, one_time_code: String, device_identifier: String, device_description: String) -> thrift::Result<AuthenticationResult>;
  /// Revoke an existing long lived authentication token. This can be used to
  /// revoke OAuth tokens or tokens created by calling authenticateLongSession,
  /// and allows a user to effectively log out of Evernote from the perspective
  /// of the application that holds the token. The authentication token that is
  /// passed is immediately revoked and may not be used to call any authenticated
  /// EDAM function.
  /// 
  /// @param authenticationToken the authentication token to revoke.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
  ///   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
  ///   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
  ///   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
  ///     is already revoked.
  /// </ul>
  fn revoke_long_session(&mut self, authentication_token: String) -> thrift::Result<()>;
  /// This is used to take an existing authentication token that grants access
  /// to an individual user account (returned from 'authenticate',
  /// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
  /// authentication token that may be used to access business notebooks if the user
  /// is a member of an Evernote Business account.
  /// 
  /// The resulting authentication token may be used to make NoteStore API calls
  /// against the business using the NoteStore URL returned in the result.
  /// 
  /// @param authenticationToken
  ///   The authentication token for the user. This may not be a shared authentication
  ///   token (returned by NoteStore.authenticateToSharedNotebook or
  ///   NoteStore.authenticateToSharedNote) or a business authentication token.
  /// 
  /// @return
  ///   The result of the authentication, with the token granting access to the
  ///   business in the result's 'authenticationToken' field. The URL that must
  ///   be used to access the business account NoteStore will be returned in the
  ///   result's 'noteStoreUrl' field.  The 'User' field will
  ///   not be set in the result.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
  ///        is a shared or business authentication token. </li>
  ///   <li> PERMISSION_DENIED "Business" - the user identified by the provided
  ///        authentication token is not currently a member of a business. </li>
  ///   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
  ///        member of is not currently in an active status. </li>
  ///   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
  ///        sign-on before authenticating to the business.
  /// </ul>
  fn authenticate_to_business(&mut self, authentication_token: String) -> thrift::Result<AuthenticationResult>;
  /// Returns the User corresponding to the provided authentication token,
  /// or throws an exception if this token is not valid.
  /// The level of detail provided in the returned User structure depends on
  /// the access level granted by the token, so a web service client may receive
  /// fewer fields than an integrated desktop client.
  fn get_user(&mut self, authentication_token: String) -> thrift::Result<types::User>;
  /// Asks the UserStore about the publicly available location information for
  /// a particular username.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "username" - username is empty
  /// </ul>
  fn get_public_user_info(&mut self, username: String) -> thrift::Result<PublicUserInfo>;
  /// <p>Returns the URLs that should be used when sending requests to the service on
  /// behalf of the account represented by the provided authenticationToken.</p>
  /// 
  /// <p>This method isn't needed by most clients, who can retreive the correct set of
  /// UserUrls from the AuthenticationResult returned from
  /// UserStore#authenticateLongSession(). This method is typically only needed to look up
  /// the correct URLs for an existing long-lived authentication token.</p>
  fn get_user_urls(&mut self, authentication_token: String) -> thrift::Result<UserUrls>;
  /// Invite a user to join an Evernote Business account.
  /// 
  /// Behavior will depend on the auth token. <ol>
  ///   <li>
  ///     auth token with privileges to manage Evernote Business membership.
  ///       "External Provisioning" - The user will receive an email inviting
  ///       them to join the business. They do not need to have an existing Evernote
  ///       account. If the user has already been invited, a new invitation email
  ///       will be sent.
  ///   </li>
  ///   <li>
  ///     business auth token issued to an admin user. Only for first-party clients:
  ///       "Approve Invitation" - If there has been a request to invite the email,
  ///       approve it. Invited user will receive email with a link to join business.
  ///       "Invite User" - If no invitation for the email exists, create an approved
  ///       invitation for the email. An email will be sent to the emailAddress with
  ///       a link to join the caller's business.
  ///   </li>
  ///   </li>
  ///     business auth token:
  ///       "Request Invitation" - If no invitation exists, create a request to
  ///       invite the user to the business. These requests do not count towards a
  ///       business' max active user limit.
  ///   </li>
  /// </ol>
  /// 
  /// @param authenticationToken
  ///   the authentication token with sufficient privileges to manage Evernote Business
  ///   membership or a business auth token.
  /// 
  /// @param emailAddress
  ///   the email address of the user to invite to join the Evernote Business account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
  ///   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
  ///   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
  ///     whose business email address matches the specified email address. </li>
  ///   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
  ///     user limit. </li>
  /// </ul>
  fn invite_to_business(&mut self, authentication_token: String, email_address: String) -> thrift::Result<()>;
  /// Remove a user from an Evernote Business account. Once removed, the user will no
  /// longer be able to access content within the Evernote Business account.
  /// 
  /// <p>The email address of the user to remove from the business must match the email
  /// address used to invite a user to join the business via UserStore.inviteToBusiness.
  /// This function will only remove users who were invited by external provisioning</p>
  /// 
  /// @param authenticationToken
  ///   An authentication token with sufficient privileges to manage Evernote Business
  ///   membership.
  /// 
  /// @param emailAddress
  ///   The email address of the user to remove from the Evernote Business account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
  ///   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
  /// </ul>
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "email" - If there is no user with the specified email address in the
  ///     business or that user was not invited via external provisioning. </li>
  /// </ul>
  fn remove_from_business(&mut self, authentication_token: String, email_address: String) -> thrift::Result<()>;
  /// Update the email address used to uniquely identify an Evernote Business user.
  /// 
  /// This will update the identifier for a user who was previously invited using
  /// inviteToBusiness, ensuring that caller and the Evernote service maintain an
  /// agreed-upon identifier for a specific user.
  /// 
  /// For example, the following sequence of calls would invite a user to join
  /// a business, update their email address, and then remove the user
  /// from the business using the updated email address.
  /// 
  /// inviteToBusiness("foo@bar.com")
  /// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
  /// removeFromBusiness("baz@bar.com")
  /// 
  /// @param authenticationToken
  ///   An authentication token with sufficient privileges to manage Evernote Business
  ///   membership.
  /// 
  /// @param oldEmailAddress
  ///   The existing email address used to uniquely identify the user.
  /// 
  /// @param newEmailAddress
  ///   The new email address used to uniquely identify the user.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
  ///   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
  ///   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
  ///   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
  ///   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
  ///   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
  ///     the provided new email address.</li>
  ///   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
  ///     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
  ///     updated.</li>
  /// </ul>
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
  ///     in the business.</li>
  /// </ul>
  fn update_business_user_identifier(&mut self, authentication_token: String, old_email_address: String, new_email_address: String) -> thrift::Result<()>;
  /// Returns a list of active business users in a given business.
  /// 
  /// Clients are required to cache this information and re-fetch no more than once per day
  /// or when they encountered a user ID or username that was not known to them.
  /// 
  /// To avoid excessive look ups, clients should also track user IDs and usernames that belong
  /// to users who are not in the business, since they will not be included in the result.
  /// 
  /// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
  /// listBusinessUsers to find information about this user. If the user is not in the resulting
  /// list, the client should track that fact and not re-query the service the next time that it sees
  /// this user on a note.
  /// 
  /// @param authenticationToken
  ///   A business authentication token returned by authenticateToBusiness or with sufficient
  ///   privileges to manage Evernote Business membership.
  fn list_business_users(&mut self, authentication_token: String) -> thrift::Result<Vec<types::UserProfile>>;
  /// Returns a list of outstanding invitations to join an Evernote Business account.
  /// 
  /// Only outstanding invitations are returned by this function. Users who have accepted an
  /// invitation and joined a business are listed using listBusinessUsers.
  /// 
  /// @param authenticationToken
  ///   An authentication token with sufficient privileges to manage Evernote Business membership.
  /// 
  /// @param includeRequestedInvitations
  ///   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
  ///   in the returned list. If false, only invitations with a status of
  ///   BusinessInvitationStatus.APPROVED will be included.
  fn list_business_invitations(&mut self, authentication_token: String, include_requested_invitations: bool) -> thrift::Result<Vec<types::BusinessInvitation>>;
  /// Retrieve the standard account limits for a given service level. This should only be
  /// called when necessary, e.g. to determine if a higher level is available should the
  /// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
  /// not expected to fluctuate frequently.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
  /// </ul>
  fn get_account_limits(&mut self, service_level: types::ServiceLevel) -> thrift::Result<types::AccountLimits>;
}

pub trait TUserStoreSyncClientMarker {}

pub struct UserStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> UserStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> UserStoreSyncClient<IP, OP> {
    UserStoreSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for UserStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TUserStoreSyncClientMarker for UserStoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TUserStoreSyncClientMarker> TUserStoreSyncClient for C {
  fn check_version(&mut self, client_name: String, edam_version_major: i16, edam_version_minor: i16) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("checkVersion", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreCheckVersionArgs { client_name, edam_version_major, edam_version_minor };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("checkVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreCheckVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_bootstrap_info(&mut self, locale: String) -> thrift::Result<BootstrapInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getBootstrapInfo", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreGetBootstrapInfoArgs { locale };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getBootstrapInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreGetBootstrapInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authenticate_long_session(&mut self, username: String, password: String, consumer_key: String, consumer_secret: String, device_identifier: String, device_description: String, supports_two_factor: bool) -> thrift::Result<AuthenticationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("authenticateLongSession", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreAuthenticateLongSessionArgs { username, password, consumer_key, consumer_secret, device_identifier, device_description, supports_two_factor };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("authenticateLongSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreAuthenticateLongSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn complete_two_factor_authentication(&mut self, authentication_token: String, one_time_code: String, device_identifier: String, device_description: String) -> thrift::Result<AuthenticationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("completeTwoFactorAuthentication", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreCompleteTwoFactorAuthenticationArgs { authentication_token, one_time_code, device_identifier, device_description };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("completeTwoFactorAuthentication", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreCompleteTwoFactorAuthenticationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn revoke_long_session(&mut self, authentication_token: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("revokeLongSession", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreRevokeLongSessionArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("revokeLongSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreRevokeLongSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authenticate_to_business(&mut self, authentication_token: String) -> thrift::Result<AuthenticationResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("authenticateToBusiness", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreAuthenticateToBusinessArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("authenticateToBusiness", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreAuthenticateToBusinessResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user(&mut self, authentication_token: String) -> thrift::Result<types::User> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUser", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreGetUserArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUser", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreGetUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_public_user_info(&mut self, username: String) -> thrift::Result<PublicUserInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreGetPublicUserInfoArgs { username };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getPublicUserInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreGetPublicUserInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_urls(&mut self, authentication_token: String) -> thrift::Result<UserUrls> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getUserUrls", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreGetUserUrlsArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getUserUrls", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreGetUserUrlsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn invite_to_business(&mut self, authentication_token: String, email_address: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("inviteToBusiness", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreInviteToBusinessArgs { authentication_token, email_address };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("inviteToBusiness", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreInviteToBusinessResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_from_business(&mut self, authentication_token: String, email_address: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreRemoveFromBusinessArgs { authentication_token, email_address };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("removeFromBusiness", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreRemoveFromBusinessResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_business_user_identifier(&mut self, authentication_token: String, old_email_address: String, new_email_address: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreUpdateBusinessUserIdentifierArgs { authentication_token, old_email_address, new_email_address };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updateBusinessUserIdentifier", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreUpdateBusinessUserIdentifierResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_business_users(&mut self, authentication_token: String) -> thrift::Result<Vec<types::UserProfile>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listBusinessUsers", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreListBusinessUsersArgs { authentication_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listBusinessUsers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreListBusinessUsersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_business_invitations(&mut self, authentication_token: String, include_requested_invitations: bool) -> thrift::Result<Vec<types::BusinessInvitation>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("listBusinessInvitations", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreListBusinessInvitationsArgs { authentication_token, include_requested_invitations };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("listBusinessInvitations", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreListBusinessInvitationsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_account_limits(&mut self, service_level: types::ServiceLevel) -> thrift::Result<types::AccountLimits> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getAccountLimits", TMessageType::Call, self.sequence_number());
        let call_args = UserStoreGetAccountLimitsArgs { service_level };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getAccountLimits", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UserStoreGetAccountLimitsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// UserStore service processor
//

/// Service:  UserStore
/// <p>
/// The UserStore service is primarily used by EDAM clients to establish
/// authentication via username and password over a trusted connection (e.g.
/// SSL).  A client's first call to this interface should be checkVersion() to
/// ensure that the client's software is up to date.
/// </p>
/// All calls which require an authenticationToken may throw an
/// EDAMUserException for the following reasons:
///  <ul>
///   <li> AUTH_EXPIRED "authenticationToken" - token has expired
///   <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
///   <li> DATA_REQUIRED "authenticationToken" - token is empty
///   <li> INVALID_AUTH "authenticationToken" - token signature is invalid
///   <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
///     privileges
/// </ul>
pub trait UserStoreSyncHandler {
  /// This should be the first call made by a client to the EDAM service.  It
  /// tells the service what protocol version is used by the client.  The
  /// service will then return true if the client is capable of talking to
  /// the service, and false if the client's protocol version is incompatible
  /// with the service, so the client must upgrade.  If a client receives a
  /// false value, it should report the incompatibility to the user and not
  /// continue with any more EDAM requests (UserStore or NoteStore).
  /// 
  /// @param clientName
  ///   This string provides some information about the client for
  ///   tracking/logging on the service.  It should provide information about
  ///   the client's software and platform. The structure should be:
  ///   application/version; platform/version; [ device/version ]
  ///   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
  /// 
  /// @param edamVersionMajor
  ///   This should be the major protocol version that was compiled by the
  ///   client.  This should be the current value of the EDAM_VERSION_MAJOR
  ///   constant for the client.
  /// 
  /// @param edamVersionMinor
  ///   This should be the major protocol version that was compiled by the
  ///   client.  This should be the current value of the EDAM_VERSION_MINOR
  ///   constant for the client.
  fn handle_check_version(&self, client_name: String, edam_version_major: i16, edam_version_minor: i16) -> thrift::Result<bool>;
  /// This provides bootstrap information to the client. Various bootstrap
  /// profiles and settings may be used by the client to configure itself.
  /// 
  /// @param locale
  ///   The client's current locale, expressed in language[_country]
  ///   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
  ///   language and country codes.
  /// 
  /// @return
  ///   The bootstrap information suitable for this client.
  fn handle_get_bootstrap_info(&self, locale: String) -> thrift::Result<BootstrapInfo>;
  /// This is used to check a username and password in order to create a
  /// long-lived authentication token that can be used for further actions.
  /// 
  /// This function is not available to most third party applications,
  /// which typically authenticate using OAuth as
  /// described at
  /// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
  /// If you believe that your application requires permission to authenticate
  /// using username and password instead of OAuth, please contact Evernote
  /// developer support by visiting
  /// <a href="http://dev.evernote.com">dev.evernote.com</a>.
  /// 
  /// @param username
  ///   The username or registered email address of the account to
  ///   authenticate against.
  /// 
  /// @param password
  ///   The plaintext password to check against the account.  Since
  ///   this is not protected by the EDAM protocol, this information must be
  ///   provided over a protected transport (i.e. SSL).
  /// 
  /// @param consumerKey
  ///   The "consumer key" portion of the API key issued to the client application
  ///   by Evernote.
  /// 
  /// @param consumerSecret
  ///   The "consumer secret" portion of the API key issued to the client application
  ///   by Evernote.
  /// 
  /// @param deviceIdentifier
  ///   An optional string that uniquely identifies the device from which the
  ///   authentication is being performed. This string allows the service to return the
  ///   same authentication token when a given application requests authentication
  ///   repeatedly from the same device. This may happen when the user logs out of an
  ///   application and then logs back in, or when the application is uninstalled
  ///   and later reinstalled. If no reliable device identifier can be created,
  ///   this value should be omitted. If set, the device identifier must be between
  ///   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
  ///   EDAM_DEVICE_ID_REGEX.
  /// 
  /// @param deviceDescription
  ///   A description of the device from which the authentication is being performed.
  ///   This field is displayed to the user in a list of authorized applications to
  ///   allow them to distinguish between multiple tokens issued to the same client
  ///   application on different devices. For example, the Evernote iOS client on
  ///   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
  ///   "Bob's iPad". The device description must be between 1 and
  ///   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
  ///   expression EDAM_DEVICE_DESCRIPTION_REGEX.
  /// 
  /// @param supportsTwoFactor
  ///   Whether the calling application supports two-factor authentication. If this
  ///   parameter is false, this method will fail with the error code INVALID_AUTH and the
  ///   parameter "password" when called for a user who has enabled two-factor
  ///   authentication.
  /// 
  /// @return
  ///   <p>The result of the authentication. The level of detail provided in the returned
  ///   AuthenticationResult.User structure depends on the access level granted by
  ///   calling application's API key.</p>
  ///   <p>If the user has two-factor authentication enabled,
  ///   AuthenticationResult.secondFactorRequired will be set and
  ///   AuthenticationResult.authenticationToken will contain a short-lived token
  ///   that may only be used to complete the two-factor authentication process by calling
  ///   UserStore.completeTwoFactorAuthentication.</p>
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "username" - username is empty
  ///   <li> DATA_REQUIRED "password" - password is empty
  ///   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
  ///   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
  ///   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
  ///   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
  ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
  ///   <li> INVALID_AUTH "username" - username not found
  ///   <li> INVALID_AUTH "password" - password did not match
  ///   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
  ///   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
  ///   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
  ///   <li> PERMISSION_DENIED "User.active" - user account is closed
  ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
  ///     failed authentication too often
  ///   <li> AUTH_EXPIRED "password" - user password is expired
  /// </ul>
  fn handle_authenticate_long_session(&self, username: String, password: String, consumer_key: String, consumer_secret: String, device_identifier: String, device_description: String, supports_two_factor: bool) -> thrift::Result<AuthenticationResult>;
  /// Complete the authentication process when a second factor is required. This
  /// call is made after a successful call to authenticate or authenticateLongSession
  /// when the authenticating user has enabled two-factor authentication.
  /// 
  /// @param authenticationToken An authentication token returned by a previous
  ///   call to UserStore.authenticate or UserStore.authenticateLongSession that
  ///   could not be completed in a single call because a second factor was required.
  /// 
  /// @param oneTimeCode The one time code entered by the user. This value is delivered
  ///   out-of-band, typically via SMS or an authenticator application.
  /// 
  /// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
  /// 
  /// @param deviceDescription See the corresponding parameter in authenticateLongSession.
  /// 
  /// @return
  ///   The result of the authentication. The level of detail provided in the returned
  ///   AuthenticationResult.User structure depends on the access level granted by the
  ///   calling application's API key. If the initial authentication call was made to
  ///   authenticateLongSession, the AuthenticationResult will contain a long-lived
  ///   authentication token.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
  ///   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
  ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
  ///   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
  ///   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
  ///   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
  ///   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
  ///   <li> PERMISSION_DENIED "User.active" - user account is closed
  ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
  ///     failed authentication too often
  ///   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
  ///      two-factor authentication.</li>
  /// </ul>
  fn handle_complete_two_factor_authentication(&self, authentication_token: String, one_time_code: String, device_identifier: String, device_description: String) -> thrift::Result<AuthenticationResult>;
  /// Revoke an existing long lived authentication token. This can be used to
  /// revoke OAuth tokens or tokens created by calling authenticateLongSession,
  /// and allows a user to effectively log out of Evernote from the perspective
  /// of the application that holds the token. The authentication token that is
  /// passed is immediately revoked and may not be used to call any authenticated
  /// EDAM function.
  /// 
  /// @param authenticationToken the authentication token to revoke.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
  ///   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
  ///   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
  ///   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
  ///     is already revoked.
  /// </ul>
  fn handle_revoke_long_session(&self, authentication_token: String) -> thrift::Result<()>;
  /// This is used to take an existing authentication token that grants access
  /// to an individual user account (returned from 'authenticate',
  /// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
  /// authentication token that may be used to access business notebooks if the user
  /// is a member of an Evernote Business account.
  /// 
  /// The resulting authentication token may be used to make NoteStore API calls
  /// against the business using the NoteStore URL returned in the result.
  /// 
  /// @param authenticationToken
  ///   The authentication token for the user. This may not be a shared authentication
  ///   token (returned by NoteStore.authenticateToSharedNotebook or
  ///   NoteStore.authenticateToSharedNote) or a business authentication token.
  /// 
  /// @return
  ///   The result of the authentication, with the token granting access to the
  ///   business in the result's 'authenticationToken' field. The URL that must
  ///   be used to access the business account NoteStore will be returned in the
  ///   result's 'noteStoreUrl' field.  The 'User' field will
  ///   not be set in the result.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
  ///        is a shared or business authentication token. </li>
  ///   <li> PERMISSION_DENIED "Business" - the user identified by the provided
  ///        authentication token is not currently a member of a business. </li>
  ///   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
  ///        member of is not currently in an active status. </li>
  ///   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
  ///        sign-on before authenticating to the business.
  /// </ul>
  fn handle_authenticate_to_business(&self, authentication_token: String) -> thrift::Result<AuthenticationResult>;
  /// Returns the User corresponding to the provided authentication token,
  /// or throws an exception if this token is not valid.
  /// The level of detail provided in the returned User structure depends on
  /// the access level granted by the token, so a web service client may receive
  /// fewer fields than an integrated desktop client.
  fn handle_get_user(&self, authentication_token: String) -> thrift::Result<types::User>;
  /// Asks the UserStore about the publicly available location information for
  /// a particular username.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "username" - username is empty
  /// </ul>
  fn handle_get_public_user_info(&self, username: String) -> thrift::Result<PublicUserInfo>;
  /// <p>Returns the URLs that should be used when sending requests to the service on
  /// behalf of the account represented by the provided authenticationToken.</p>
  /// 
  /// <p>This method isn't needed by most clients, who can retreive the correct set of
  /// UserUrls from the AuthenticationResult returned from
  /// UserStore#authenticateLongSession(). This method is typically only needed to look up
  /// the correct URLs for an existing long-lived authentication token.</p>
  fn handle_get_user_urls(&self, authentication_token: String) -> thrift::Result<UserUrls>;
  /// Invite a user to join an Evernote Business account.
  /// 
  /// Behavior will depend on the auth token. <ol>
  ///   <li>
  ///     auth token with privileges to manage Evernote Business membership.
  ///       "External Provisioning" - The user will receive an email inviting
  ///       them to join the business. They do not need to have an existing Evernote
  ///       account. If the user has already been invited, a new invitation email
  ///       will be sent.
  ///   </li>
  ///   <li>
  ///     business auth token issued to an admin user. Only for first-party clients:
  ///       "Approve Invitation" - If there has been a request to invite the email,
  ///       approve it. Invited user will receive email with a link to join business.
  ///       "Invite User" - If no invitation for the email exists, create an approved
  ///       invitation for the email. An email will be sent to the emailAddress with
  ///       a link to join the caller's business.
  ///   </li>
  ///   </li>
  ///     business auth token:
  ///       "Request Invitation" - If no invitation exists, create a request to
  ///       invite the user to the business. These requests do not count towards a
  ///       business' max active user limit.
  ///   </li>
  /// </ol>
  /// 
  /// @param authenticationToken
  ///   the authentication token with sufficient privileges to manage Evernote Business
  ///   membership or a business auth token.
  /// 
  /// @param emailAddress
  ///   the email address of the user to invite to join the Evernote Business account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
  ///   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
  ///   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
  ///     whose business email address matches the specified email address. </li>
  ///   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
  ///     user limit. </li>
  /// </ul>
  fn handle_invite_to_business(&self, authentication_token: String, email_address: String) -> thrift::Result<()>;
  /// Remove a user from an Evernote Business account. Once removed, the user will no
  /// longer be able to access content within the Evernote Business account.
  /// 
  /// <p>The email address of the user to remove from the business must match the email
  /// address used to invite a user to join the business via UserStore.inviteToBusiness.
  /// This function will only remove users who were invited by external provisioning</p>
  /// 
  /// @param authenticationToken
  ///   An authentication token with sufficient privileges to manage Evernote Business
  ///   membership.
  /// 
  /// @param emailAddress
  ///   The email address of the user to remove from the Evernote Business account.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
  ///   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
  /// </ul>
  /// @throws EDAMNotFoundException <ul>
  ///   <li> "email" - If there is no user with the specified email address in the
  ///     business or that user was not invited via external provisioning. </li>
  /// </ul>
  fn handle_remove_from_business(&self, authentication_token: String, email_address: String) -> thrift::Result<()>;
  /// Update the email address used to uniquely identify an Evernote Business user.
  /// 
  /// This will update the identifier for a user who was previously invited using
  /// inviteToBusiness, ensuring that caller and the Evernote service maintain an
  /// agreed-upon identifier for a specific user.
  /// 
  /// For example, the following sequence of calls would invite a user to join
  /// a business, update their email address, and then remove the user
  /// from the business using the updated email address.
  /// 
  /// inviteToBusiness("foo@bar.com")
  /// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
  /// removeFromBusiness("baz@bar.com")
  /// 
  /// @param authenticationToken
  ///   An authentication token with sufficient privileges to manage Evernote Business
  ///   membership.
  /// 
  /// @param oldEmailAddress
  ///   The existing email address used to uniquely identify the user.
  /// 
  /// @param newEmailAddress
  ///   The new email address used to uniquely identify the user.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
  ///   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
  ///   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
  ///   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
  ///   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
  ///   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
  ///     the provided new email address.</li>
  ///   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
  ///     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
  ///     updated.</li>
  /// </ul>
  /// @throws EDAMNotFoundException <ul>
  ///   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
  ///     in the business.</li>
  /// </ul>
  fn handle_update_business_user_identifier(&self, authentication_token: String, old_email_address: String, new_email_address: String) -> thrift::Result<()>;
  /// Returns a list of active business users in a given business.
  /// 
  /// Clients are required to cache this information and re-fetch no more than once per day
  /// or when they encountered a user ID or username that was not known to them.
  /// 
  /// To avoid excessive look ups, clients should also track user IDs and usernames that belong
  /// to users who are not in the business, since they will not be included in the result.
  /// 
  /// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
  /// listBusinessUsers to find information about this user. If the user is not in the resulting
  /// list, the client should track that fact and not re-query the service the next time that it sees
  /// this user on a note.
  /// 
  /// @param authenticationToken
  ///   A business authentication token returned by authenticateToBusiness or with sufficient
  ///   privileges to manage Evernote Business membership.
  fn handle_list_business_users(&self, authentication_token: String) -> thrift::Result<Vec<types::UserProfile>>;
  /// Returns a list of outstanding invitations to join an Evernote Business account.
  /// 
  /// Only outstanding invitations are returned by this function. Users who have accepted an
  /// invitation and joined a business are listed using listBusinessUsers.
  /// 
  /// @param authenticationToken
  ///   An authentication token with sufficient privileges to manage Evernote Business membership.
  /// 
  /// @param includeRequestedInvitations
  ///   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
  ///   in the returned list. If false, only invitations with a status of
  ///   BusinessInvitationStatus.APPROVED will be included.
  fn handle_list_business_invitations(&self, authentication_token: String, include_requested_invitations: bool) -> thrift::Result<Vec<types::BusinessInvitation>>;
  /// Retrieve the standard account limits for a given service level. This should only be
  /// called when necessary, e.g. to determine if a higher level is available should the
  /// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
  /// not expected to fluctuate frequently.
  /// 
  /// @throws EDAMUserException <ul>
  ///   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
  /// </ul>
  fn handle_get_account_limits(&self, service_level: types::ServiceLevel) -> thrift::Result<types::AccountLimits>;
}

pub struct UserStoreSyncProcessor<H: UserStoreSyncHandler> {
  handler: H,
}

impl <H: UserStoreSyncHandler> UserStoreSyncProcessor<H> {
  pub fn new(handler: H) -> UserStoreSyncProcessor<H> {
    UserStoreSyncProcessor {
      handler,
    }
  }
  fn process_check_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_check_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_bootstrap_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_get_bootstrap_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authenticate_long_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_authenticate_long_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_complete_two_factor_authentication(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_complete_two_factor_authentication(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_revoke_long_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_revoke_long_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authenticate_to_business(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_authenticate_to_business(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_get_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_public_user_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_get_public_user_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_urls(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_get_user_urls(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_invite_to_business(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_invite_to_business(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_from_business(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_remove_from_business(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_business_user_identifier(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_update_business_user_identifier(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_business_users(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_list_business_users(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_business_invitations(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_list_business_invitations(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_account_limits(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TUserStoreProcessFunctions::process_get_account_limits(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TUserStoreProcessFunctions;

impl TUserStoreProcessFunctions {
  pub fn process_check_version<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreCheckVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_version(args.client_name, args.edam_version_major, args.edam_version_minor) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("checkVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreCheckVersionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("checkVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("checkVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_bootstrap_info<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreGetBootstrapInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_bootstrap_info(args.locale) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getBootstrapInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreGetBootstrapInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getBootstrapInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getBootstrapInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authenticate_long_session<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreAuthenticateLongSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authenticate_long_session(args.username, args.password, args.consumer_key, args.consumer_secret, args.device_identifier, args.device_description, args.supports_two_factor) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("authenticateLongSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreAuthenticateLongSessionResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreAuthenticateLongSessionResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("authenticateLongSession", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreAuthenticateLongSessionResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("authenticateLongSession", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("authenticateLongSession", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("authenticateLongSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("authenticateLongSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_complete_two_factor_authentication<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreCompleteTwoFactorAuthenticationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_complete_two_factor_authentication(args.authentication_token, args.one_time_code, args.device_identifier, args.device_description) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("completeTwoFactorAuthentication", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreCompleteTwoFactorAuthenticationResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreCompleteTwoFactorAuthenticationResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("completeTwoFactorAuthentication", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreCompleteTwoFactorAuthenticationResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("completeTwoFactorAuthentication", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("completeTwoFactorAuthentication", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("completeTwoFactorAuthentication", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("completeTwoFactorAuthentication", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_revoke_long_session<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreRevokeLongSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_revoke_long_session(args.authentication_token) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("revokeLongSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreRevokeLongSessionResult { user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreRevokeLongSessionResult{ user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("revokeLongSession", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreRevokeLongSessionResult{ user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("revokeLongSession", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("revokeLongSession", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("revokeLongSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("revokeLongSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authenticate_to_business<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreAuthenticateToBusinessArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authenticate_to_business(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("authenticateToBusiness", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreAuthenticateToBusinessResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreAuthenticateToBusinessResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("authenticateToBusiness", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreAuthenticateToBusinessResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("authenticateToBusiness", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("authenticateToBusiness", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("authenticateToBusiness", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("authenticateToBusiness", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreGetUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUser", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreGetUserResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreGetUserResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("getUser", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreGetUserResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUser", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getUser", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_public_user_info<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreGetPublicUserInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_public_user_info(args.username) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreGetPublicUserInfoResult { result_value: Some(handler_return), not_found_exception: None, system_exception: None, user_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = UserStoreGetPublicUserInfoResult{ result_value: None, not_found_exception: Some(*err), system_exception: None, user_exception: None };
              let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreGetPublicUserInfoResult{ result_value: None, not_found_exception: None, system_exception: Some(*err), user_exception: None };
              let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreGetPublicUserInfoResult{ result_value: None, not_found_exception: None, system_exception: None, user_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getPublicUserInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_urls<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreGetUserUrlsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_urls(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getUserUrls", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreGetUserUrlsResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreGetUserUrlsResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("getUserUrls", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreGetUserUrlsResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getUserUrls", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getUserUrls", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getUserUrls", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getUserUrls", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_invite_to_business<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreInviteToBusinessArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_invite_to_business(args.authentication_token, args.email_address) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("inviteToBusiness", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreInviteToBusinessResult { user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreInviteToBusinessResult{ user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("inviteToBusiness", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreInviteToBusinessResult{ user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("inviteToBusiness", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("inviteToBusiness", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("inviteToBusiness", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("inviteToBusiness", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_from_business<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreRemoveFromBusinessArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_from_business(args.authentication_token, args.email_address) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreRemoveFromBusinessResult { user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreRemoveFromBusinessResult{ user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreRemoveFromBusinessResult{ user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = UserStoreRemoveFromBusinessResult{ user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("removeFromBusiness", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_business_user_identifier<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreUpdateBusinessUserIdentifierArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_business_user_identifier(args.authentication_token, args.old_email_address, args.new_email_address) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreUpdateBusinessUserIdentifierResult { user_exception: None, system_exception: None, not_found_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreUpdateBusinessUserIdentifierResult{ user_exception: Some(*err), system_exception: None, not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreUpdateBusinessUserIdentifierResult{ user_exception: None, system_exception: Some(*err), not_found_exception: None };
              let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMNotFoundException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMNotFoundException>().expect("downcast already checked");
              let ret_err = UserStoreUpdateBusinessUserIdentifierResult{ user_exception: None, system_exception: None, not_found_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updateBusinessUserIdentifier", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_business_users<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreListBusinessUsersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_business_users(args.authentication_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listBusinessUsers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreListBusinessUsersResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreListBusinessUsersResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listBusinessUsers", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreListBusinessUsersResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listBusinessUsers", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listBusinessUsers", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listBusinessUsers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listBusinessUsers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_business_invitations<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreListBusinessInvitationsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_business_invitations(args.authentication_token, args.include_requested_invitations) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("listBusinessInvitations", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreListBusinessInvitationsResult { result_value: Some(handler_return), user_exception: None, system_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreListBusinessInvitationsResult{ result_value: None, user_exception: Some(*err), system_exception: None };
              let message_ident = TMessageIdentifier::new("listBusinessInvitations", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<errors::EDAMSystemException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMSystemException>().expect("downcast already checked");
              let ret_err = UserStoreListBusinessInvitationsResult{ result_value: None, user_exception: None, system_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("listBusinessInvitations", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("listBusinessInvitations", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("listBusinessInvitations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("listBusinessInvitations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_account_limits<H: UserStoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = UserStoreGetAccountLimitsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_account_limits(args.service_level) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getAccountLimits", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UserStoreGetAccountLimitsResult { result_value: Some(handler_return), user_exception: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<errors::EDAMUserException>().is_some() {
              let err = usr_err.downcast::<errors::EDAMUserException>().expect("downcast already checked");
              let ret_err = UserStoreGetAccountLimitsResult{ result_value: None, user_exception: Some(*err) };
              let message_ident = TMessageIdentifier::new("getAccountLimits", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getAccountLimits", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getAccountLimits", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getAccountLimits", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: UserStoreSyncHandler> TProcessor for UserStoreSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "checkVersion" => {
        self.process_check_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "getBootstrapInfo" => {
        self.process_get_bootstrap_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "authenticateLongSession" => {
        self.process_authenticate_long_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "completeTwoFactorAuthentication" => {
        self.process_complete_two_factor_authentication(message_ident.sequence_number, i_prot, o_prot)
      },
      "revokeLongSession" => {
        self.process_revoke_long_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "authenticateToBusiness" => {
        self.process_authenticate_to_business(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUser" => {
        self.process_get_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "getPublicUserInfo" => {
        self.process_get_public_user_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "getUserUrls" => {
        self.process_get_user_urls(message_ident.sequence_number, i_prot, o_prot)
      },
      "inviteToBusiness" => {
        self.process_invite_to_business(message_ident.sequence_number, i_prot, o_prot)
      },
      "removeFromBusiness" => {
        self.process_remove_from_business(message_ident.sequence_number, i_prot, o_prot)
      },
      "updateBusinessUserIdentifier" => {
        self.process_update_business_user_identifier(message_ident.sequence_number, i_prot, o_prot)
      },
      "listBusinessUsers" => {
        self.process_list_business_users(message_ident.sequence_number, i_prot, o_prot)
      },
      "listBusinessInvitations" => {
        self.process_list_business_invitations(message_ident.sequence_number, i_prot, o_prot)
      },
      "getAccountLimits" => {
        self.process_get_account_limits(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// UserStoreCheckVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreCheckVersionArgs {
  client_name: String,
  edam_version_major: i16,
  edam_version_minor: i16,
}

impl UserStoreCheckVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreCheckVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i16> = None;
    let mut f_3: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i16()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreCheckVersionArgs.client_name", &f_1)?;
    verify_required_field_exists("UserStoreCheckVersionArgs.edam_version_major", &f_2)?;
    verify_required_field_exists("UserStoreCheckVersionArgs.edam_version_minor", &f_3)?;
    let ret = UserStoreCheckVersionArgs {
      client_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      edam_version_major: f_2.expect("auto-generated code should have checked for presence of required fields"),
      edam_version_minor: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("checkVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientName", TType::String, 1))?;
    o_prot.write_string(&self.client_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("edamVersionMajor", TType::I16, 2))?;
    o_prot.write_i16(self.edam_version_major)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("edamVersionMinor", TType::I16, 3))?;
    o_prot.write_i16(self.edam_version_minor)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreCheckVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreCheckVersionResult {
  result_value: Option<bool>,
}

impl UserStoreCheckVersionResult {
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreCheckVersion"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreCheckVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreCheckVersionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreCheckVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetBootstrapInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetBootstrapInfoArgs {
  locale: String,
}

impl UserStoreGetBootstrapInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetBootstrapInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreGetBootstrapInfoArgs.locale", &f_1)?;
    let ret = UserStoreGetBootstrapInfoArgs {
      locale: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getBootstrapInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("locale", TType::String, 1))?;
    o_prot.write_string(&self.locale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetBootstrapInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetBootstrapInfoResult {
  result_value: Option<BootstrapInfo>,
}

impl UserStoreGetBootstrapInfoResult {
  fn ok_or(self) -> thrift::Result<BootstrapInfo> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreGetBootstrapInfo"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetBootstrapInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BootstrapInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = BootstrapInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreGetBootstrapInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreGetBootstrapInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreAuthenticateLongSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreAuthenticateLongSessionArgs {
  username: String,
  password: String,
  consumer_key: String,
  consumer_secret: String,
  device_identifier: String,
  device_description: String,
  supports_two_factor: bool,
}

impl UserStoreAuthenticateLongSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreAuthenticateLongSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreAuthenticateLongSessionArgs.username", &f_1)?;
    verify_required_field_exists("UserStoreAuthenticateLongSessionArgs.password", &f_2)?;
    verify_required_field_exists("UserStoreAuthenticateLongSessionArgs.consumer_key", &f_3)?;
    verify_required_field_exists("UserStoreAuthenticateLongSessionArgs.consumer_secret", &f_4)?;
    verify_required_field_exists("UserStoreAuthenticateLongSessionArgs.device_identifier", &f_5)?;
    verify_required_field_exists("UserStoreAuthenticateLongSessionArgs.device_description", &f_6)?;
    verify_required_field_exists("UserStoreAuthenticateLongSessionArgs.supports_two_factor", &f_7)?;
    let ret = UserStoreAuthenticateLongSessionArgs {
      username: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      consumer_key: f_3.expect("auto-generated code should have checked for presence of required fields"),
      consumer_secret: f_4.expect("auto-generated code should have checked for presence of required fields"),
      device_identifier: f_5.expect("auto-generated code should have checked for presence of required fields"),
      device_description: f_6.expect("auto-generated code should have checked for presence of required fields"),
      supports_two_factor: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("authenticateLongSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 1))?;
    o_prot.write_string(&self.username)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consumerKey", TType::String, 3))?;
    o_prot.write_string(&self.consumer_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consumerSecret", TType::String, 4))?;
    o_prot.write_string(&self.consumer_secret)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceIdentifier", TType::String, 5))?;
    o_prot.write_string(&self.device_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceDescription", TType::String, 6))?;
    o_prot.write_string(&self.device_description)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("supportsTwoFactor", TType::Bool, 7))?;
    o_prot.write_bool(self.supports_two_factor)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreAuthenticateLongSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreAuthenticateLongSessionResult {
  result_value: Option<AuthenticationResult>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreAuthenticateLongSessionResult {
  fn ok_or(self) -> thrift::Result<AuthenticationResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreAuthenticateLongSession"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreAuthenticateLongSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AuthenticationResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AuthenticationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreAuthenticateLongSessionResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreAuthenticateLongSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreCompleteTwoFactorAuthenticationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreCompleteTwoFactorAuthenticationArgs {
  authentication_token: String,
  one_time_code: String,
  device_identifier: String,
  device_description: String,
}

impl UserStoreCompleteTwoFactorAuthenticationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreCompleteTwoFactorAuthenticationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreCompleteTwoFactorAuthenticationArgs.authentication_token", &f_1)?;
    verify_required_field_exists("UserStoreCompleteTwoFactorAuthenticationArgs.one_time_code", &f_2)?;
    verify_required_field_exists("UserStoreCompleteTwoFactorAuthenticationArgs.device_identifier", &f_3)?;
    verify_required_field_exists("UserStoreCompleteTwoFactorAuthenticationArgs.device_description", &f_4)?;
    let ret = UserStoreCompleteTwoFactorAuthenticationArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      one_time_code: f_2.expect("auto-generated code should have checked for presence of required fields"),
      device_identifier: f_3.expect("auto-generated code should have checked for presence of required fields"),
      device_description: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("completeTwoFactorAuthentication_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("oneTimeCode", TType::String, 2))?;
    o_prot.write_string(&self.one_time_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceIdentifier", TType::String, 3))?;
    o_prot.write_string(&self.device_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceDescription", TType::String, 4))?;
    o_prot.write_string(&self.device_description)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreCompleteTwoFactorAuthenticationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreCompleteTwoFactorAuthenticationResult {
  result_value: Option<AuthenticationResult>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreCompleteTwoFactorAuthenticationResult {
  fn ok_or(self) -> thrift::Result<AuthenticationResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreCompleteTwoFactorAuthentication"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreCompleteTwoFactorAuthenticationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AuthenticationResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AuthenticationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreCompleteTwoFactorAuthenticationResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreCompleteTwoFactorAuthenticationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreRevokeLongSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreRevokeLongSessionArgs {
  authentication_token: String,
}

impl UserStoreRevokeLongSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreRevokeLongSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreRevokeLongSessionArgs.authentication_token", &f_1)?;
    let ret = UserStoreRevokeLongSessionArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("revokeLongSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreRevokeLongSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreRevokeLongSessionResult {
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreRevokeLongSessionResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreRevokeLongSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreRevokeLongSessionResult {
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreRevokeLongSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreAuthenticateToBusinessArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreAuthenticateToBusinessArgs {
  authentication_token: String,
}

impl UserStoreAuthenticateToBusinessArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreAuthenticateToBusinessArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreAuthenticateToBusinessArgs.authentication_token", &f_1)?;
    let ret = UserStoreAuthenticateToBusinessArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("authenticateToBusiness_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreAuthenticateToBusinessResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreAuthenticateToBusinessResult {
  result_value: Option<AuthenticationResult>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreAuthenticateToBusinessResult {
  fn ok_or(self) -> thrift::Result<AuthenticationResult> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreAuthenticateToBusiness"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreAuthenticateToBusinessResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AuthenticationResult> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AuthenticationResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreAuthenticateToBusinessResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreAuthenticateToBusinessResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetUserArgs {
  authentication_token: String,
}

impl UserStoreGetUserArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreGetUserArgs.authentication_token", &f_1)?;
    let ret = UserStoreGetUserArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUser_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetUserResult {
  result_value: Option<types::User>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreGetUserResult {
  fn ok_or(self) -> thrift::Result<types::User> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreGetUser"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::User> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::User::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreGetUserResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreGetUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetPublicUserInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetPublicUserInfoArgs {
  username: String,
}

impl UserStoreGetPublicUserInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetPublicUserInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreGetPublicUserInfoArgs.username", &f_1)?;
    let ret = UserStoreGetPublicUserInfoArgs {
      username: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getPublicUserInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 1))?;
    o_prot.write_string(&self.username)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetPublicUserInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetPublicUserInfoResult {
  result_value: Option<PublicUserInfo>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
  system_exception: Option<errors::EDAMSystemException>,
  user_exception: Option<errors::EDAMUserException>,
}

impl UserStoreGetPublicUserInfoResult {
  fn ok_or(self) -> thrift::Result<PublicUserInfo> {
    if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreGetPublicUserInfo"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetPublicUserInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PublicUserInfo> = None;
    let mut f_1: Option<errors::EDAMNotFoundException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMUserException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PublicUserInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreGetPublicUserInfoResult {
      result_value: f_0,
      not_found_exception: f_1,
      system_exception: f_2,
      user_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreGetPublicUserInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetUserUrlsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetUserUrlsArgs {
  authentication_token: String,
}

impl UserStoreGetUserUrlsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetUserUrlsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreGetUserUrlsArgs.authentication_token", &f_1)?;
    let ret = UserStoreGetUserUrlsArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getUserUrls_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetUserUrlsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetUserUrlsResult {
  result_value: Option<UserUrls>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreGetUserUrlsResult {
  fn ok_or(self) -> thrift::Result<UserUrls> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreGetUserUrls"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetUserUrlsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UserUrls> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UserUrls::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreGetUserUrlsResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreGetUserUrlsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreInviteToBusinessArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreInviteToBusinessArgs {
  authentication_token: String,
  email_address: String,
}

impl UserStoreInviteToBusinessArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreInviteToBusinessArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreInviteToBusinessArgs.authentication_token", &f_1)?;
    verify_required_field_exists("UserStoreInviteToBusinessArgs.email_address", &f_2)?;
    let ret = UserStoreInviteToBusinessArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      email_address: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("inviteToBusiness_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("emailAddress", TType::String, 2))?;
    o_prot.write_string(&self.email_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreInviteToBusinessResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreInviteToBusinessResult {
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreInviteToBusinessResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreInviteToBusinessResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreInviteToBusinessResult {
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreInviteToBusinessResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreRemoveFromBusinessArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreRemoveFromBusinessArgs {
  authentication_token: String,
  email_address: String,
}

impl UserStoreRemoveFromBusinessArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreRemoveFromBusinessArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreRemoveFromBusinessArgs.authentication_token", &f_1)?;
    verify_required_field_exists("UserStoreRemoveFromBusinessArgs.email_address", &f_2)?;
    let ret = UserStoreRemoveFromBusinessArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      email_address: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("removeFromBusiness_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("emailAddress", TType::String, 2))?;
    o_prot.write_string(&self.email_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreRemoveFromBusinessResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreRemoveFromBusinessResult {
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl UserStoreRemoveFromBusinessResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreRemoveFromBusinessResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreRemoveFromBusinessResult {
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreRemoveFromBusinessResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreUpdateBusinessUserIdentifierArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreUpdateBusinessUserIdentifierArgs {
  authentication_token: String,
  old_email_address: String,
  new_email_address: String,
}

impl UserStoreUpdateBusinessUserIdentifierArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreUpdateBusinessUserIdentifierArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreUpdateBusinessUserIdentifierArgs.authentication_token", &f_1)?;
    verify_required_field_exists("UserStoreUpdateBusinessUserIdentifierArgs.old_email_address", &f_2)?;
    verify_required_field_exists("UserStoreUpdateBusinessUserIdentifierArgs.new_email_address", &f_3)?;
    let ret = UserStoreUpdateBusinessUserIdentifierArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      old_email_address: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_email_address: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updateBusinessUserIdentifier_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("oldEmailAddress", TType::String, 2))?;
    o_prot.write_string(&self.old_email_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("newEmailAddress", TType::String, 3))?;
    o_prot.write_string(&self.new_email_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreUpdateBusinessUserIdentifierResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreUpdateBusinessUserIdentifierResult {
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
  not_found_exception: Option<errors::EDAMNotFoundException>,
}

impl UserStoreUpdateBusinessUserIdentifierResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.not_found_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.not_found_exception.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreUpdateBusinessUserIdentifierResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    let mut f_3: Option<errors::EDAMNotFoundException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = errors::EDAMNotFoundException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreUpdateBusinessUserIdentifierResult {
      user_exception: f_1,
      system_exception: f_2,
      not_found_exception: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreUpdateBusinessUserIdentifierResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.not_found_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("notFoundException", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreListBusinessUsersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreListBusinessUsersArgs {
  authentication_token: String,
}

impl UserStoreListBusinessUsersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreListBusinessUsersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreListBusinessUsersArgs.authentication_token", &f_1)?;
    let ret = UserStoreListBusinessUsersArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listBusinessUsers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreListBusinessUsersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreListBusinessUsersResult {
  result_value: Option<Vec<types::UserProfile>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreListBusinessUsersResult {
  fn ok_or(self) -> thrift::Result<Vec<types::UserProfile>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreListBusinessUsers"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreListBusinessUsersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::UserProfile>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::UserProfile> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = types::UserProfile::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreListBusinessUsersResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreListBusinessUsersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreListBusinessInvitationsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreListBusinessInvitationsArgs {
  authentication_token: String,
  include_requested_invitations: bool,
}

impl UserStoreListBusinessInvitationsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreListBusinessInvitationsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreListBusinessInvitationsArgs.authentication_token", &f_1)?;
    verify_required_field_exists("UserStoreListBusinessInvitationsArgs.include_requested_invitations", &f_2)?;
    let ret = UserStoreListBusinessInvitationsArgs {
      authentication_token: f_1.expect("auto-generated code should have checked for presence of required fields"),
      include_requested_invitations: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("listBusinessInvitations_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 1))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeRequestedInvitations", TType::Bool, 2))?;
    o_prot.write_bool(self.include_requested_invitations)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreListBusinessInvitationsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreListBusinessInvitationsResult {
  result_value: Option<Vec<types::BusinessInvitation>>,
  user_exception: Option<errors::EDAMUserException>,
  system_exception: Option<errors::EDAMSystemException>,
}

impl UserStoreListBusinessInvitationsResult {
  fn ok_or(self) -> thrift::Result<Vec<types::BusinessInvitation>> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.system_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.system_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreListBusinessInvitations"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreListBusinessInvitationsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<types::BusinessInvitation>> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    let mut f_2: Option<errors::EDAMSystemException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::BusinessInvitation> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = types::BusinessInvitation::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = errors::EDAMSystemException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreListBusinessInvitationsResult {
      result_value: f_0,
      user_exception: f_1,
      system_exception: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreListBusinessInvitationsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.system_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("systemException", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetAccountLimitsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetAccountLimitsArgs {
  service_level: types::ServiceLevel,
}

impl UserStoreGetAccountLimitsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetAccountLimitsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::ServiceLevel> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::ServiceLevel::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UserStoreGetAccountLimitsArgs.service_level", &f_1)?;
    let ret = UserStoreGetAccountLimitsArgs {
      service_level: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getAccountLimits_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serviceLevel", TType::I32, 1))?;
    self.service_level.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UserStoreGetAccountLimitsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UserStoreGetAccountLimitsResult {
  result_value: Option<types::AccountLimits>,
  user_exception: Option<errors::EDAMUserException>,
}

impl UserStoreGetAccountLimitsResult {
  fn ok_or(self) -> thrift::Result<types::AccountLimits> {
    if self.user_exception.is_some() {
      Err(thrift::Error::User(Box::new(self.user_exception.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UserStoreGetAccountLimits"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UserStoreGetAccountLimitsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<types::AccountLimits> = None;
    let mut f_1: Option<errors::EDAMUserException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = types::AccountLimits::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = errors::EDAMUserException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserStoreGetAccountLimitsResult {
      result_value: f_0,
      user_exception: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserStoreGetAccountLimitsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_exception {
      o_prot.write_field_begin(&TFieldIdentifier::new("userException", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

